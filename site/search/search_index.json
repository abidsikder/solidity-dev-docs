{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"prb-math/PRBMath/","text":"PRBMath__MulDivFixedPointOverflow error PRBMath__MulDivFixedPointOverflow(uint256 prod1) Emitted when the result overflows uint256. PRBMath__MulDivOverflow error PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator) Emitted when the result overflows uint256. PRBMath__MulDivSignedInputTooSmall error PRBMath__MulDivSignedInputTooSmall() Emitted when one of the inputs is type(int256).min. PRBMath__MulDivSignedOverflow error PRBMath__MulDivSignedOverflow(uint256 rAbs) Emitted when the intermediary absolute result overflows int256. PRBMathSD59x18__AbsInputTooSmall error PRBMathSD59x18__AbsInputTooSmall() Emitted when the input is MIN_SD59x18. PRBMathSD59x18__CeilOverflow error PRBMathSD59x18__CeilOverflow(int256 x) Emitted when ceiling a number overflows SD59x18. PRBMathSD59x18__DivInputTooSmall error PRBMathSD59x18__DivInputTooSmall() Emitted when one of the inputs is MIN_SD59x18. PRBMathSD59x18__DivOverflow error PRBMathSD59x18__DivOverflow(uint256 rAbs) Emitted when one of the intermediary unsigned results overflows SD59x18. PRBMathSD59x18__ExpInputTooBig error PRBMathSD59x18__ExpInputTooBig(int256 x) Emitted when the input is greater than 133.084258667509499441. PRBMathSD59x18__Exp2InputTooBig error PRBMathSD59x18__Exp2InputTooBig(int256 x) Emitted when the input is greater than 192. PRBMathSD59x18__FloorUnderflow error PRBMathSD59x18__FloorUnderflow(int256 x) Emitted when flooring a number underflows SD59x18. PRBMathSD59x18__FromIntOverflow error PRBMathSD59x18__FromIntOverflow(int256 x) Emitted when converting a basic integer to the fixed-point format overflows SD59x18. PRBMathSD59x18__FromIntUnderflow error PRBMathSD59x18__FromIntUnderflow(int256 x) Emitted when converting a basic integer to the fixed-point format underflows SD59x18. PRBMathSD59x18__GmNegativeProduct error PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y) Emitted when the product of the inputs is negative. PRBMathSD59x18__GmOverflow error PRBMathSD59x18__GmOverflow(int256 x, int256 y) Emitted when multiplying the inputs overflows SD59x18. PRBMathSD59x18__LogInputTooSmall error PRBMathSD59x18__LogInputTooSmall(int256 x) Emitted when the input is less than or equal to zero. PRBMathSD59x18__MulInputTooSmall error PRBMathSD59x18__MulInputTooSmall() Emitted when one of the inputs is MIN_SD59x18. PRBMathSD59x18__MulOverflow error PRBMathSD59x18__MulOverflow(uint256 rAbs) Emitted when the intermediary absolute result overflows SD59x18. PRBMathSD59x18__PowuOverflow error PRBMathSD59x18__PowuOverflow(uint256 rAbs) Emitted when the intermediary absolute result overflows SD59x18. PRBMathSD59x18__SqrtNegativeInput error PRBMathSD59x18__SqrtNegativeInput(int256 x) Emitted when the input is negative. PRBMathSD59x18__SqrtOverflow error PRBMathSD59x18__SqrtOverflow(int256 x) Emitted when the calculating the square root overflows SD59x18. PRBMathUD60x18__AddOverflow error PRBMathUD60x18__AddOverflow(uint256 x, uint256 y) Emitted when addition overflows UD60x18. PRBMathUD60x18__CeilOverflow error PRBMathUD60x18__CeilOverflow(uint256 x) Emitted when ceiling a number overflows UD60x18. PRBMathUD60x18__ExpInputTooBig error PRBMathUD60x18__ExpInputTooBig(uint256 x) Emitted when the input is greater than 133.084258667509499441. PRBMathUD60x18__Exp2InputTooBig error PRBMathUD60x18__Exp2InputTooBig(uint256 x) Emitted when the input is greater than 192. PRBMathUD60x18__FromUintOverflow error PRBMathUD60x18__FromUintOverflow(uint256 x) Emitted when converting a basic integer to the fixed-point format format overflows UD60x18. PRBMathUD60x18__GmOverflow error PRBMathUD60x18__GmOverflow(uint256 x, uint256 y) Emitted when multiplying the inputs overflows UD60x18. PRBMathUD60x18__LogInputTooSmall error PRBMathUD60x18__LogInputTooSmall(uint256 x) Emitted when the input is less than 1. PRBMathUD60x18__SqrtOverflow error PRBMathUD60x18__SqrtOverflow(uint256 x) Emitted when the calculating the square root overflows UD60x18. PRBMathUD60x18__SubUnderflow error PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y) Emitted when subtraction underflows UD60x18. PRBMath Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point representation. When it does not, it is explicitly mentioned in the NatSpec documentation. SD59x18 struct SD59x18 { int256 value; } UD60x18 struct UD60x18 { uint256 value; } SCALE uint256 SCALE How many trailing decimals can be represented. SCALE_LPOTD uint256 SCALE_LPOTD Largest power of two divisor of SCALE. SCALE_INVERSE uint256 SCALE_INVERSE SCALE inverted mod 2^256. exp2 function exp2(uint256 x) internal pure returns (uint256 result) Calculates the binary exponent of x using the binary fraction method. Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693. Name Type Description x uint256 The exponent as an unsigned 192.64-bit fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number. mostSignificantBit function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) Finds the zero-based index of the first one in the binary representation of x. See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set Name Type Description x uint256 The uint256 number for which to find the index of the most significant bit. Name Type Description msb uint256 The index of the most significant bit as an uint256. mulDiv function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) Calculates floor(x*y\u00f7denominator) with full precision. _Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv. Requirements: - The denominator cannot be zero. - The result must fit within uint256. Caveats: - This function does not work with fixed-point numbers._ Name Type Description x uint256 The multiplicand as an uint256. y uint256 The multiplier as an uint256. denominator uint256 The divisor as an uint256. Name Type Description result uint256 The result as an uint256. mulDivFixedPoint function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) Calculates floor(x*y\u00f71e18) with full precision. _Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of being rounded to 1e-18. See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717. Requirements: - The result must fit within uint256. Caveats: - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works. - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations: 1. x * y = type(uint256).max * SCALE 2. (x * y) % SCALE >= SCALE / 2_ Name Type Description x uint256 The multiplicand as an unsigned 60.18-decimal fixed-point number. y uint256 The multiplier as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number. mulDivSigned function mulDivSigned(int256 x, int256 y, int256 denominator) internal pure returns (int256 result) Calculates floor(x*y\u00f7denominator) with full precision. _An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately. Requirements: - None of the inputs can be type(int256).min. - The result must fit within int256._ Name Type Description x int256 The multiplicand as an int256. y int256 The multiplier as an int256. denominator int256 The divisor as an int256. Name Type Description result int256 The result as an int256. sqrt function sqrt(uint256 x) internal pure returns (uint256 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Caveats: - This function does not work with fixed-point numbers._ Name Type Description x uint256 The uint256 number for which to calculate the square root. Name Type Description result uint256 The result as an uint256.","title":"PRBMath"},{"location":"prb-math/PRBMath/#prbmath__muldivfixedpointoverflow","text":"error PRBMath__MulDivFixedPointOverflow(uint256 prod1) Emitted when the result overflows uint256.","title":"PRBMath__MulDivFixedPointOverflow"},{"location":"prb-math/PRBMath/#prbmath__muldivoverflow","text":"error PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator) Emitted when the result overflows uint256.","title":"PRBMath__MulDivOverflow"},{"location":"prb-math/PRBMath/#prbmath__muldivsignedinputtoosmall","text":"error PRBMath__MulDivSignedInputTooSmall() Emitted when one of the inputs is type(int256).min.","title":"PRBMath__MulDivSignedInputTooSmall"},{"location":"prb-math/PRBMath/#prbmath__muldivsignedoverflow","text":"error PRBMath__MulDivSignedOverflow(uint256 rAbs) Emitted when the intermediary absolute result overflows int256.","title":"PRBMath__MulDivSignedOverflow"},{"location":"prb-math/PRBMath/#prbmathsd59x18__absinputtoosmall","text":"error PRBMathSD59x18__AbsInputTooSmall() Emitted when the input is MIN_SD59x18.","title":"PRBMathSD59x18__AbsInputTooSmall"},{"location":"prb-math/PRBMath/#prbmathsd59x18__ceiloverflow","text":"error PRBMathSD59x18__CeilOverflow(int256 x) Emitted when ceiling a number overflows SD59x18.","title":"PRBMathSD59x18__CeilOverflow"},{"location":"prb-math/PRBMath/#prbmathsd59x18__divinputtoosmall","text":"error PRBMathSD59x18__DivInputTooSmall() Emitted when one of the inputs is MIN_SD59x18.","title":"PRBMathSD59x18__DivInputTooSmall"},{"location":"prb-math/PRBMath/#prbmathsd59x18__divoverflow","text":"error PRBMathSD59x18__DivOverflow(uint256 rAbs) Emitted when one of the intermediary unsigned results overflows SD59x18.","title":"PRBMathSD59x18__DivOverflow"},{"location":"prb-math/PRBMath/#prbmathsd59x18__expinputtoobig","text":"error PRBMathSD59x18__ExpInputTooBig(int256 x) Emitted when the input is greater than 133.084258667509499441.","title":"PRBMathSD59x18__ExpInputTooBig"},{"location":"prb-math/PRBMath/#prbmathsd59x18__exp2inputtoobig","text":"error PRBMathSD59x18__Exp2InputTooBig(int256 x) Emitted when the input is greater than 192.","title":"PRBMathSD59x18__Exp2InputTooBig"},{"location":"prb-math/PRBMath/#prbmathsd59x18__floorunderflow","text":"error PRBMathSD59x18__FloorUnderflow(int256 x) Emitted when flooring a number underflows SD59x18.","title":"PRBMathSD59x18__FloorUnderflow"},{"location":"prb-math/PRBMath/#prbmathsd59x18__fromintoverflow","text":"error PRBMathSD59x18__FromIntOverflow(int256 x) Emitted when converting a basic integer to the fixed-point format overflows SD59x18.","title":"PRBMathSD59x18__FromIntOverflow"},{"location":"prb-math/PRBMath/#prbmathsd59x18__fromintunderflow","text":"error PRBMathSD59x18__FromIntUnderflow(int256 x) Emitted when converting a basic integer to the fixed-point format underflows SD59x18.","title":"PRBMathSD59x18__FromIntUnderflow"},{"location":"prb-math/PRBMath/#prbmathsd59x18__gmnegativeproduct","text":"error PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y) Emitted when the product of the inputs is negative.","title":"PRBMathSD59x18__GmNegativeProduct"},{"location":"prb-math/PRBMath/#prbmathsd59x18__gmoverflow","text":"error PRBMathSD59x18__GmOverflow(int256 x, int256 y) Emitted when multiplying the inputs overflows SD59x18.","title":"PRBMathSD59x18__GmOverflow"},{"location":"prb-math/PRBMath/#prbmathsd59x18__loginputtoosmall","text":"error PRBMathSD59x18__LogInputTooSmall(int256 x) Emitted when the input is less than or equal to zero.","title":"PRBMathSD59x18__LogInputTooSmall"},{"location":"prb-math/PRBMath/#prbmathsd59x18__mulinputtoosmall","text":"error PRBMathSD59x18__MulInputTooSmall() Emitted when one of the inputs is MIN_SD59x18.","title":"PRBMathSD59x18__MulInputTooSmall"},{"location":"prb-math/PRBMath/#prbmathsd59x18__muloverflow","text":"error PRBMathSD59x18__MulOverflow(uint256 rAbs) Emitted when the intermediary absolute result overflows SD59x18.","title":"PRBMathSD59x18__MulOverflow"},{"location":"prb-math/PRBMath/#prbmathsd59x18__powuoverflow","text":"error PRBMathSD59x18__PowuOverflow(uint256 rAbs) Emitted when the intermediary absolute result overflows SD59x18.","title":"PRBMathSD59x18__PowuOverflow"},{"location":"prb-math/PRBMath/#prbmathsd59x18__sqrtnegativeinput","text":"error PRBMathSD59x18__SqrtNegativeInput(int256 x) Emitted when the input is negative.","title":"PRBMathSD59x18__SqrtNegativeInput"},{"location":"prb-math/PRBMath/#prbmathsd59x18__sqrtoverflow","text":"error PRBMathSD59x18__SqrtOverflow(int256 x) Emitted when the calculating the square root overflows SD59x18.","title":"PRBMathSD59x18__SqrtOverflow"},{"location":"prb-math/PRBMath/#prbmathud60x18__addoverflow","text":"error PRBMathUD60x18__AddOverflow(uint256 x, uint256 y) Emitted when addition overflows UD60x18.","title":"PRBMathUD60x18__AddOverflow"},{"location":"prb-math/PRBMath/#prbmathud60x18__ceiloverflow","text":"error PRBMathUD60x18__CeilOverflow(uint256 x) Emitted when ceiling a number overflows UD60x18.","title":"PRBMathUD60x18__CeilOverflow"},{"location":"prb-math/PRBMath/#prbmathud60x18__expinputtoobig","text":"error PRBMathUD60x18__ExpInputTooBig(uint256 x) Emitted when the input is greater than 133.084258667509499441.","title":"PRBMathUD60x18__ExpInputTooBig"},{"location":"prb-math/PRBMath/#prbmathud60x18__exp2inputtoobig","text":"error PRBMathUD60x18__Exp2InputTooBig(uint256 x) Emitted when the input is greater than 192.","title":"PRBMathUD60x18__Exp2InputTooBig"},{"location":"prb-math/PRBMath/#prbmathud60x18__fromuintoverflow","text":"error PRBMathUD60x18__FromUintOverflow(uint256 x) Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.","title":"PRBMathUD60x18__FromUintOverflow"},{"location":"prb-math/PRBMath/#prbmathud60x18__gmoverflow","text":"error PRBMathUD60x18__GmOverflow(uint256 x, uint256 y) Emitted when multiplying the inputs overflows UD60x18.","title":"PRBMathUD60x18__GmOverflow"},{"location":"prb-math/PRBMath/#prbmathud60x18__loginputtoosmall","text":"error PRBMathUD60x18__LogInputTooSmall(uint256 x) Emitted when the input is less than 1.","title":"PRBMathUD60x18__LogInputTooSmall"},{"location":"prb-math/PRBMath/#prbmathud60x18__sqrtoverflow","text":"error PRBMathUD60x18__SqrtOverflow(uint256 x) Emitted when the calculating the square root overflows UD60x18.","title":"PRBMathUD60x18__SqrtOverflow"},{"location":"prb-math/PRBMath/#prbmathud60x18__subunderflow","text":"error PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y) Emitted when subtraction underflows UD60x18.","title":"PRBMathUD60x18__SubUnderflow"},{"location":"prb-math/PRBMath/#prbmath","text":"Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point representation. When it does not, it is explicitly mentioned in the NatSpec documentation.","title":"PRBMath"},{"location":"prb-math/PRBMath/#sd59x18","text":"struct SD59x18 { int256 value; }","title":"SD59x18"},{"location":"prb-math/PRBMath/#ud60x18","text":"struct UD60x18 { uint256 value; }","title":"UD60x18"},{"location":"prb-math/PRBMath/#scale","text":"uint256 SCALE How many trailing decimals can be represented.","title":"SCALE"},{"location":"prb-math/PRBMath/#scale_lpotd","text":"uint256 SCALE_LPOTD Largest power of two divisor of SCALE.","title":"SCALE_LPOTD"},{"location":"prb-math/PRBMath/#scale_inverse","text":"uint256 SCALE_INVERSE SCALE inverted mod 2^256.","title":"SCALE_INVERSE"},{"location":"prb-math/PRBMath/#exp2","text":"function exp2(uint256 x) internal pure returns (uint256 result) Calculates the binary exponent of x using the binary fraction method. Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693. Name Type Description x uint256 The exponent as an unsigned 192.64-bit fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number.","title":"exp2"},{"location":"prb-math/PRBMath/#mostsignificantbit","text":"function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) Finds the zero-based index of the first one in the binary representation of x. See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set Name Type Description x uint256 The uint256 number for which to find the index of the most significant bit. Name Type Description msb uint256 The index of the most significant bit as an uint256.","title":"mostSignificantBit"},{"location":"prb-math/PRBMath/#muldiv","text":"function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) Calculates floor(x*y\u00f7denominator) with full precision. _Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv. Requirements: - The denominator cannot be zero. - The result must fit within uint256. Caveats: - This function does not work with fixed-point numbers._ Name Type Description x uint256 The multiplicand as an uint256. y uint256 The multiplier as an uint256. denominator uint256 The divisor as an uint256. Name Type Description result uint256 The result as an uint256.","title":"mulDiv"},{"location":"prb-math/PRBMath/#muldivfixedpoint","text":"function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) Calculates floor(x*y\u00f71e18) with full precision. _Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of being rounded to 1e-18. See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717. Requirements: - The result must fit within uint256. Caveats: - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works. - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations: 1. x * y = type(uint256).max * SCALE 2. (x * y) % SCALE >= SCALE / 2_ Name Type Description x uint256 The multiplicand as an unsigned 60.18-decimal fixed-point number. y uint256 The multiplier as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number.","title":"mulDivFixedPoint"},{"location":"prb-math/PRBMath/#muldivsigned","text":"function mulDivSigned(int256 x, int256 y, int256 denominator) internal pure returns (int256 result) Calculates floor(x*y\u00f7denominator) with full precision. _An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately. Requirements: - None of the inputs can be type(int256).min. - The result must fit within int256._ Name Type Description x int256 The multiplicand as an int256. y int256 The multiplier as an int256. denominator int256 The divisor as an int256. Name Type Description result int256 The result as an int256.","title":"mulDivSigned"},{"location":"prb-math/PRBMath/#sqrt","text":"function sqrt(uint256 x) internal pure returns (uint256 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Caveats: - This function does not work with fixed-point numbers._ Name Type Description x uint256 The uint256 number for which to calculate the square root. Name Type Description result uint256 The result as an uint256.","title":"sqrt"},{"location":"prb-math/PRBMathSD59x18/","text":"PRBMathSD59x18 Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18 trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type int256. LOG2_E int256 LOG2_E log2(e) as a signed 59.18-decimal fixed-point number. HALF_SCALE int256 HALF_SCALE Half the SCALE number. MAX_SD59x18 int256 MAX_SD59x18 The maximum value a signed 59.18-decimal fixed-point number can have. MAX_WHOLE_SD59x18 int256 MAX_WHOLE_SD59x18 The maximum whole value a signed 59.18-decimal fixed-point number can have. MIN_SD59x18 int256 MIN_SD59x18 The minimum value a signed 59.18-decimal fixed-point number can have. MIN_WHOLE_SD59x18 int256 MIN_WHOLE_SD59x18 The minimum whole value a signed 59.18-decimal fixed-point number can have. SCALE int256 SCALE How many trailing decimals can be represented. abs function abs(int256 x) internal pure returns (int256 result) Calculate the absolute value of x. Requirements: - x must be greater than MIN_SD59x18. Name Type Description x int256 The number to calculate the absolute value for. avg function avg(int256 x, int256 y) internal pure returns (int256 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x int256 The first operand as a signed 59.18-decimal fixed-point number. y int256 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The arithmetic average as a signed 59.18-decimal fixed-point number. ceil function ceil(int256 x) internal pure returns (int256 result) Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_SD59x18._ Name Type Description x int256 The signed 59.18-decimal fixed-point number to ceil. div function div(int256 x, int256 y) internal pure returns (int256 result) Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers. Works by computing the signs and the absolute values separately. Requirements: - All from \"PRBMath.mulDiv\". - None of the inputs can be MIN_SD59x18. - The denominator cannot be zero. - The result must fit within int256. Caveats: - All from \"PRBMath.mulDiv\"._ Name Type Description x int256 The numerator as a signed 59.18-decimal fixed-point number. y int256 The denominator as a signed 59.18-decimal fixed-point number. e function e() internal pure returns (int256 result) Returns Euler's number as a signed 59.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._ exp function exp(int256 x) internal pure returns (int256 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 133.084258667509499441. Caveats: - All from \"exp2\". - For any x less than -41.446531673892822322, the result is zero._ Name Type Description x int256 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number. exp2 function exp2(int256 x) internal pure returns (int256 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_SD59x18. Caveats: - For any x less than -59.794705707972522261, the result is zero._ Name Type Description x int256 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number. floor function floor(int256 x) internal pure returns (int256 result) Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be greater than or equal to MIN_WHOLE_SD59x18._ Name Type Description x int256 The signed 59.18-decimal fixed-point number to floor. frac function frac(int256 x) internal pure returns (int256 result) Yields the excess beyond the floor of x for positive numbers and the part of the number to the right of the radix point for negative numbers. Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part Name Type Description x int256 The signed 59.18-decimal fixed-point number to get the fractional part of. fromInt function fromInt(int256 x) internal pure returns (int256 result) Converts a number from basic integer form to signed 59.18-decimal fixed-point representation. Requirements: - x must be greater than or equal to MIN_SD59x18 divided by SCALE. - x must be less than or equal to MAX_SD59x18 divided by SCALE. Name Type Description x int256 The basic integer to convert. gm function gm(int256 x, int256 y) internal pure returns (int256 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_SD59x18, lest it overflows. - x * y cannot be negative. Name Type Description x int256 The first operand as a signed 59.18-decimal fixed-point number. y int256 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number. inv function inv(int256 x) internal pure returns (int256 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result int256 The inverse as a signed 59.18-decimal fixed-point number. ln function ln(int256 x) internal pure returns (int256 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result int256 The natural logarithm as a signed 59.18-decimal fixed-point number. log10 function log10(int256 x) internal pure returns (int256 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result int256 The common logarithm as a signed 59.18-decimal fixed-point number. log2 function log2(int256 x) internal pure returns (int256 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than zero. Caveats: - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result int256 The binary logarithm as a signed 59.18-decimal fixed-point number. mul function mul(int256 x, int256 y) internal pure returns (int256 result) Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers and employs constant folding, i.e. the denominator is always 1e18. Requirements: - All from \"PRBMath.mulDivFixedPoint\". - None of the inputs can be MIN_SD59x18 - The result must fit within MAX_SD59x18. Caveats: - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works._ Name Type Description x int256 The multiplicand as a signed 59.18-decimal fixed-point number. y int256 The multiplier as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The product as a signed 59.18-decimal fixed-point number. pi function pi() internal pure returns (int256 result) Returns PI as a signed 59.18-decimal fixed-point number. pow function pow(int256 x, int256 y) internal pure returns (int256 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". - z cannot be zero. Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x int256 Number to raise to given power y, as a signed 59.18-decimal fixed-point number. y int256 Exponent to raise x to, as a signed 59.18-decimal fixed-point number. Name Type Description result int256 x raised to power y, as a signed 59.18-decimal fixed-point number. powu function powu(int256 x, uint256 y) internal pure returns (int256 result) Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - All from \"abs\" and \"PRBMath.mulDivFixedPoint\". - The result must fit within MAX_SD59x18. Caveats: - All from \"PRBMath.mulDivFixedPoint\". - Assumes 0^0 is 1._ Name Type Description x int256 The base as a signed 59.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number. scale function scale() internal pure returns (int256 result) Returns 1 as a signed 59.18-decimal fixed-point number. sqrt function sqrt(int256 x) internal pure returns (int256 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x cannot be negative. - x must be less than MAX_SD59x18 / SCALE._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the square root. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point . toInt function toInt(int256 x) internal pure returns (int256 result) Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x int256 The signed 59.18-decimal fixed-point number to convert. Name Type Description result int256 The same number in basic integer form.","title":"PRBMathSD59x18"},{"location":"prb-math/PRBMathSD59x18/#prbmathsd59x18","text":"Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18 trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type int256.","title":"PRBMathSD59x18"},{"location":"prb-math/PRBMathSD59x18/#log2_e","text":"int256 LOG2_E log2(e) as a signed 59.18-decimal fixed-point number.","title":"LOG2_E"},{"location":"prb-math/PRBMathSD59x18/#half_scale","text":"int256 HALF_SCALE Half the SCALE number.","title":"HALF_SCALE"},{"location":"prb-math/PRBMathSD59x18/#max_sd59x18","text":"int256 MAX_SD59x18 The maximum value a signed 59.18-decimal fixed-point number can have.","title":"MAX_SD59x18"},{"location":"prb-math/PRBMathSD59x18/#max_whole_sd59x18","text":"int256 MAX_WHOLE_SD59x18 The maximum whole value a signed 59.18-decimal fixed-point number can have.","title":"MAX_WHOLE_SD59x18"},{"location":"prb-math/PRBMathSD59x18/#min_sd59x18","text":"int256 MIN_SD59x18 The minimum value a signed 59.18-decimal fixed-point number can have.","title":"MIN_SD59x18"},{"location":"prb-math/PRBMathSD59x18/#min_whole_sd59x18","text":"int256 MIN_WHOLE_SD59x18 The minimum whole value a signed 59.18-decimal fixed-point number can have.","title":"MIN_WHOLE_SD59x18"},{"location":"prb-math/PRBMathSD59x18/#scale","text":"int256 SCALE How many trailing decimals can be represented.","title":"SCALE"},{"location":"prb-math/PRBMathSD59x18/#abs","text":"function abs(int256 x) internal pure returns (int256 result) Calculate the absolute value of x. Requirements: - x must be greater than MIN_SD59x18. Name Type Description x int256 The number to calculate the absolute value for.","title":"abs"},{"location":"prb-math/PRBMathSD59x18/#avg","text":"function avg(int256 x, int256 y) internal pure returns (int256 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x int256 The first operand as a signed 59.18-decimal fixed-point number. y int256 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The arithmetic average as a signed 59.18-decimal fixed-point number.","title":"avg"},{"location":"prb-math/PRBMathSD59x18/#ceil","text":"function ceil(int256 x) internal pure returns (int256 result) Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_SD59x18._ Name Type Description x int256 The signed 59.18-decimal fixed-point number to ceil.","title":"ceil"},{"location":"prb-math/PRBMathSD59x18/#div","text":"function div(int256 x, int256 y) internal pure returns (int256 result) Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers. Works by computing the signs and the absolute values separately. Requirements: - All from \"PRBMath.mulDiv\". - None of the inputs can be MIN_SD59x18. - The denominator cannot be zero. - The result must fit within int256. Caveats: - All from \"PRBMath.mulDiv\"._ Name Type Description x int256 The numerator as a signed 59.18-decimal fixed-point number. y int256 The denominator as a signed 59.18-decimal fixed-point number.","title":"div"},{"location":"prb-math/PRBMathSD59x18/#e","text":"function e() internal pure returns (int256 result) Returns Euler's number as a signed 59.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._","title":"e"},{"location":"prb-math/PRBMathSD59x18/#exp","text":"function exp(int256 x) internal pure returns (int256 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 133.084258667509499441. Caveats: - All from \"exp2\". - For any x less than -41.446531673892822322, the result is zero._ Name Type Description x int256 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number.","title":"exp"},{"location":"prb-math/PRBMathSD59x18/#exp2","text":"function exp2(int256 x) internal pure returns (int256 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_SD59x18. Caveats: - For any x less than -59.794705707972522261, the result is zero._ Name Type Description x int256 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number.","title":"exp2"},{"location":"prb-math/PRBMathSD59x18/#floor","text":"function floor(int256 x) internal pure returns (int256 result) Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be greater than or equal to MIN_WHOLE_SD59x18._ Name Type Description x int256 The signed 59.18-decimal fixed-point number to floor.","title":"floor"},{"location":"prb-math/PRBMathSD59x18/#frac","text":"function frac(int256 x) internal pure returns (int256 result) Yields the excess beyond the floor of x for positive numbers and the part of the number to the right of the radix point for negative numbers. Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part Name Type Description x int256 The signed 59.18-decimal fixed-point number to get the fractional part of.","title":"frac"},{"location":"prb-math/PRBMathSD59x18/#fromint","text":"function fromInt(int256 x) internal pure returns (int256 result) Converts a number from basic integer form to signed 59.18-decimal fixed-point representation. Requirements: - x must be greater than or equal to MIN_SD59x18 divided by SCALE. - x must be less than or equal to MAX_SD59x18 divided by SCALE. Name Type Description x int256 The basic integer to convert.","title":"fromInt"},{"location":"prb-math/PRBMathSD59x18/#gm","text":"function gm(int256 x, int256 y) internal pure returns (int256 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_SD59x18, lest it overflows. - x * y cannot be negative. Name Type Description x int256 The first operand as a signed 59.18-decimal fixed-point number. y int256 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number.","title":"gm"},{"location":"prb-math/PRBMathSD59x18/#inv","text":"function inv(int256 x) internal pure returns (int256 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result int256 The inverse as a signed 59.18-decimal fixed-point number.","title":"inv"},{"location":"prb-math/PRBMathSD59x18/#ln","text":"function ln(int256 x) internal pure returns (int256 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result int256 The natural logarithm as a signed 59.18-decimal fixed-point number.","title":"ln"},{"location":"prb-math/PRBMathSD59x18/#log10","text":"function log10(int256 x) internal pure returns (int256 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result int256 The common logarithm as a signed 59.18-decimal fixed-point number.","title":"log10"},{"location":"prb-math/PRBMathSD59x18/#log2","text":"function log2(int256 x) internal pure returns (int256 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than zero. Caveats: - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result int256 The binary logarithm as a signed 59.18-decimal fixed-point number.","title":"log2"},{"location":"prb-math/PRBMathSD59x18/#mul","text":"function mul(int256 x, int256 y) internal pure returns (int256 result) Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers and employs constant folding, i.e. the denominator is always 1e18. Requirements: - All from \"PRBMath.mulDivFixedPoint\". - None of the inputs can be MIN_SD59x18 - The result must fit within MAX_SD59x18. Caveats: - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works._ Name Type Description x int256 The multiplicand as a signed 59.18-decimal fixed-point number. y int256 The multiplier as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The product as a signed 59.18-decimal fixed-point number.","title":"mul"},{"location":"prb-math/PRBMathSD59x18/#pi","text":"function pi() internal pure returns (int256 result) Returns PI as a signed 59.18-decimal fixed-point number.","title":"pi"},{"location":"prb-math/PRBMathSD59x18/#pow","text":"function pow(int256 x, int256 y) internal pure returns (int256 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". - z cannot be zero. Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x int256 Number to raise to given power y, as a signed 59.18-decimal fixed-point number. y int256 Exponent to raise x to, as a signed 59.18-decimal fixed-point number. Name Type Description result int256 x raised to power y, as a signed 59.18-decimal fixed-point number.","title":"pow"},{"location":"prb-math/PRBMathSD59x18/#powu","text":"function powu(int256 x, uint256 y) internal pure returns (int256 result) Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - All from \"abs\" and \"PRBMath.mulDivFixedPoint\". - The result must fit within MAX_SD59x18. Caveats: - All from \"PRBMath.mulDivFixedPoint\". - Assumes 0^0 is 1._ Name Type Description x int256 The base as a signed 59.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number.","title":"powu"},{"location":"prb-math/PRBMathSD59x18/#scale_1","text":"function scale() internal pure returns (int256 result) Returns 1 as a signed 59.18-decimal fixed-point number.","title":"scale"},{"location":"prb-math/PRBMathSD59x18/#sqrt","text":"function sqrt(int256 x) internal pure returns (int256 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x cannot be negative. - x must be less than MAX_SD59x18 / SCALE._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the square root. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point .","title":"sqrt"},{"location":"prb-math/PRBMathSD59x18/#toint","text":"function toInt(int256 x) internal pure returns (int256 result) Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x int256 The signed 59.18-decimal fixed-point number to convert. Name Type Description result int256 The same number in basic integer form.","title":"toInt"},{"location":"prb-math/PRBMathSD59x18Typed/","text":"PRBMathSD59x18Typed Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18 trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type int256. This is the same as PRBMathSD59x18, except that it works with structs instead of raw uint256s. LOG2_E int256 LOG2_E log2(e) as a signed 59.18-decimal fixed-point number. HALF_SCALE int256 HALF_SCALE Half the SCALE number. MAX_SD59x18 int256 MAX_SD59x18 The maximum value a signed 59.18-decimal fixed-point number can have. MAX_WHOLE_SD59x18 int256 MAX_WHOLE_SD59x18 The maximum whole value a signed 59.18-decimal fixed-point number can have. MIN_SD59x18 int256 MIN_SD59x18 The minimum value a signed 59.18-decimal fixed-point number can have. MIN_WHOLE_SD59x18 int256 MIN_WHOLE_SD59x18 The minimum whole value a signed 59.18-decimal fixed-point number can have. SCALE int256 SCALE How many trailing decimals can be represented. abs function abs(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculate the absolute value of x. Requirements: - x must be greater than MIN_SD59x18. Name Type Description x struct PRBMath.SD59x18 The number to calculate the absolute value for. add function add(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Adds two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal fixed-point number. Name Type Description x struct PRBMath.SD59x18 The first summand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The second summand as a signed 59.18-decimal fixed-point number. avg function avg(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x struct PRBMath.SD59x18 The first operand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The arithmetic average as a signed 59.18-decimal fixed-point number. ceil function ceil(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_SD59x18._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to ceil. div function div(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers. Works by computing the signs and the absolute values separately. Requirements: - All from \"PRBMath.mulDiv\". - None of the inputs can be type(int256).min. - The denominator cannot be zero. - The result must fit within int256. Caveats: - All from \"PRBMath.mulDiv\"._ Name Type Description x struct PRBMath.SD59x18 The numerator as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The denominator as a signed 59.18-decimal fixed-point number. e function e() internal pure returns (struct PRBMath.SD59x18 result) Returns Euler's number as a signed 59.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._ exp function exp(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 133.084258667509499441. Caveats: - All from \"exp2\". - For any x less than -41.446531673892822322, the result is zero._ Name Type Description x struct PRBMath.SD59x18 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number. exp2 function exp2(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_SD59x18. Caveats: - For any x less than -59.794705707972522261, the result is zero._ Name Type Description x struct PRBMath.SD59x18 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number. floor function floor(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be greater than or equal to MIN_WHOLE_SD59x18._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to floor. frac function frac(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Yields the excess beyond the floor of x for positive numbers and the part of the number to the right of the radix point for negative numbers. Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to get the fractional part of. fromInt function fromInt(int256 x) internal pure returns (struct PRBMath.SD59x18 result) Converts a number from basic integer form to signed 59.18-decimal fixed-point representation. Requirements: - x must be greater than or equal to MIN_SD59x18 divided by SCALE. - x must be less than or equal to MAX_SD59x18 divided by SCALE. Name Type Description x int256 The basic integer to convert. gm function gm(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_SD59x18, lest it overflows. - x * y cannot be negative. Name Type Description x struct PRBMath.SD59x18 The first operand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number. inv function inv(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result struct PRBMath.SD59x18 The inverse as a signed 59.18-decimal fixed-point number. ln function ln(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result struct PRBMath.SD59x18 The natural logarithm as a signed 59.18-decimal fixed-point number. log10 function log10(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result struct PRBMath.SD59x18 The common logarithm as a signed 59.18-decimal fixed-point number. log2 function log2(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than zero. Caveats: - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result struct PRBMath.SD59x18 The binary logarithm as a signed 59.18-decimal fixed-point number. mul function mul(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers and employs constant folding, i.e. the denominator is always 1e18. Requirements: - All from \"PRBMath.mulDivFixedPoint\". - None of the inputs can be MIN_SD59x18 - The result must fit within MAX_SD59x18. Caveats: - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works._ Name Type Description x struct PRBMath.SD59x18 The multiplicand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The multiplier as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The product as a signed 59.18-decimal fixed-point number. pi function pi() internal pure returns (struct PRBMath.SD59x18 result) Returns PI as a signed 59.18-decimal fixed-point number. pow function pow(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". - z cannot be zero. Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.SD59x18 Number to raise to given power y, as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 Exponent to raise x to, as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 x raised to power y, as a signed 59.18-decimal fixed-point number. powu function powu(struct PRBMath.SD59x18 x, uint256 y) internal pure returns (struct PRBMath.SD59x18 result) Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - All from \"abs\" and \"PRBMath.mulDivFixedPoint\". - The result must fit within MAX_SD59x18. Caveats: - All from \"PRBMath.mulDivFixedPoint\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.SD59x18 The base as a signed 59.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number. scale function scale() internal pure returns (struct PRBMath.SD59x18 result) Returns 1 as a signed 59.18-decimal fixed-point number. sqrt function sqrt(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x cannot be negative. - x must be less than MAX_SD59x18 / SCALE._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the square root. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point . sub function sub(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Subtracts one signed 59.18-decimal fixed-point number from another one, returning a new signed 59.18-decimal fixed-point number. Name Type Description x struct PRBMath.SD59x18 The minuend as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The subtrahend as a signed 59.18-decimal fixed-point number. toInt function toInt(struct PRBMath.SD59x18 x) internal pure returns (int256 result) Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to convert. Name Type Description result int256 The same number in basic integer form.","title":"PRBMathSD59x18Typed"},{"location":"prb-math/PRBMathSD59x18Typed/#prbmathsd59x18typed","text":"Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18 trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type int256. This is the same as PRBMathSD59x18, except that it works with structs instead of raw uint256s.","title":"PRBMathSD59x18Typed"},{"location":"prb-math/PRBMathSD59x18Typed/#log2_e","text":"int256 LOG2_E log2(e) as a signed 59.18-decimal fixed-point number.","title":"LOG2_E"},{"location":"prb-math/PRBMathSD59x18Typed/#half_scale","text":"int256 HALF_SCALE Half the SCALE number.","title":"HALF_SCALE"},{"location":"prb-math/PRBMathSD59x18Typed/#max_sd59x18","text":"int256 MAX_SD59x18 The maximum value a signed 59.18-decimal fixed-point number can have.","title":"MAX_SD59x18"},{"location":"prb-math/PRBMathSD59x18Typed/#max_whole_sd59x18","text":"int256 MAX_WHOLE_SD59x18 The maximum whole value a signed 59.18-decimal fixed-point number can have.","title":"MAX_WHOLE_SD59x18"},{"location":"prb-math/PRBMathSD59x18Typed/#min_sd59x18","text":"int256 MIN_SD59x18 The minimum value a signed 59.18-decimal fixed-point number can have.","title":"MIN_SD59x18"},{"location":"prb-math/PRBMathSD59x18Typed/#min_whole_sd59x18","text":"int256 MIN_WHOLE_SD59x18 The minimum whole value a signed 59.18-decimal fixed-point number can have.","title":"MIN_WHOLE_SD59x18"},{"location":"prb-math/PRBMathSD59x18Typed/#scale","text":"int256 SCALE How many trailing decimals can be represented.","title":"SCALE"},{"location":"prb-math/PRBMathSD59x18Typed/#abs","text":"function abs(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculate the absolute value of x. Requirements: - x must be greater than MIN_SD59x18. Name Type Description x struct PRBMath.SD59x18 The number to calculate the absolute value for.","title":"abs"},{"location":"prb-math/PRBMathSD59x18Typed/#add","text":"function add(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Adds two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal fixed-point number. Name Type Description x struct PRBMath.SD59x18 The first summand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The second summand as a signed 59.18-decimal fixed-point number.","title":"add"},{"location":"prb-math/PRBMathSD59x18Typed/#avg","text":"function avg(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x struct PRBMath.SD59x18 The first operand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The arithmetic average as a signed 59.18-decimal fixed-point number.","title":"avg"},{"location":"prb-math/PRBMathSD59x18Typed/#ceil","text":"function ceil(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_SD59x18._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to ceil.","title":"ceil"},{"location":"prb-math/PRBMathSD59x18Typed/#div","text":"function div(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers. Works by computing the signs and the absolute values separately. Requirements: - All from \"PRBMath.mulDiv\". - None of the inputs can be type(int256).min. - The denominator cannot be zero. - The result must fit within int256. Caveats: - All from \"PRBMath.mulDiv\"._ Name Type Description x struct PRBMath.SD59x18 The numerator as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The denominator as a signed 59.18-decimal fixed-point number.","title":"div"},{"location":"prb-math/PRBMathSD59x18Typed/#e","text":"function e() internal pure returns (struct PRBMath.SD59x18 result) Returns Euler's number as a signed 59.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._","title":"e"},{"location":"prb-math/PRBMathSD59x18Typed/#exp","text":"function exp(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 133.084258667509499441. Caveats: - All from \"exp2\". - For any x less than -41.446531673892822322, the result is zero._ Name Type Description x struct PRBMath.SD59x18 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number.","title":"exp"},{"location":"prb-math/PRBMathSD59x18Typed/#exp2","text":"function exp2(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_SD59x18. Caveats: - For any x less than -59.794705707972522261, the result is zero._ Name Type Description x struct PRBMath.SD59x18 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number.","title":"exp2"},{"location":"prb-math/PRBMathSD59x18Typed/#floor","text":"function floor(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be greater than or equal to MIN_WHOLE_SD59x18._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to floor.","title":"floor"},{"location":"prb-math/PRBMathSD59x18Typed/#frac","text":"function frac(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Yields the excess beyond the floor of x for positive numbers and the part of the number to the right of the radix point for negative numbers. Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to get the fractional part of.","title":"frac"},{"location":"prb-math/PRBMathSD59x18Typed/#fromint","text":"function fromInt(int256 x) internal pure returns (struct PRBMath.SD59x18 result) Converts a number from basic integer form to signed 59.18-decimal fixed-point representation. Requirements: - x must be greater than or equal to MIN_SD59x18 divided by SCALE. - x must be less than or equal to MAX_SD59x18 divided by SCALE. Name Type Description x int256 The basic integer to convert.","title":"fromInt"},{"location":"prb-math/PRBMathSD59x18Typed/#gm","text":"function gm(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_SD59x18, lest it overflows. - x * y cannot be negative. Name Type Description x struct PRBMath.SD59x18 The first operand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number.","title":"gm"},{"location":"prb-math/PRBMathSD59x18Typed/#inv","text":"function inv(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result struct PRBMath.SD59x18 The inverse as a signed 59.18-decimal fixed-point number.","title":"inv"},{"location":"prb-math/PRBMathSD59x18Typed/#ln","text":"function ln(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result struct PRBMath.SD59x18 The natural logarithm as a signed 59.18-decimal fixed-point number.","title":"ln"},{"location":"prb-math/PRBMathSD59x18Typed/#log10","text":"function log10(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result struct PRBMath.SD59x18 The common logarithm as a signed 59.18-decimal fixed-point number.","title":"log10"},{"location":"prb-math/PRBMathSD59x18Typed/#log2","text":"function log2(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than zero. Caveats: - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result struct PRBMath.SD59x18 The binary logarithm as a signed 59.18-decimal fixed-point number.","title":"log2"},{"location":"prb-math/PRBMathSD59x18Typed/#mul","text":"function mul(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers and employs constant folding, i.e. the denominator is always 1e18. Requirements: - All from \"PRBMath.mulDivFixedPoint\". - None of the inputs can be MIN_SD59x18 - The result must fit within MAX_SD59x18. Caveats: - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works._ Name Type Description x struct PRBMath.SD59x18 The multiplicand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The multiplier as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The product as a signed 59.18-decimal fixed-point number.","title":"mul"},{"location":"prb-math/PRBMathSD59x18Typed/#pi","text":"function pi() internal pure returns (struct PRBMath.SD59x18 result) Returns PI as a signed 59.18-decimal fixed-point number.","title":"pi"},{"location":"prb-math/PRBMathSD59x18Typed/#pow","text":"function pow(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". - z cannot be zero. Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.SD59x18 Number to raise to given power y, as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 Exponent to raise x to, as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 x raised to power y, as a signed 59.18-decimal fixed-point number.","title":"pow"},{"location":"prb-math/PRBMathSD59x18Typed/#powu","text":"function powu(struct PRBMath.SD59x18 x, uint256 y) internal pure returns (struct PRBMath.SD59x18 result) Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - All from \"abs\" and \"PRBMath.mulDivFixedPoint\". - The result must fit within MAX_SD59x18. Caveats: - All from \"PRBMath.mulDivFixedPoint\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.SD59x18 The base as a signed 59.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number.","title":"powu"},{"location":"prb-math/PRBMathSD59x18Typed/#scale_1","text":"function scale() internal pure returns (struct PRBMath.SD59x18 result) Returns 1 as a signed 59.18-decimal fixed-point number.","title":"scale"},{"location":"prb-math/PRBMathSD59x18Typed/#sqrt","text":"function sqrt(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x cannot be negative. - x must be less than MAX_SD59x18 / SCALE._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the square root. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point .","title":"sqrt"},{"location":"prb-math/PRBMathSD59x18Typed/#sub","text":"function sub(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Subtracts one signed 59.18-decimal fixed-point number from another one, returning a new signed 59.18-decimal fixed-point number. Name Type Description x struct PRBMath.SD59x18 The minuend as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The subtrahend as a signed 59.18-decimal fixed-point number.","title":"sub"},{"location":"prb-math/PRBMathSD59x18Typed/#toint","text":"function toInt(struct PRBMath.SD59x18 x) internal pure returns (int256 result) Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to convert. Name Type Description result int256 The same number in basic integer form.","title":"toInt"},{"location":"prb-math/PRBMathUD60x18/","text":"PRBMathUD60x18 Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18 trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type uint256. HALF_SCALE uint256 HALF_SCALE Half the SCALE number. LOG2_E uint256 LOG2_E log2(e) as an unsigned 60.18-decimal fixed-point number. MAX_UD60x18 uint256 MAX_UD60x18 The maximum value an unsigned 60.18-decimal fixed-point number can have. MAX_WHOLE_UD60x18 uint256 MAX_WHOLE_UD60x18 The maximum whole value an unsigned 60.18-decimal fixed-point number can have. SCALE uint256 SCALE How many trailing decimals can be represented. avg function avg(uint256 x, uint256 y) internal pure returns (uint256 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x uint256 The first operand as an unsigned 60.18-decimal fixed-point number. y uint256 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The arithmetic average as an unsigned 60.18-decimal fixed-point number. ceil function ceil(uint256 x) internal pure returns (uint256 result) Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_UD60x18._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to ceil. div function div(uint256 x, uint256 y) internal pure returns (uint256 result) Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number. _Uses mulDiv to enable overflow-safe multiplication and division. Requirements: - The denominator cannot be zero._ Name Type Description x uint256 The numerator as an unsigned 60.18-decimal fixed-point number. y uint256 The denominator as an unsigned 60.18-decimal fixed-point number. e function e() internal pure returns (uint256 result) Returns Euler's number as an unsigned 60.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._ exp function exp(uint256 x) internal pure returns (uint256 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 133.084258667509499441._ Name Type Description x uint256 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number. exp2 function exp2(uint256 x) internal pure returns (uint256 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_UD60x18._ Name Type Description x uint256 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number. floor function floor(uint256 x) internal pure returns (uint256 result) Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x. Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to floor. frac function frac(uint256 x) internal pure returns (uint256 result) Yields the excess beyond the floor of x. Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to get the fractional part of. fromUint function fromUint(uint256 x) internal pure returns (uint256 result) Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation. Requirements: - x must be less than or equal to MAX_UD60x18 divided by SCALE. Name Type Description x uint256 The basic integer to convert. gm function gm(uint256 x, uint256 y) internal pure returns (uint256 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_UD60x18, lest it overflows. Name Type Description x uint256 The first operand as an unsigned 60.18-decimal fixed-point number. y uint256 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number. inv function inv(uint256 x) internal pure returns (uint256 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result uint256 The inverse as an unsigned 60.18-decimal fixed-point number. ln function ln(uint256 x) internal pure returns (uint256 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result uint256 The natural logarithm as an unsigned 60.18-decimal fixed-point number. log10 function log10(uint256 x) internal pure returns (uint256 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result uint256 The common logarithm as an unsigned 60.18-decimal fixed-point number. log2 function log2(uint256 x) internal pure returns (uint256 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than or equal to SCALE, otherwise the result would be negative. Caveats: - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result uint256 The binary logarithm as an unsigned 60.18-decimal fixed-point number. mul function mul(uint256 x, uint256 y) internal pure returns (uint256 result) Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal fixed-point number. See the documentation for the \"PRBMath.mulDivFixedPoint\" function. Name Type Description x uint256 The multiplicand as an unsigned 60.18-decimal fixed-point number. y uint256 The multiplier as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The product as an unsigned 60.18-decimal fixed-point number. pi function pi() internal pure returns (uint256 result) Returns PI as an unsigned 60.18-decimal fixed-point number. pow function pow(uint256 x, uint256 y) internal pure returns (uint256 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x uint256 Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number. y uint256 Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 x raised to power y, as an unsigned 60.18-decimal fixed-point number. powu function powu(uint256 x, uint256 y) internal pure returns (uint256 result) Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - The result must fit within MAX_UD60x18. Caveats: - All from \"mul\". - Assumes 0^0 is 1._ Name Type Description x uint256 The base as an unsigned 60.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number. scale function scale() internal pure returns (uint256 result) Returns 1 as an unsigned 60.18-decimal fixed-point number. sqrt function sqrt(uint256 x) internal pure returns (uint256 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x must be less than MAX_UD60x18 / SCALE._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the square root. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point . toUint function toUint(uint256 x) internal pure returns (uint256 result) Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to convert. Name Type Description result uint256 The same number in basic integer form.","title":"PRBMathUD60x18"},{"location":"prb-math/PRBMathUD60x18/#prbmathud60x18","text":"Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18 trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type uint256.","title":"PRBMathUD60x18"},{"location":"prb-math/PRBMathUD60x18/#half_scale","text":"uint256 HALF_SCALE Half the SCALE number.","title":"HALF_SCALE"},{"location":"prb-math/PRBMathUD60x18/#log2_e","text":"uint256 LOG2_E log2(e) as an unsigned 60.18-decimal fixed-point number.","title":"LOG2_E"},{"location":"prb-math/PRBMathUD60x18/#max_ud60x18","text":"uint256 MAX_UD60x18 The maximum value an unsigned 60.18-decimal fixed-point number can have.","title":"MAX_UD60x18"},{"location":"prb-math/PRBMathUD60x18/#max_whole_ud60x18","text":"uint256 MAX_WHOLE_UD60x18 The maximum whole value an unsigned 60.18-decimal fixed-point number can have.","title":"MAX_WHOLE_UD60x18"},{"location":"prb-math/PRBMathUD60x18/#scale","text":"uint256 SCALE How many trailing decimals can be represented.","title":"SCALE"},{"location":"prb-math/PRBMathUD60x18/#avg","text":"function avg(uint256 x, uint256 y) internal pure returns (uint256 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x uint256 The first operand as an unsigned 60.18-decimal fixed-point number. y uint256 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The arithmetic average as an unsigned 60.18-decimal fixed-point number.","title":"avg"},{"location":"prb-math/PRBMathUD60x18/#ceil","text":"function ceil(uint256 x) internal pure returns (uint256 result) Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_UD60x18._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to ceil.","title":"ceil"},{"location":"prb-math/PRBMathUD60x18/#div","text":"function div(uint256 x, uint256 y) internal pure returns (uint256 result) Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number. _Uses mulDiv to enable overflow-safe multiplication and division. Requirements: - The denominator cannot be zero._ Name Type Description x uint256 The numerator as an unsigned 60.18-decimal fixed-point number. y uint256 The denominator as an unsigned 60.18-decimal fixed-point number.","title":"div"},{"location":"prb-math/PRBMathUD60x18/#e","text":"function e() internal pure returns (uint256 result) Returns Euler's number as an unsigned 60.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._","title":"e"},{"location":"prb-math/PRBMathUD60x18/#exp","text":"function exp(uint256 x) internal pure returns (uint256 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 133.084258667509499441._ Name Type Description x uint256 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number.","title":"exp"},{"location":"prb-math/PRBMathUD60x18/#exp2","text":"function exp2(uint256 x) internal pure returns (uint256 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_UD60x18._ Name Type Description x uint256 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number.","title":"exp2"},{"location":"prb-math/PRBMathUD60x18/#floor","text":"function floor(uint256 x) internal pure returns (uint256 result) Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x. Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to floor.","title":"floor"},{"location":"prb-math/PRBMathUD60x18/#frac","text":"function frac(uint256 x) internal pure returns (uint256 result) Yields the excess beyond the floor of x. Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to get the fractional part of.","title":"frac"},{"location":"prb-math/PRBMathUD60x18/#fromuint","text":"function fromUint(uint256 x) internal pure returns (uint256 result) Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation. Requirements: - x must be less than or equal to MAX_UD60x18 divided by SCALE. Name Type Description x uint256 The basic integer to convert.","title":"fromUint"},{"location":"prb-math/PRBMathUD60x18/#gm","text":"function gm(uint256 x, uint256 y) internal pure returns (uint256 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_UD60x18, lest it overflows. Name Type Description x uint256 The first operand as an unsigned 60.18-decimal fixed-point number. y uint256 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number.","title":"gm"},{"location":"prb-math/PRBMathUD60x18/#inv","text":"function inv(uint256 x) internal pure returns (uint256 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result uint256 The inverse as an unsigned 60.18-decimal fixed-point number.","title":"inv"},{"location":"prb-math/PRBMathUD60x18/#ln","text":"function ln(uint256 x) internal pure returns (uint256 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result uint256 The natural logarithm as an unsigned 60.18-decimal fixed-point number.","title":"ln"},{"location":"prb-math/PRBMathUD60x18/#log10","text":"function log10(uint256 x) internal pure returns (uint256 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result uint256 The common logarithm as an unsigned 60.18-decimal fixed-point number.","title":"log10"},{"location":"prb-math/PRBMathUD60x18/#log2","text":"function log2(uint256 x) internal pure returns (uint256 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than or equal to SCALE, otherwise the result would be negative. Caveats: - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result uint256 The binary logarithm as an unsigned 60.18-decimal fixed-point number.","title":"log2"},{"location":"prb-math/PRBMathUD60x18/#mul","text":"function mul(uint256 x, uint256 y) internal pure returns (uint256 result) Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal fixed-point number. See the documentation for the \"PRBMath.mulDivFixedPoint\" function. Name Type Description x uint256 The multiplicand as an unsigned 60.18-decimal fixed-point number. y uint256 The multiplier as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The product as an unsigned 60.18-decimal fixed-point number.","title":"mul"},{"location":"prb-math/PRBMathUD60x18/#pi","text":"function pi() internal pure returns (uint256 result) Returns PI as an unsigned 60.18-decimal fixed-point number.","title":"pi"},{"location":"prb-math/PRBMathUD60x18/#pow","text":"function pow(uint256 x, uint256 y) internal pure returns (uint256 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x uint256 Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number. y uint256 Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 x raised to power y, as an unsigned 60.18-decimal fixed-point number.","title":"pow"},{"location":"prb-math/PRBMathUD60x18/#powu","text":"function powu(uint256 x, uint256 y) internal pure returns (uint256 result) Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - The result must fit within MAX_UD60x18. Caveats: - All from \"mul\". - Assumes 0^0 is 1._ Name Type Description x uint256 The base as an unsigned 60.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number.","title":"powu"},{"location":"prb-math/PRBMathUD60x18/#scale_1","text":"function scale() internal pure returns (uint256 result) Returns 1 as an unsigned 60.18-decimal fixed-point number.","title":"scale"},{"location":"prb-math/PRBMathUD60x18/#sqrt","text":"function sqrt(uint256 x) internal pure returns (uint256 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x must be less than MAX_UD60x18 / SCALE._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the square root. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point .","title":"sqrt"},{"location":"prb-math/PRBMathUD60x18/#touint","text":"function toUint(uint256 x) internal pure returns (uint256 result) Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to convert. Name Type Description result uint256 The same number in basic integer form.","title":"toUint"},{"location":"prb-math/PRBMathUD60x18Typed/","text":"PRBMathUD60x18Typed Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18 trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type uint256. This is the same as PRBMathUD59x18, except that it works with structs instead of raw uint256s. HALF_SCALE uint256 HALF_SCALE Half the SCALE number. LOG2_E uint256 LOG2_E log2(e) as an unsigned 60.18-decimal fixed-point number. MAX_UD60x18 uint256 MAX_UD60x18 The maximum value an unsigned 60.18-decimal fixed-point number can have. MAX_WHOLE_UD60x18 uint256 MAX_WHOLE_UD60x18 The maximum whole value an unsigned 60.18-decimal fixed-point number can have. SCALE uint256 SCALE How many trailing decimals can be represented. add function add(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Adds two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal fixed-point number. Name Type Description x struct PRBMath.UD60x18 The first summand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The second summand as an unsigned 60.18-decimal fixed-point number. avg function avg(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x struct PRBMath.UD60x18 The first operand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The arithmetic average as an unsigned 60.18-decimal fixed-point number. ceil function ceil(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_UD60x18._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to ceil. div function div(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number. _Uses mulDiv to enable overflow-safe multiplication and division. Requirements: - The denominator cannot be zero._ Name Type Description x struct PRBMath.UD60x18 The numerator as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The denominator as an unsigned 60.18-decimal fixed-point number. e function e() internal pure returns (struct PRBMath.UD60x18 result) Returns Euler's number as an unsigned 60.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._ exp function exp(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 88.722839111672999628._ Name Type Description x struct PRBMath.UD60x18 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number. exp2 function exp2(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_UD60x18._ Name Type Description x struct PRBMath.UD60x18 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number. floor function floor(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x. Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to floor. frac function frac(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Yields the excess beyond the floor of x. Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to get the fractional part of. fromUint function fromUint(uint256 x) internal pure returns (struct PRBMath.UD60x18 result) Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation. Requirements: - x must be less than or equal to MAX_UD60x18 divided by SCALE. Name Type Description x uint256 The basic integer to convert. gm function gm(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_UD60x18, lest it overflows. Name Type Description x struct PRBMath.UD60x18 The first operand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number. inv function inv(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result struct PRBMath.UD60x18 The inverse as an unsigned 60.18-decimal fixed-point number. ln function ln(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result struct PRBMath.UD60x18 The natural logarithm as an unsigned 60.18-decimal fixed-point number. log10 function log10(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result struct PRBMath.UD60x18 The common logarithm as an unsigned 60.18-decimal fixed-point number. log2 function log2(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than or equal to SCALE, otherwise the result would be negative. Caveats: - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result struct PRBMath.UD60x18 The binary logarithm as an unsigned 60.18-decimal fixed-point number. mul function mul(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal fixed-point number. See the documentation for the \"PRBMath.mulDivFixedPoint\" function. Name Type Description x struct PRBMath.UD60x18 The multiplicand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The multiplier as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The product as an unsigned 60.18-decimal fixed-point number. pi function pi() internal pure returns (struct PRBMath.UD60x18 result) Returns PI as an unsigned 60.18-decimal fixed-point number. pow function pow(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.UD60x18 Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 x raised to power y, as an unsigned 60.18-decimal fixed-point number. powu function powu(struct PRBMath.UD60x18 x, uint256 y) internal pure returns (struct PRBMath.UD60x18 result) Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - The result must fit within MAX_UD60x18. Caveats: - All from \"mul\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.UD60x18 The base as an unsigned 60.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number. scale function scale() internal pure returns (struct PRBMath.UD60x18 result) Returns 1 as an unsigned 60.18-decimal fixed-point number. sqrt function sqrt(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x must be less than MAX_UD60x18 / SCALE._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the square root. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point . sub function sub(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Subtracts one unsigned 60.18-decimal fixed-point number from another one, returning a new unsigned 60.18-decimal fixed-point number. Name Type Description x struct PRBMath.UD60x18 The minuend as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The subtrahend as an unsigned 60.18-decimal fixed-point number. toUint function toUint(struct PRBMath.UD60x18 x) internal pure returns (uint256 result) Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to convert. Name Type Description result uint256 The same number in basic integer form.","title":"PRBMathUD60x18Typed"},{"location":"prb-math/PRBMathUD60x18Typed/#prbmathud60x18typed","text":"Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18 trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type uint256. This is the same as PRBMathUD59x18, except that it works with structs instead of raw uint256s.","title":"PRBMathUD60x18Typed"},{"location":"prb-math/PRBMathUD60x18Typed/#half_scale","text":"uint256 HALF_SCALE Half the SCALE number.","title":"HALF_SCALE"},{"location":"prb-math/PRBMathUD60x18Typed/#log2_e","text":"uint256 LOG2_E log2(e) as an unsigned 60.18-decimal fixed-point number.","title":"LOG2_E"},{"location":"prb-math/PRBMathUD60x18Typed/#max_ud60x18","text":"uint256 MAX_UD60x18 The maximum value an unsigned 60.18-decimal fixed-point number can have.","title":"MAX_UD60x18"},{"location":"prb-math/PRBMathUD60x18Typed/#max_whole_ud60x18","text":"uint256 MAX_WHOLE_UD60x18 The maximum whole value an unsigned 60.18-decimal fixed-point number can have.","title":"MAX_WHOLE_UD60x18"},{"location":"prb-math/PRBMathUD60x18Typed/#scale","text":"uint256 SCALE How many trailing decimals can be represented.","title":"SCALE"},{"location":"prb-math/PRBMathUD60x18Typed/#add","text":"function add(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Adds two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal fixed-point number. Name Type Description x struct PRBMath.UD60x18 The first summand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The second summand as an unsigned 60.18-decimal fixed-point number.","title":"add"},{"location":"prb-math/PRBMathUD60x18Typed/#avg","text":"function avg(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x struct PRBMath.UD60x18 The first operand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The arithmetic average as an unsigned 60.18-decimal fixed-point number.","title":"avg"},{"location":"prb-math/PRBMathUD60x18Typed/#ceil","text":"function ceil(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_UD60x18._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to ceil.","title":"ceil"},{"location":"prb-math/PRBMathUD60x18Typed/#div","text":"function div(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number. _Uses mulDiv to enable overflow-safe multiplication and division. Requirements: - The denominator cannot be zero._ Name Type Description x struct PRBMath.UD60x18 The numerator as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The denominator as an unsigned 60.18-decimal fixed-point number.","title":"div"},{"location":"prb-math/PRBMathUD60x18Typed/#e","text":"function e() internal pure returns (struct PRBMath.UD60x18 result) Returns Euler's number as an unsigned 60.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._","title":"e"},{"location":"prb-math/PRBMathUD60x18Typed/#exp","text":"function exp(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 88.722839111672999628._ Name Type Description x struct PRBMath.UD60x18 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number.","title":"exp"},{"location":"prb-math/PRBMathUD60x18Typed/#exp2","text":"function exp2(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_UD60x18._ Name Type Description x struct PRBMath.UD60x18 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number.","title":"exp2"},{"location":"prb-math/PRBMathUD60x18Typed/#floor","text":"function floor(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x. Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to floor.","title":"floor"},{"location":"prb-math/PRBMathUD60x18Typed/#frac","text":"function frac(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Yields the excess beyond the floor of x. Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to get the fractional part of.","title":"frac"},{"location":"prb-math/PRBMathUD60x18Typed/#fromuint","text":"function fromUint(uint256 x) internal pure returns (struct PRBMath.UD60x18 result) Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation. Requirements: - x must be less than or equal to MAX_UD60x18 divided by SCALE. Name Type Description x uint256 The basic integer to convert.","title":"fromUint"},{"location":"prb-math/PRBMathUD60x18Typed/#gm","text":"function gm(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_UD60x18, lest it overflows. Name Type Description x struct PRBMath.UD60x18 The first operand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number.","title":"gm"},{"location":"prb-math/PRBMathUD60x18Typed/#inv","text":"function inv(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result struct PRBMath.UD60x18 The inverse as an unsigned 60.18-decimal fixed-point number.","title":"inv"},{"location":"prb-math/PRBMathUD60x18Typed/#ln","text":"function ln(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result struct PRBMath.UD60x18 The natural logarithm as an unsigned 60.18-decimal fixed-point number.","title":"ln"},{"location":"prb-math/PRBMathUD60x18Typed/#log10","text":"function log10(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result struct PRBMath.UD60x18 The common logarithm as an unsigned 60.18-decimal fixed-point number.","title":"log10"},{"location":"prb-math/PRBMathUD60x18Typed/#log2","text":"function log2(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than or equal to SCALE, otherwise the result would be negative. Caveats: - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result struct PRBMath.UD60x18 The binary logarithm as an unsigned 60.18-decimal fixed-point number.","title":"log2"},{"location":"prb-math/PRBMathUD60x18Typed/#mul","text":"function mul(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal fixed-point number. See the documentation for the \"PRBMath.mulDivFixedPoint\" function. Name Type Description x struct PRBMath.UD60x18 The multiplicand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The multiplier as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The product as an unsigned 60.18-decimal fixed-point number.","title":"mul"},{"location":"prb-math/PRBMathUD60x18Typed/#pi","text":"function pi() internal pure returns (struct PRBMath.UD60x18 result) Returns PI as an unsigned 60.18-decimal fixed-point number.","title":"pi"},{"location":"prb-math/PRBMathUD60x18Typed/#pow","text":"function pow(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.UD60x18 Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 x raised to power y, as an unsigned 60.18-decimal fixed-point number.","title":"pow"},{"location":"prb-math/PRBMathUD60x18Typed/#powu","text":"function powu(struct PRBMath.UD60x18 x, uint256 y) internal pure returns (struct PRBMath.UD60x18 result) Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - The result must fit within MAX_UD60x18. Caveats: - All from \"mul\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.UD60x18 The base as an unsigned 60.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number.","title":"powu"},{"location":"prb-math/PRBMathUD60x18Typed/#scale_1","text":"function scale() internal pure returns (struct PRBMath.UD60x18 result) Returns 1 as an unsigned 60.18-decimal fixed-point number.","title":"scale"},{"location":"prb-math/PRBMathUD60x18Typed/#sqrt","text":"function sqrt(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x must be less than MAX_UD60x18 / SCALE._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the square root. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point .","title":"sqrt"},{"location":"prb-math/PRBMathUD60x18Typed/#sub","text":"function sub(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Subtracts one unsigned 60.18-decimal fixed-point number from another one, returning a new unsigned 60.18-decimal fixed-point number. Name Type Description x struct PRBMath.UD60x18 The minuend as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The subtrahend as an unsigned 60.18-decimal fixed-point number.","title":"sub"},{"location":"prb-math/PRBMathUD60x18Typed/#touint","text":"function toUint(struct PRBMath.UD60x18 x) internal pure returns (uint256 result) Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to convert. Name Type Description result uint256 The same number in basic integer form.","title":"toUint"},{"location":"solidity-trigonometry/Trigonometry/","text":"Trigonometry Solidity library offering basic trigonometry functions where inputs and outputs are integers. Inputs are specified in radians scaled by 1e18, and similarly outputs are scaled by 1e18. This implementation is based off the Solidity trigonometry library written by Lefteris Karapetsas which can be found here: https://github.com/Sikorkaio/sikorka/blob/e75c91925c914beaedf4841c0336a806f2b5f66d/contracts/trigonometry.sol Compared to Lefteris' implementation, this version makes the following changes: - Uses a 32 bits instead of 16 bits for improved accuracy - Updated for Solidity 0.8.x - Various gas optimizations - Change inputs/outputs to standard trig format (scaled by 1e18) instead of requiring the integer format used by the algorithm Lefertis' implementation is based off Dave Dribin's trigint C library http://www.dribin.org/dave/trigint/ Which in turn is based from a now deleted article which can be found in the Wayback Machine: http://web.archive.org/web/20120301144605/http://www.dattalo.com/technical/software/pic/picsine.html INDEX_WIDTH uint256 INDEX_WIDTH INTERP_WIDTH uint256 INTERP_WIDTH INDEX_OFFSET uint256 INDEX_OFFSET INTERP_OFFSET uint256 INTERP_OFFSET ANGLES_IN_CYCLE uint32 ANGLES_IN_CYCLE QUADRANT_HIGH_MASK uint32 QUADRANT_HIGH_MASK QUADRANT_LOW_MASK uint32 QUADRANT_LOW_MASK SINE_TABLE_SIZE uint256 SINE_TABLE_SIZE PI uint256 PI TWO_PI uint256 TWO_PI PI_OVER_TWO uint256 PI_OVER_TWO entry_bytes uint8 entry_bytes entry_mask uint256 entry_mask sin_table bytes sin_table sin function sin(uint256 _angle) internal pure returns (int256) Return the sine of a value, specified in radians scaled by 1e18 This algorithm for converting sine only uses integer values, and it works by dividing the circle into 30 bit angles, i.e. there are 1,073,741,824 (2^30) angle units, instead of the standard 360 degrees (2pi radians). From there, we get an output in range -2,147,483,647 to 2,147,483,647, (which is the max value of an int32) which is then converted back to the standard range of -1 to 1, again scaled by 1e18 Name Type Description _angle uint256 Angle to convert Name Type Description [0] int256 Result scaled by 1e18 cos function cos(uint256 _angle) internal pure returns (int256) Return the cosine of a value, specified in radians scaled by 1e18 This is identical to the sin() method, and just computes the value by delegating to the sin() method using the identity cos(x) = sin(x + pi/2) Overflow when angle + PI_OVER_TWO > type(uint256).max is ok, results are still accurate Name Type Description _angle uint256 Angle to convert Name Type Description [0] int256 Result scaled by 1e18","title":"Trigonometry"},{"location":"solidity-trigonometry/Trigonometry/#trigonometry","text":"Solidity library offering basic trigonometry functions where inputs and outputs are integers. Inputs are specified in radians scaled by 1e18, and similarly outputs are scaled by 1e18. This implementation is based off the Solidity trigonometry library written by Lefteris Karapetsas which can be found here: https://github.com/Sikorkaio/sikorka/blob/e75c91925c914beaedf4841c0336a806f2b5f66d/contracts/trigonometry.sol Compared to Lefteris' implementation, this version makes the following changes: - Uses a 32 bits instead of 16 bits for improved accuracy - Updated for Solidity 0.8.x - Various gas optimizations - Change inputs/outputs to standard trig format (scaled by 1e18) instead of requiring the integer format used by the algorithm Lefertis' implementation is based off Dave Dribin's trigint C library http://www.dribin.org/dave/trigint/ Which in turn is based from a now deleted article which can be found in the Wayback Machine: http://web.archive.org/web/20120301144605/http://www.dattalo.com/technical/software/pic/picsine.html","title":"Trigonometry"},{"location":"solidity-trigonometry/Trigonometry/#index_width","text":"uint256 INDEX_WIDTH","title":"INDEX_WIDTH"},{"location":"solidity-trigonometry/Trigonometry/#interp_width","text":"uint256 INTERP_WIDTH","title":"INTERP_WIDTH"},{"location":"solidity-trigonometry/Trigonometry/#index_offset","text":"uint256 INDEX_OFFSET","title":"INDEX_OFFSET"},{"location":"solidity-trigonometry/Trigonometry/#interp_offset","text":"uint256 INTERP_OFFSET","title":"INTERP_OFFSET"},{"location":"solidity-trigonometry/Trigonometry/#angles_in_cycle","text":"uint32 ANGLES_IN_CYCLE","title":"ANGLES_IN_CYCLE"},{"location":"solidity-trigonometry/Trigonometry/#quadrant_high_mask","text":"uint32 QUADRANT_HIGH_MASK","title":"QUADRANT_HIGH_MASK"},{"location":"solidity-trigonometry/Trigonometry/#quadrant_low_mask","text":"uint32 QUADRANT_LOW_MASK","title":"QUADRANT_LOW_MASK"},{"location":"solidity-trigonometry/Trigonometry/#sine_table_size","text":"uint256 SINE_TABLE_SIZE","title":"SINE_TABLE_SIZE"},{"location":"solidity-trigonometry/Trigonometry/#pi","text":"uint256 PI","title":"PI"},{"location":"solidity-trigonometry/Trigonometry/#two_pi","text":"uint256 TWO_PI","title":"TWO_PI"},{"location":"solidity-trigonometry/Trigonometry/#pi_over_two","text":"uint256 PI_OVER_TWO","title":"PI_OVER_TWO"},{"location":"solidity-trigonometry/Trigonometry/#entry_bytes","text":"uint8 entry_bytes","title":"entry_bytes"},{"location":"solidity-trigonometry/Trigonometry/#entry_mask","text":"uint256 entry_mask","title":"entry_mask"},{"location":"solidity-trigonometry/Trigonometry/#sin_table","text":"bytes sin_table","title":"sin_table"},{"location":"solidity-trigonometry/Trigonometry/#sin","text":"function sin(uint256 _angle) internal pure returns (int256) Return the sine of a value, specified in radians scaled by 1e18 This algorithm for converting sine only uses integer values, and it works by dividing the circle into 30 bit angles, i.e. there are 1,073,741,824 (2^30) angle units, instead of the standard 360 degrees (2pi radians). From there, we get an output in range -2,147,483,647 to 2,147,483,647, (which is the max value of an int32) which is then converted back to the standard range of -1 to 1, again scaled by 1e18 Name Type Description _angle uint256 Angle to convert Name Type Description [0] int256 Result scaled by 1e18","title":"sin"},{"location":"solidity-trigonometry/Trigonometry/#cos","text":"function cos(uint256 _angle) internal pure returns (int256) Return the cosine of a value, specified in radians scaled by 1e18 This is identical to the sin() method, and just computes the value by delegating to the sin() method using the identity cos(x) = sin(x + pi/2) Overflow when angle + PI_OVER_TWO > type(uint256).max is ok, results are still accurate Name Type Description _angle uint256 Angle to convert Name Type Description [0] int256 Result scaled by 1e18","title":"cos"},{"location":"spatial-sol/Jurisdiction/","text":"Jurisdiction owner address owner boundaries int256[] boundaries numBoundaryPoints uint256 numBoundaryPoints name string name tax uint256 tax constructor constructor() public owned modifier owned(address _account) getBalance function getBalance() public view returns (uint256 balance_) updateBoundaries function updateBoundaries(int256[] _boundaries) public updateTaxRate function updateTaxRate(uint256 _newTaxRate) public updateJurisdictionName function updateJurisdictionName(string _newName) public transferOwnership function transferOwnership(address _newOwner) public","title":"Jurisdiction"},{"location":"spatial-sol/Jurisdiction/#jurisdiction","text":"","title":"Jurisdiction"},{"location":"spatial-sol/Jurisdiction/#owner","text":"address owner","title":"owner"},{"location":"spatial-sol/Jurisdiction/#boundaries","text":"int256[] boundaries","title":"boundaries"},{"location":"spatial-sol/Jurisdiction/#numboundarypoints","text":"uint256 numBoundaryPoints","title":"numBoundaryPoints"},{"location":"spatial-sol/Jurisdiction/#name","text":"string name","title":"name"},{"location":"spatial-sol/Jurisdiction/#tax","text":"uint256 tax","title":"tax"},{"location":"spatial-sol/Jurisdiction/#constructor","text":"constructor() public","title":"constructor"},{"location":"spatial-sol/Jurisdiction/#owned","text":"modifier owned(address _account)","title":"owned"},{"location":"spatial-sol/Jurisdiction/#getbalance","text":"function getBalance() public view returns (uint256 balance_)","title":"getBalance"},{"location":"spatial-sol/Jurisdiction/#updateboundaries","text":"function updateBoundaries(int256[] _boundaries) public","title":"updateBoundaries"},{"location":"spatial-sol/Jurisdiction/#updatetaxrate","text":"function updateTaxRate(uint256 _newTaxRate) public","title":"updateTaxRate"},{"location":"spatial-sol/Jurisdiction/#updatejurisdictionname","text":"function updateJurisdictionName(string _newName) public","title":"updateJurisdictionName"},{"location":"spatial-sol/Jurisdiction/#transferownership","text":"function transferOwnership(address _newOwner) public","title":"transferOwnership"},{"location":"spatial-sol/LocationAware/","text":"LocationAware owner address owner subscribedToJurisdiction mapping(address => bool) subscribedToJurisdiction jurisdictions address[] jurisdictions constructor constructor() public owned modifier owned(address _address) fund function fund() external payable getBalance function getBalance() public view returns (uint256 balance_) subscribeToJurisdiction function subscribeToJurisdiction(address _jurisdiction) public unsubscribeFromJurisdiction function unsubscribeFromJurisdiction(address _jurisdiction) public sendWithLocationChecks function sendWithLocationChecks(address payable _to, int256[2] _locationOfOwner, uint256 _value) public returns (uint256) withinJurisdictionBoundaries function withinJurisdictionBoundaries(int256[2] _point, int256[] _jurisdictionBoundaries) public pure returns (bool)","title":"LocationAware"},{"location":"spatial-sol/LocationAware/#locationaware","text":"","title":"LocationAware"},{"location":"spatial-sol/LocationAware/#owner","text":"address owner","title":"owner"},{"location":"spatial-sol/LocationAware/#subscribedtojurisdiction","text":"mapping(address => bool) subscribedToJurisdiction","title":"subscribedToJurisdiction"},{"location":"spatial-sol/LocationAware/#jurisdictions","text":"address[] jurisdictions","title":"jurisdictions"},{"location":"spatial-sol/LocationAware/#constructor","text":"constructor() public","title":"constructor"},{"location":"spatial-sol/LocationAware/#owned","text":"modifier owned(address _address)","title":"owned"},{"location":"spatial-sol/LocationAware/#fund","text":"function fund() external payable","title":"fund"},{"location":"spatial-sol/LocationAware/#getbalance","text":"function getBalance() public view returns (uint256 balance_)","title":"getBalance"},{"location":"spatial-sol/LocationAware/#subscribetojurisdiction","text":"function subscribeToJurisdiction(address _jurisdiction) public","title":"subscribeToJurisdiction"},{"location":"spatial-sol/LocationAware/#unsubscribefromjurisdiction","text":"function unsubscribeFromJurisdiction(address _jurisdiction) public","title":"unsubscribeFromJurisdiction"},{"location":"spatial-sol/LocationAware/#sendwithlocationchecks","text":"function sendWithLocationChecks(address payable _to, int256[2] _locationOfOwner, uint256 _value) public returns (uint256)","title":"sendWithLocationChecks"},{"location":"spatial-sol/LocationAware/#withinjurisdictionboundaries","text":"function withinJurisdictionBoundaries(int256[2] _point, int256[] _jurisdictionBoundaries) public pure returns (bool)","title":"withinJurisdictionBoundaries"},{"location":"spatial-sol/Migrations/","text":"Migrations owner address owner last_completed_migration uint256 last_completed_migration constructor constructor() public restricted modifier restricted() setCompleted function setCompleted(uint256 completed) public upgrade function upgrade(address new_address) public","title":"Migrations"},{"location":"spatial-sol/Migrations/#migrations","text":"","title":"Migrations"},{"location":"spatial-sol/Migrations/#owner","text":"address owner","title":"owner"},{"location":"spatial-sol/Migrations/#last_completed_migration","text":"uint256 last_completed_migration","title":"last_completed_migration"},{"location":"spatial-sol/Migrations/#constructor","text":"constructor() public","title":"constructor"},{"location":"spatial-sol/Migrations/#restricted","text":"modifier restricted()","title":"restricted"},{"location":"spatial-sol/Migrations/#setcompleted","text":"function setCompleted(uint256 completed) public","title":"setCompleted"},{"location":"spatial-sol/Migrations/#upgrade","text":"function upgrade(address new_address) public","title":"upgrade"},{"location":"spatial-sol/Spatial/","text":"Spatial earthRadius uint256 earthRadius piScaled uint256 piScaled sinDegrees function sinDegrees(uint256 _degrees) public pure returns (int256) sinNanodegrees function sinNanodegrees(uint256 _nanodegrees) public pure returns (int256) cosDegrees function cosDegrees(uint256 _degrees) public pure returns (int256) cosNanodegrees function cosNanodegrees(uint256 _nanodegrees) public pure returns (int256) isPolygon function isPolygon(int256[2][] _coordinates) public pure returns (bool) isLine function isLine(int256[2][] _coordinates) public pure returns (bool) sqrt function sqrt(int256 _x) public pure returns (uint256 y_) degreesToNanoradians function degreesToNanoradians(uint256 _degrees) public pure returns (uint256 radians_) nanodegreesToNanoradians function nanodegreesToNanoradians(uint256 _nanodegrees) public pure returns (uint256 radians_) nanoradiansToDegrees function nanoradiansToDegrees(uint256 _nanoradians) public pure returns (uint256 degrees_) earthNanoradiansToNanometers function earthNanoradiansToNanometers(uint256 _nanoradians) public pure returns (uint256 nanometers_) earthNanodegreesToNanometers function earthNanodegreesToNanometers(uint256 _nanodegrees) public pure returns (uint256 nanometers_) distance function distance(int256[2] ptA, int256[2] ptB) public view returns (uint256 distanceNanometers_) area function area(int256[2][] _coordinates) public pure returns (uint256 area_) centroid function centroid(int256[2][] _coordinates) public pure returns (int256[2]) boundingBox function boundingBox(int256[2][] _coordinates) public pure returns (int256[2][2]) length function length(int256[2][] _coordinates) public view returns (uint256 length_) perimeter function perimeter(int256[2][] _coordinates) public view returns (uint256 perimeter_) distanceBetweenAzimuthalEquidistantProjectedPoints function distanceBetweenAzimuthalEquidistantProjectedPoints(uint256[2] ptA, uint256[2] ptB) public view returns (uint256) bearingFromAzimuthalEquidistantProjectedPoints function bearingFromAzimuthalEquidistantProjectedPoints(uint256[2] ptA, uint256[2] ptB) public view returns (uint256) boundingBoxBuffer function boundingBoxBuffer(int256[2] _point, int256 _buffer) public pure returns (int256[2][2]) pointInBbox function pointInBbox(int256[2] _point, int256[2][2] _bbox) public pure returns (bool ptInsideBbox_) pointInPolygon function pointInPolygon(int256[2] _point, int256[] _polygon) public pure returns (bool)","title":"Spatial"},{"location":"spatial-sol/Spatial/#spatial","text":"","title":"Spatial"},{"location":"spatial-sol/Spatial/#earthradius","text":"uint256 earthRadius","title":"earthRadius"},{"location":"spatial-sol/Spatial/#piscaled","text":"uint256 piScaled","title":"piScaled"},{"location":"spatial-sol/Spatial/#sindegrees","text":"function sinDegrees(uint256 _degrees) public pure returns (int256)","title":"sinDegrees"},{"location":"spatial-sol/Spatial/#sinnanodegrees","text":"function sinNanodegrees(uint256 _nanodegrees) public pure returns (int256)","title":"sinNanodegrees"},{"location":"spatial-sol/Spatial/#cosdegrees","text":"function cosDegrees(uint256 _degrees) public pure returns (int256)","title":"cosDegrees"},{"location":"spatial-sol/Spatial/#cosnanodegrees","text":"function cosNanodegrees(uint256 _nanodegrees) public pure returns (int256)","title":"cosNanodegrees"},{"location":"spatial-sol/Spatial/#ispolygon","text":"function isPolygon(int256[2][] _coordinates) public pure returns (bool)","title":"isPolygon"},{"location":"spatial-sol/Spatial/#isline","text":"function isLine(int256[2][] _coordinates) public pure returns (bool)","title":"isLine"},{"location":"spatial-sol/Spatial/#sqrt","text":"function sqrt(int256 _x) public pure returns (uint256 y_)","title":"sqrt"},{"location":"spatial-sol/Spatial/#degreestonanoradians","text":"function degreesToNanoradians(uint256 _degrees) public pure returns (uint256 radians_)","title":"degreesToNanoradians"},{"location":"spatial-sol/Spatial/#nanodegreestonanoradians","text":"function nanodegreesToNanoradians(uint256 _nanodegrees) public pure returns (uint256 radians_)","title":"nanodegreesToNanoradians"},{"location":"spatial-sol/Spatial/#nanoradianstodegrees","text":"function nanoradiansToDegrees(uint256 _nanoradians) public pure returns (uint256 degrees_)","title":"nanoradiansToDegrees"},{"location":"spatial-sol/Spatial/#earthnanoradianstonanometers","text":"function earthNanoradiansToNanometers(uint256 _nanoradians) public pure returns (uint256 nanometers_)","title":"earthNanoradiansToNanometers"},{"location":"spatial-sol/Spatial/#earthnanodegreestonanometers","text":"function earthNanodegreesToNanometers(uint256 _nanodegrees) public pure returns (uint256 nanometers_)","title":"earthNanodegreesToNanometers"},{"location":"spatial-sol/Spatial/#distance","text":"function distance(int256[2] ptA, int256[2] ptB) public view returns (uint256 distanceNanometers_)","title":"distance"},{"location":"spatial-sol/Spatial/#area","text":"function area(int256[2][] _coordinates) public pure returns (uint256 area_)","title":"area"},{"location":"spatial-sol/Spatial/#centroid","text":"function centroid(int256[2][] _coordinates) public pure returns (int256[2])","title":"centroid"},{"location":"spatial-sol/Spatial/#boundingbox","text":"function boundingBox(int256[2][] _coordinates) public pure returns (int256[2][2])","title":"boundingBox"},{"location":"spatial-sol/Spatial/#length","text":"function length(int256[2][] _coordinates) public view returns (uint256 length_)","title":"length"},{"location":"spatial-sol/Spatial/#perimeter","text":"function perimeter(int256[2][] _coordinates) public view returns (uint256 perimeter_)","title":"perimeter"},{"location":"spatial-sol/Spatial/#distancebetweenazimuthalequidistantprojectedpoints","text":"function distanceBetweenAzimuthalEquidistantProjectedPoints(uint256[2] ptA, uint256[2] ptB) public view returns (uint256)","title":"distanceBetweenAzimuthalEquidistantProjectedPoints"},{"location":"spatial-sol/Spatial/#bearingfromazimuthalequidistantprojectedpoints","text":"function bearingFromAzimuthalEquidistantProjectedPoints(uint256[2] ptA, uint256[2] ptB) public view returns (uint256)","title":"bearingFromAzimuthalEquidistantProjectedPoints"},{"location":"spatial-sol/Spatial/#boundingboxbuffer","text":"function boundingBoxBuffer(int256[2] _point, int256 _buffer) public pure returns (int256[2][2])","title":"boundingBoxBuffer"},{"location":"spatial-sol/Spatial/#pointinbbox","text":"function pointInBbox(int256[2] _point, int256[2][2] _bbox) public pure returns (bool ptInsideBbox_)","title":"pointInBbox"},{"location":"spatial-sol/Spatial/#pointinpolygon","text":"function pointInPolygon(int256[2] _point, int256[] _polygon) public pure returns (bool)","title":"pointInPolygon"},{"location":"spatial-sol/Trigonometry/","text":"Trigonometry INDEX_WIDTH uint256 INDEX_WIDTH INTERP_WIDTH uint256 INTERP_WIDTH INDEX_OFFSET uint256 INDEX_OFFSET INTERP_OFFSET uint256 INTERP_OFFSET ANGLES_IN_CYCLE uint16 ANGLES_IN_CYCLE QUADRANT_HIGH_MASK uint16 QUADRANT_HIGH_MASK QUADRANT_LOW_MASK uint16 QUADRANT_LOW_MASK SINE_TABLE_SIZE uint256 SINE_TABLE_SIZE entry_bytes uint8 entry_bytes sin_table bytes sin_table bits function bits(uint256 _value, uint256 _width, uint256 _offset) internal pure returns (uint256) Convenience function to apply a mask on an integer to extract a certain number of bits. Using exponents since solidity still does not support shifting. Name Type Description _value uint256 The integer whose bits we want to get _width uint256 The width of the bits (in bits) we want to extract _offset uint256 The offset of the bits (in bits) we want to extract Name Type Description [0] uint256 An integer containing _width bits of _value starting at the _offset bit sin_table_lookup function sin_table_lookup(uint256 index) internal pure returns (uint16) sin function sin(uint16 _angle) public pure returns (int256) Return the sine of an integer approximated angle as a signed 16-bit integer. Name Type Description _angle uint16 A 16-bit angle. This divides the circle into 16384 angle units, instead of the standard 360 degrees. Name Type Description [0] int256 The sine result as a number in the range -32767 to 32767. cos function cos(uint16 _angle) public pure returns (int256) Return the cos of an integer approximated angle. It functions just like the sin() method but uses the trigonometric identity sin(x + pi/2) = cos(x) to quickly calculate the cos.","title":"Trigonometry"},{"location":"spatial-sol/Trigonometry/#trigonometry","text":"","title":"Trigonometry"},{"location":"spatial-sol/Trigonometry/#index_width","text":"uint256 INDEX_WIDTH","title":"INDEX_WIDTH"},{"location":"spatial-sol/Trigonometry/#interp_width","text":"uint256 INTERP_WIDTH","title":"INTERP_WIDTH"},{"location":"spatial-sol/Trigonometry/#index_offset","text":"uint256 INDEX_OFFSET","title":"INDEX_OFFSET"},{"location":"spatial-sol/Trigonometry/#interp_offset","text":"uint256 INTERP_OFFSET","title":"INTERP_OFFSET"},{"location":"spatial-sol/Trigonometry/#angles_in_cycle","text":"uint16 ANGLES_IN_CYCLE","title":"ANGLES_IN_CYCLE"},{"location":"spatial-sol/Trigonometry/#quadrant_high_mask","text":"uint16 QUADRANT_HIGH_MASK","title":"QUADRANT_HIGH_MASK"},{"location":"spatial-sol/Trigonometry/#quadrant_low_mask","text":"uint16 QUADRANT_LOW_MASK","title":"QUADRANT_LOW_MASK"},{"location":"spatial-sol/Trigonometry/#sine_table_size","text":"uint256 SINE_TABLE_SIZE","title":"SINE_TABLE_SIZE"},{"location":"spatial-sol/Trigonometry/#entry_bytes","text":"uint8 entry_bytes","title":"entry_bytes"},{"location":"spatial-sol/Trigonometry/#sin_table","text":"bytes sin_table","title":"sin_table"},{"location":"spatial-sol/Trigonometry/#bits","text":"function bits(uint256 _value, uint256 _width, uint256 _offset) internal pure returns (uint256) Convenience function to apply a mask on an integer to extract a certain number of bits. Using exponents since solidity still does not support shifting. Name Type Description _value uint256 The integer whose bits we want to get _width uint256 The width of the bits (in bits) we want to extract _offset uint256 The offset of the bits (in bits) we want to extract Name Type Description [0] uint256 An integer containing _width bits of _value starting at the _offset bit","title":"bits"},{"location":"spatial-sol/Trigonometry/#sin_table_lookup","text":"function sin_table_lookup(uint256 index) internal pure returns (uint16)","title":"sin_table_lookup"},{"location":"spatial-sol/Trigonometry/#sin","text":"function sin(uint16 _angle) public pure returns (int256) Return the sine of an integer approximated angle as a signed 16-bit integer. Name Type Description _angle uint16 A 16-bit angle. This divides the circle into 16384 angle units, instead of the standard 360 degrees. Name Type Description [0] int256 The sine result as a number in the range -32767 to 32767.","title":"sin"},{"location":"spatial-sol/Trigonometry/#cos","text":"function cos(uint16 _angle) public pure returns (int256) Return the cos of an integer approximated angle. It functions just like the sin() method but uses the trigonometric identity sin(x + pi/2) = cos(x) to quickly calculate the cos.","title":"cos"},{"location":"uniswap-v3-core/NoDelegateCall/","text":"NoDelegateCall Base contract that provides a modifier for preventing delegatecall to methods in a child contract original address original The original address of this contract constructor constructor() internal checkNotDelegateCall function checkNotDelegateCall() private view Private method is used instead of inlining into modifier because modifiers are copied into each method, and the use of immutable means the address bytes are copied in every place the modifier is used. noDelegateCall modifier noDelegateCall() Prevents delegatecall into the modified method","title":"NoDelegateCall"},{"location":"uniswap-v3-core/NoDelegateCall/#nodelegatecall","text":"Base contract that provides a modifier for preventing delegatecall to methods in a child contract","title":"NoDelegateCall"},{"location":"uniswap-v3-core/NoDelegateCall/#original","text":"address original The original address of this contract","title":"original"},{"location":"uniswap-v3-core/NoDelegateCall/#constructor","text":"constructor() internal","title":"constructor"},{"location":"uniswap-v3-core/NoDelegateCall/#checknotdelegatecall","text":"function checkNotDelegateCall() private view Private method is used instead of inlining into modifier because modifiers are copied into each method, and the use of immutable means the address bytes are copied in every place the modifier is used.","title":"checkNotDelegateCall"},{"location":"uniswap-v3-core/NoDelegateCall/#nodelegatecall_1","text":"modifier noDelegateCall() Prevents delegatecall into the modified method","title":"noDelegateCall"},{"location":"uniswap-v3-core/UniswapV3Factory/","text":"UniswapV3Factory Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees owner address owner Returns the current owner of the factory Can be changed by the current owner via setOwner Name Type Description feeAmountTickSpacing mapping(uint24 => int24) feeAmountTickSpacing Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled A fee amount can never be removed, so this value should be hard coded or cached in the calling context Name Type Description Name Type Description getPool mapping(address => mapping(address => mapping(uint24 => address))) getPool Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist tokenA and tokenB may be passed in either token0/token1 or token1/token0 order Name Type Description Name Type Description constructor constructor() public createPool function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool) Creates a pool for the given two tokens and fee tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments are invalid. Name Type Description tokenA address One of the two tokens in the desired pool tokenB address The other of the two tokens in the desired pool fee uint24 The desired fee for the pool Name Type Description pool address The address of the newly created pool setOwner function setOwner(address _owner) external Updates the owner of the factory Must be called by the current owner Name Type Description _owner address The new owner of the factory enableFeeAmount function enableFeeAmount(uint24 fee, int24 tickSpacing) public Enables a fee amount with the given tickSpacing Fee amounts may never be removed once enabled Name Type Description fee uint24 The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6) tickSpacing int24 The spacing between ticks to be enforced for all pools created with the given fee amount","title":"UniswapV3Factory"},{"location":"uniswap-v3-core/UniswapV3Factory/#uniswapv3factory","text":"Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees","title":"UniswapV3Factory"},{"location":"uniswap-v3-core/UniswapV3Factory/#owner","text":"address owner Returns the current owner of the factory Can be changed by the current owner via setOwner Name Type Description","title":"owner"},{"location":"uniswap-v3-core/UniswapV3Factory/#feeamounttickspacing","text":"mapping(uint24 => int24) feeAmountTickSpacing Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled A fee amount can never be removed, so this value should be hard coded or cached in the calling context Name Type Description Name Type Description","title":"feeAmountTickSpacing"},{"location":"uniswap-v3-core/UniswapV3Factory/#getpool","text":"mapping(address => mapping(address => mapping(uint24 => address))) getPool Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist tokenA and tokenB may be passed in either token0/token1 or token1/token0 order Name Type Description Name Type Description","title":"getPool"},{"location":"uniswap-v3-core/UniswapV3Factory/#constructor","text":"constructor() public","title":"constructor"},{"location":"uniswap-v3-core/UniswapV3Factory/#createpool","text":"function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool) Creates a pool for the given two tokens and fee tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments are invalid. Name Type Description tokenA address One of the two tokens in the desired pool tokenB address The other of the two tokens in the desired pool fee uint24 The desired fee for the pool Name Type Description pool address The address of the newly created pool","title":"createPool"},{"location":"uniswap-v3-core/UniswapV3Factory/#setowner","text":"function setOwner(address _owner) external Updates the owner of the factory Must be called by the current owner Name Type Description _owner address The new owner of the factory","title":"setOwner"},{"location":"uniswap-v3-core/UniswapV3Factory/#enablefeeamount","text":"function enableFeeAmount(uint24 fee, int24 tickSpacing) public Enables a fee amount with the given tickSpacing Fee amounts may never be removed once enabled Name Type Description fee uint24 The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6) tickSpacing int24 The spacing between ticks to be enforced for all pools created with the given fee amount","title":"enableFeeAmount"},{"location":"uniswap-v3-core/UniswapV3Pool/","text":"UniswapV3Pool factory address factory The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface Name Type Description token0 address token0 The first of the two tokens of the pool, sorted by address Name Type Description token1 address token1 The second of the two tokens of the pool, sorted by address Name Type Description fee uint24 fee The pool's fee in hundredths of a bip, i.e. 1e-6 Name Type Description tickSpacing int24 tickSpacing The pool tick spacing Ticks can only be used at multiples of this value, minimum of 1 and always positive e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ... This value is an int24 to avoid casting even though it is always positive. Name Type Description maxLiquidityPerTick uint128 maxLiquidityPerTick The maximum amount of position liquidity that can use any tick in the range This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool Name Type Description Slot0 struct Slot0 { uint160 sqrtPriceX96; int24 tick; uint16 observationIndex; uint16 observationCardinality; uint16 observationCardinalityNext; uint8 feeProtocol; bool unlocked; } slot0 struct UniswapV3Pool.Slot0 slot0 The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally. Name Type Description feeGrowthGlobal0X128 uint256 feeGrowthGlobal0X128 The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool This value can overflow the uint256 feeGrowthGlobal1X128 uint256 feeGrowthGlobal1X128 The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool This value can overflow the uint256 ProtocolFees struct ProtocolFees { uint128 token0; uint128 token1; } protocolFees struct UniswapV3Pool.ProtocolFees protocolFees The amounts of token0 and token1 that are owed to the protocol Protocol fees will never exceed uint128 max in either token liquidity uint128 liquidity The currently in range liquidity available to the pool This value has no relationship to the total liquidity across all ticks ticks mapping(int24 => struct Tick.Info) ticks Look up information about a specific tick in the pool Name Type Description Name Type Description tickBitmap mapping(int16 => uint256) tickBitmap Returns 256 packed tick initialized boolean values. See TickBitmap for more information positions mapping(bytes32 => struct Position.Info) positions Returns the information about a position by the position's key Name Type Description Name Type Description observations struct Oracle.Observation[65535] observations Returns data about a specific observation index You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array. Name Type Description Name Type Description lock modifier lock() Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance to a function before the pool is initialized. The reentrancy guard is required throughout the contract because we use balance checks to determine the payment status of interactions such as mint, swap and flash. onlyFactoryOwner modifier onlyFactoryOwner() Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner() constructor constructor() public checkTicks function checkTicks(int24 tickLower, int24 tickUpper) private pure Common checks for valid tick inputs. _blockTimestamp function _blockTimestamp() internal view virtual returns (uint32) Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests. balance0 function balance0() private view returns (uint256) Get the pool's balance of token0 This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize check balance1 function balance1() private view returns (uint256) Get the pool's balance of token1 This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize check snapshotCumulativesInside function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside) Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range Snapshots must only be compared to other snapshots, taken over a period for which a position existed. I.e., snapshots cannot be compared if a position is not held for the entire period between when the first snapshot is taken and the second snapshot is taken. Name Type Description tickLower int24 The lower tick of the range tickUpper int24 The upper tick of the range Name Type Description tickCumulativeInside int56 The snapshot of the tick accumulator for the range secondsPerLiquidityInsideX128 uint160 The snapshot of seconds per liquidity for the range secondsInside uint32 The snapshot of seconds per liquidity for the range observe function observe(uint32[] secondsAgos) external view returns (int56[] tickCumulatives, uint160[] secondsPerLiquidityCumulativeX128s) Returns the cumulative tick and liquidity as of each timestamp secondsAgo from the current block timestamp To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick, you must call it with secondsAgos = [3600, 0]. The time weighted average tick represents the geometric time weighted average price of the pool, in log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio. Name Type Description secondsAgos uint32[] From how long ago each cumulative tick and liquidity value should be returned Name Type Description tickCumulatives int56[] Cumulative tick values as of each secondsAgos from the current block timestamp secondsPerLiquidityCumulativeX128s uint160[] Cumulative seconds per liquidity-in-range value as of each secondsAgos from the current block timestamp increaseObservationCardinalityNext function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external Increase the maximum number of price and liquidity observations that this pool will store This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext. Name Type Description observationCardinalityNext uint16 The desired minimum number of observations for the pool to store initialize function initialize(uint160 sqrtPriceX96) external Sets the initial price for the pool not locked because it initializes unlocked Name Type Description sqrtPriceX96 uint160 the initial sqrt price of the pool as a Q64.96 ModifyPositionParams struct ModifyPositionParams { address owner; int24 tickLower; int24 tickUpper; int128 liquidityDelta; } _modifyPosition function _modifyPosition(struct UniswapV3Pool.ModifyPositionParams params) private returns (struct Position.Info position, int256 amount0, int256 amount1) Effect some changes to a position Name Type Description params struct UniswapV3Pool.ModifyPositionParams the position details and the change to the position's liquidity to effect Name Type Description position struct Position.Info a storage pointer referencing the position with the given owner and tick range amount0 int256 the amount of token0 owed to the pool, negative if the pool should pay the recipient amount1 int256 the amount of token1 owed to the pool, negative if the pool should pay the recipient _updatePosition function _updatePosition(address owner, int24 tickLower, int24 tickUpper, int128 liquidityDelta, int24 tick) private returns (struct Position.Info position) Gets and updates a position with the given liquidity delta Name Type Description owner address the owner of the position tickLower int24 the lower tick of the position's tick range tickUpper int24 the upper tick of the position's tick range liquidityDelta int128 tick int24 the current tick, passed to avoid sloads mint function mint(address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes data) external returns (uint256 amount0, uint256 amount1) Adds liquidity for the given recipient/tickLower/tickUpper position noDelegateCall is applied indirectly via _modifyPosition Name Type Description recipient address The address for which the liquidity will be created tickLower int24 The lower tick of the position in which to add liquidity tickUpper int24 The upper tick of the position in which to add liquidity amount uint128 The amount of liquidity to mint data bytes Any data that should be passed through to the callback Name Type Description amount0 uint256 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback amount1 uint256 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback collect function collect(address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128 amount0, uint128 amount1) Collects tokens owed to a position Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity. Name Type Description recipient address The address which should receive the fees collected tickLower int24 The lower tick of the position for which to collect fees tickUpper int24 The upper tick of the position for which to collect fees amount0Requested uint128 How much token0 should be withdrawn from the fees owed amount1Requested uint128 How much token1 should be withdrawn from the fees owed Name Type Description amount0 uint128 The amount of fees collected in token0 amount1 uint128 The amount of fees collected in token1 burn function burn(int24 tickLower, int24 tickUpper, uint128 amount) external returns (uint256 amount0, uint256 amount1) Burn liquidity from the sender and account tokens owed for the liquidity to the position noDelegateCall is applied indirectly via _modifyPosition Name Type Description tickLower int24 The lower tick of the position for which to burn liquidity tickUpper int24 The upper tick of the position for which to burn liquidity amount uint128 How much liquidity to burn Name Type Description amount0 uint256 The amount of token0 sent to the recipient amount1 uint256 The amount of token1 sent to the recipient SwapCache struct SwapCache { uint8 feeProtocol; uint128 liquidityStart; uint32 blockTimestamp; int56 tickCumulative; uint160 secondsPerLiquidityCumulativeX128; bool computedLatestObservation; } SwapState struct SwapState { int256 amountSpecifiedRemaining; int256 amountCalculated; uint160 sqrtPriceX96; int24 tick; uint256 feeGrowthGlobalX128; uint128 protocolFee; uint128 liquidity; } StepComputations struct StepComputations { uint160 sqrtPriceStartX96; int24 tickNext; bool initialized; uint160 sqrtPriceNextX96; uint256 amountIn; uint256 amountOut; uint256 feeAmount; } swap function swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) external returns (int256 amount0, int256 amount1) Swap token0 for token1, or token1 for token0 The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback Name Type Description recipient address The address to receive the output of the swap zeroForOne bool The direction of the swap, true for token0 to token1, false for token1 to token0 amountSpecified int256 The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative) sqrtPriceLimitX96 uint160 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap data bytes Any data to be passed through to the callback Name Type Description amount0 int256 The delta of the balance of token0 of the pool, exact when negative, minimum when positive amount1 int256 The delta of the balance of token1 of the pool, exact when negative, minimum when positive flash function flash(address recipient, uint256 amount0, uint256 amount1, bytes data) external Receive token0 and/or token1 and pay it back, plus a fee, in the callback The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount{0,1} and sending the donation amount(s) from the callback Name Type Description recipient address The address which will receive the token0 and token1 amounts amount0 uint256 The amount of token0 to send amount1 uint256 The amount of token1 to send data bytes Any data to be passed through to the callback setFeeProtocol function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external Set the denominator of the protocol's % share of the fees Name Type Description feeProtocol0 uint8 new protocol fee for token0 of the pool feeProtocol1 uint8 new protocol fee for token1 of the pool collectProtocol function collectProtocol(address recipient, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128 amount0, uint128 amount1) Collect the protocol fee accrued to the pool Name Type Description recipient address The address to which collected protocol fees should be sent amount0Requested uint128 The maximum amount of token0 to send, can be 0 to collect fees in only token1 amount1Requested uint128 The maximum amount of token1 to send, can be 0 to collect fees in only token0 Name Type Description amount0 uint128 The protocol fee collected in token0 amount1 uint128 The protocol fee collected in token1","title":"UniswapV3Pool"},{"location":"uniswap-v3-core/UniswapV3Pool/#uniswapv3pool","text":"","title":"UniswapV3Pool"},{"location":"uniswap-v3-core/UniswapV3Pool/#factory","text":"address factory The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface Name Type Description","title":"factory"},{"location":"uniswap-v3-core/UniswapV3Pool/#token0","text":"address token0 The first of the two tokens of the pool, sorted by address Name Type Description","title":"token0"},{"location":"uniswap-v3-core/UniswapV3Pool/#token1","text":"address token1 The second of the two tokens of the pool, sorted by address Name Type Description","title":"token1"},{"location":"uniswap-v3-core/UniswapV3Pool/#fee","text":"uint24 fee The pool's fee in hundredths of a bip, i.e. 1e-6 Name Type Description","title":"fee"},{"location":"uniswap-v3-core/UniswapV3Pool/#tickspacing","text":"int24 tickSpacing The pool tick spacing Ticks can only be used at multiples of this value, minimum of 1 and always positive e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ... This value is an int24 to avoid casting even though it is always positive. Name Type Description","title":"tickSpacing"},{"location":"uniswap-v3-core/UniswapV3Pool/#maxliquiditypertick","text":"uint128 maxLiquidityPerTick The maximum amount of position liquidity that can use any tick in the range This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool Name Type Description","title":"maxLiquidityPerTick"},{"location":"uniswap-v3-core/UniswapV3Pool/#slot0","text":"struct Slot0 { uint160 sqrtPriceX96; int24 tick; uint16 observationIndex; uint16 observationCardinality; uint16 observationCardinalityNext; uint8 feeProtocol; bool unlocked; }","title":"Slot0"},{"location":"uniswap-v3-core/UniswapV3Pool/#slot0_1","text":"struct UniswapV3Pool.Slot0 slot0 The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally. Name Type Description","title":"slot0"},{"location":"uniswap-v3-core/UniswapV3Pool/#feegrowthglobal0x128","text":"uint256 feeGrowthGlobal0X128 The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool This value can overflow the uint256","title":"feeGrowthGlobal0X128"},{"location":"uniswap-v3-core/UniswapV3Pool/#feegrowthglobal1x128","text":"uint256 feeGrowthGlobal1X128 The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool This value can overflow the uint256","title":"feeGrowthGlobal1X128"},{"location":"uniswap-v3-core/UniswapV3Pool/#protocolfees","text":"struct ProtocolFees { uint128 token0; uint128 token1; }","title":"ProtocolFees"},{"location":"uniswap-v3-core/UniswapV3Pool/#protocolfees_1","text":"struct UniswapV3Pool.ProtocolFees protocolFees The amounts of token0 and token1 that are owed to the protocol Protocol fees will never exceed uint128 max in either token","title":"protocolFees"},{"location":"uniswap-v3-core/UniswapV3Pool/#liquidity","text":"uint128 liquidity The currently in range liquidity available to the pool This value has no relationship to the total liquidity across all ticks","title":"liquidity"},{"location":"uniswap-v3-core/UniswapV3Pool/#ticks","text":"mapping(int24 => struct Tick.Info) ticks Look up information about a specific tick in the pool Name Type Description Name Type Description","title":"ticks"},{"location":"uniswap-v3-core/UniswapV3Pool/#tickbitmap","text":"mapping(int16 => uint256) tickBitmap Returns 256 packed tick initialized boolean values. See TickBitmap for more information","title":"tickBitmap"},{"location":"uniswap-v3-core/UniswapV3Pool/#positions","text":"mapping(bytes32 => struct Position.Info) positions Returns the information about a position by the position's key Name Type Description Name Type Description","title":"positions"},{"location":"uniswap-v3-core/UniswapV3Pool/#observations","text":"struct Oracle.Observation[65535] observations Returns data about a specific observation index You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array. Name Type Description Name Type Description","title":"observations"},{"location":"uniswap-v3-core/UniswapV3Pool/#lock","text":"modifier lock() Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance to a function before the pool is initialized. The reentrancy guard is required throughout the contract because we use balance checks to determine the payment status of interactions such as mint, swap and flash.","title":"lock"},{"location":"uniswap-v3-core/UniswapV3Pool/#onlyfactoryowner","text":"modifier onlyFactoryOwner() Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner()","title":"onlyFactoryOwner"},{"location":"uniswap-v3-core/UniswapV3Pool/#constructor","text":"constructor() public","title":"constructor"},{"location":"uniswap-v3-core/UniswapV3Pool/#checkticks","text":"function checkTicks(int24 tickLower, int24 tickUpper) private pure Common checks for valid tick inputs.","title":"checkTicks"},{"location":"uniswap-v3-core/UniswapV3Pool/#_blocktimestamp","text":"function _blockTimestamp() internal view virtual returns (uint32) Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.","title":"_blockTimestamp"},{"location":"uniswap-v3-core/UniswapV3Pool/#balance0","text":"function balance0() private view returns (uint256) Get the pool's balance of token0 This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize check","title":"balance0"},{"location":"uniswap-v3-core/UniswapV3Pool/#balance1","text":"function balance1() private view returns (uint256) Get the pool's balance of token1 This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize check","title":"balance1"},{"location":"uniswap-v3-core/UniswapV3Pool/#snapshotcumulativesinside","text":"function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside) Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range Snapshots must only be compared to other snapshots, taken over a period for which a position existed. I.e., snapshots cannot be compared if a position is not held for the entire period between when the first snapshot is taken and the second snapshot is taken. Name Type Description tickLower int24 The lower tick of the range tickUpper int24 The upper tick of the range Name Type Description tickCumulativeInside int56 The snapshot of the tick accumulator for the range secondsPerLiquidityInsideX128 uint160 The snapshot of seconds per liquidity for the range secondsInside uint32 The snapshot of seconds per liquidity for the range","title":"snapshotCumulativesInside"},{"location":"uniswap-v3-core/UniswapV3Pool/#observe","text":"function observe(uint32[] secondsAgos) external view returns (int56[] tickCumulatives, uint160[] secondsPerLiquidityCumulativeX128s) Returns the cumulative tick and liquidity as of each timestamp secondsAgo from the current block timestamp To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick, you must call it with secondsAgos = [3600, 0]. The time weighted average tick represents the geometric time weighted average price of the pool, in log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio. Name Type Description secondsAgos uint32[] From how long ago each cumulative tick and liquidity value should be returned Name Type Description tickCumulatives int56[] Cumulative tick values as of each secondsAgos from the current block timestamp secondsPerLiquidityCumulativeX128s uint160[] Cumulative seconds per liquidity-in-range value as of each secondsAgos from the current block timestamp","title":"observe"},{"location":"uniswap-v3-core/UniswapV3Pool/#increaseobservationcardinalitynext","text":"function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external Increase the maximum number of price and liquidity observations that this pool will store This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext. Name Type Description observationCardinalityNext uint16 The desired minimum number of observations for the pool to store","title":"increaseObservationCardinalityNext"},{"location":"uniswap-v3-core/UniswapV3Pool/#initialize","text":"function initialize(uint160 sqrtPriceX96) external Sets the initial price for the pool not locked because it initializes unlocked Name Type Description sqrtPriceX96 uint160 the initial sqrt price of the pool as a Q64.96","title":"initialize"},{"location":"uniswap-v3-core/UniswapV3Pool/#modifypositionparams","text":"struct ModifyPositionParams { address owner; int24 tickLower; int24 tickUpper; int128 liquidityDelta; }","title":"ModifyPositionParams"},{"location":"uniswap-v3-core/UniswapV3Pool/#_modifyposition","text":"function _modifyPosition(struct UniswapV3Pool.ModifyPositionParams params) private returns (struct Position.Info position, int256 amount0, int256 amount1) Effect some changes to a position Name Type Description params struct UniswapV3Pool.ModifyPositionParams the position details and the change to the position's liquidity to effect Name Type Description position struct Position.Info a storage pointer referencing the position with the given owner and tick range amount0 int256 the amount of token0 owed to the pool, negative if the pool should pay the recipient amount1 int256 the amount of token1 owed to the pool, negative if the pool should pay the recipient","title":"_modifyPosition"},{"location":"uniswap-v3-core/UniswapV3Pool/#_updateposition","text":"function _updatePosition(address owner, int24 tickLower, int24 tickUpper, int128 liquidityDelta, int24 tick) private returns (struct Position.Info position) Gets and updates a position with the given liquidity delta Name Type Description owner address the owner of the position tickLower int24 the lower tick of the position's tick range tickUpper int24 the upper tick of the position's tick range liquidityDelta int128 tick int24 the current tick, passed to avoid sloads","title":"_updatePosition"},{"location":"uniswap-v3-core/UniswapV3Pool/#mint","text":"function mint(address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes data) external returns (uint256 amount0, uint256 amount1) Adds liquidity for the given recipient/tickLower/tickUpper position noDelegateCall is applied indirectly via _modifyPosition Name Type Description recipient address The address for which the liquidity will be created tickLower int24 The lower tick of the position in which to add liquidity tickUpper int24 The upper tick of the position in which to add liquidity amount uint128 The amount of liquidity to mint data bytes Any data that should be passed through to the callback Name Type Description amount0 uint256 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback amount1 uint256 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback","title":"mint"},{"location":"uniswap-v3-core/UniswapV3Pool/#collect","text":"function collect(address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128 amount0, uint128 amount1) Collects tokens owed to a position Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity. Name Type Description recipient address The address which should receive the fees collected tickLower int24 The lower tick of the position for which to collect fees tickUpper int24 The upper tick of the position for which to collect fees amount0Requested uint128 How much token0 should be withdrawn from the fees owed amount1Requested uint128 How much token1 should be withdrawn from the fees owed Name Type Description amount0 uint128 The amount of fees collected in token0 amount1 uint128 The amount of fees collected in token1","title":"collect"},{"location":"uniswap-v3-core/UniswapV3Pool/#burn","text":"function burn(int24 tickLower, int24 tickUpper, uint128 amount) external returns (uint256 amount0, uint256 amount1) Burn liquidity from the sender and account tokens owed for the liquidity to the position noDelegateCall is applied indirectly via _modifyPosition Name Type Description tickLower int24 The lower tick of the position for which to burn liquidity tickUpper int24 The upper tick of the position for which to burn liquidity amount uint128 How much liquidity to burn Name Type Description amount0 uint256 The amount of token0 sent to the recipient amount1 uint256 The amount of token1 sent to the recipient","title":"burn"},{"location":"uniswap-v3-core/UniswapV3Pool/#swapcache","text":"struct SwapCache { uint8 feeProtocol; uint128 liquidityStart; uint32 blockTimestamp; int56 tickCumulative; uint160 secondsPerLiquidityCumulativeX128; bool computedLatestObservation; }","title":"SwapCache"},{"location":"uniswap-v3-core/UniswapV3Pool/#swapstate","text":"struct SwapState { int256 amountSpecifiedRemaining; int256 amountCalculated; uint160 sqrtPriceX96; int24 tick; uint256 feeGrowthGlobalX128; uint128 protocolFee; uint128 liquidity; }","title":"SwapState"},{"location":"uniswap-v3-core/UniswapV3Pool/#stepcomputations","text":"struct StepComputations { uint160 sqrtPriceStartX96; int24 tickNext; bool initialized; uint160 sqrtPriceNextX96; uint256 amountIn; uint256 amountOut; uint256 feeAmount; }","title":"StepComputations"},{"location":"uniswap-v3-core/UniswapV3Pool/#swap","text":"function swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) external returns (int256 amount0, int256 amount1) Swap token0 for token1, or token1 for token0 The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback Name Type Description recipient address The address to receive the output of the swap zeroForOne bool The direction of the swap, true for token0 to token1, false for token1 to token0 amountSpecified int256 The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative) sqrtPriceLimitX96 uint160 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap data bytes Any data to be passed through to the callback Name Type Description amount0 int256 The delta of the balance of token0 of the pool, exact when negative, minimum when positive amount1 int256 The delta of the balance of token1 of the pool, exact when negative, minimum when positive","title":"swap"},{"location":"uniswap-v3-core/UniswapV3Pool/#flash","text":"function flash(address recipient, uint256 amount0, uint256 amount1, bytes data) external Receive token0 and/or token1 and pay it back, plus a fee, in the callback The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount{0,1} and sending the donation amount(s) from the callback Name Type Description recipient address The address which will receive the token0 and token1 amounts amount0 uint256 The amount of token0 to send amount1 uint256 The amount of token1 to send data bytes Any data to be passed through to the callback","title":"flash"},{"location":"uniswap-v3-core/UniswapV3Pool/#setfeeprotocol","text":"function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external Set the denominator of the protocol's % share of the fees Name Type Description feeProtocol0 uint8 new protocol fee for token0 of the pool feeProtocol1 uint8 new protocol fee for token1 of the pool","title":"setFeeProtocol"},{"location":"uniswap-v3-core/UniswapV3Pool/#collectprotocol","text":"function collectProtocol(address recipient, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128 amount0, uint128 amount1) Collect the protocol fee accrued to the pool Name Type Description recipient address The address to which collected protocol fees should be sent amount0Requested uint128 The maximum amount of token0 to send, can be 0 to collect fees in only token1 amount1Requested uint128 The maximum amount of token1 to send, can be 0 to collect fees in only token0 Name Type Description amount0 uint128 The protocol fee collected in token0 amount1 uint128 The protocol fee collected in token1","title":"collectProtocol"},{"location":"uniswap-v3-core/UniswapV3PoolDeployer/","text":"UniswapV3PoolDeployer Parameters struct Parameters { address factory; address token0; address token1; uint24 fee; int24 tickSpacing; } parameters struct UniswapV3PoolDeployer.Parameters parameters Get the parameters to be used in constructing the pool, set transiently during pool creation. Called by the pool constructor to fetch the parameters of the pool Returns factory The factory address Returns token0 The first token of the pool by address sort order Returns token1 The second token of the pool by address sort order Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip Returns tickSpacing The minimum number of ticks between initialized ticks deploy function deploy(address factory, address token0, address token1, uint24 fee, int24 tickSpacing) internal returns (address pool) Deploys a pool with the given parameters by transiently setting the parameters storage slot and then clearing it after deploying the pool. Name Type Description factory address The contract address of the Uniswap V3 factory token0 address The first token of the pool by address sort order token1 address The second token of the pool by address sort order fee uint24 The fee collected upon every swap in the pool, denominated in hundredths of a bip tickSpacing int24 The spacing between usable ticks","title":"UniswapV3PoolDeployer"},{"location":"uniswap-v3-core/UniswapV3PoolDeployer/#uniswapv3pooldeployer","text":"","title":"UniswapV3PoolDeployer"},{"location":"uniswap-v3-core/UniswapV3PoolDeployer/#parameters","text":"struct Parameters { address factory; address token0; address token1; uint24 fee; int24 tickSpacing; }","title":"Parameters"},{"location":"uniswap-v3-core/UniswapV3PoolDeployer/#parameters_1","text":"struct UniswapV3PoolDeployer.Parameters parameters Get the parameters to be used in constructing the pool, set transiently during pool creation. Called by the pool constructor to fetch the parameters of the pool Returns factory The factory address Returns token0 The first token of the pool by address sort order Returns token1 The second token of the pool by address sort order Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip Returns tickSpacing The minimum number of ticks between initialized ticks","title":"parameters"},{"location":"uniswap-v3-core/UniswapV3PoolDeployer/#deploy","text":"function deploy(address factory, address token0, address token1, uint24 fee, int24 tickSpacing) internal returns (address pool) Deploys a pool with the given parameters by transiently setting the parameters storage slot and then clearing it after deploying the pool. Name Type Description factory address The contract address of the Uniswap V3 factory token0 address The first token of the pool by address sort order token1 address The second token of the pool by address sort order fee uint24 The fee collected upon every swap in the pool, denominated in hundredths of a bip tickSpacing int24 The spacing between usable ticks","title":"deploy"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/","text":"IERC20Minimal Contains a subset of the full ERC20 interface that is used in Uniswap V3 balanceOf function balanceOf(address account) external view returns (uint256) Returns the balance of a token Name Type Description account address The account for which to look up the number of tokens it has, i.e. its balance Name Type Description [0] uint256 The number of tokens held by the account transfer function transfer(address recipient, uint256 amount) external returns (bool) Transfers the amount of token from the msg.sender to the recipient Name Type Description recipient address The account that will receive the amount transferred amount uint256 The number of tokens to send from the sender to the recipient Name Type Description [0] bool Returns true for a successful transfer, false for an unsuccessful transfer allowance function allowance(address owner, address spender) external view returns (uint256) Returns the current allowance given to a spender by an owner Name Type Description owner address The account of the token owner spender address The account of the token spender Name Type Description [0] uint256 The current allowance granted by owner to spender approve function approve(address spender, uint256 amount) external returns (bool) Sets the allowance of a spender from the msg.sender to the value amount Name Type Description spender address The account which will be allowed to spend a given amount of the owners tokens amount uint256 The amount of tokens allowed to be used by spender Name Type Description [0] bool Returns true for a successful approval, false for unsuccessful transferFrom function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) Transfers amount tokens from sender to recipient up to the allowance given to the msg.sender Name Type Description sender address The account from which the transfer will be initiated recipient address The recipient of the transfer amount uint256 The amount of the transfer Name Type Description [0] bool Returns true for a successful transfer, false for unsuccessful Transfer event Transfer(address from, address to, uint256 value) Event emitted when tokens are transferred from one address to another, either via #transfer or #transferFrom . Name Type Description from address The account from which the tokens were sent, i.e. the balance decreased to address The account to which the tokens were sent, i.e. the balance increased value uint256 The amount of tokens that were transferred Approval event Approval(address owner, address spender, uint256 value) Event emitted when the approval amount for the spender of a given owner's tokens changes. Name Type Description owner address The account that approved spending of its tokens spender address The account for which the spending allowance was modified value uint256 The new allowance from the owner to the spender IERC20Minimal Contains a subset of the full ERC20 interface that is used in Uniswap V3 balanceOf function balanceOf(address account) external view returns (uint256) Returns the balance of a token Name Type Description account address The account for which to look up the number of tokens it has, i.e. its balance Name Type Description [0] uint256 The number of tokens held by the account transfer function transfer(address recipient, uint256 amount) external returns (bool) Transfers the amount of token from the msg.sender to the recipient Name Type Description recipient address The account that will receive the amount transferred amount uint256 The number of tokens to send from the sender to the recipient Name Type Description [0] bool Returns true for a successful transfer, false for an unsuccessful transfer allowance function allowance(address owner, address spender) external view returns (uint256) Returns the current allowance given to a spender by an owner Name Type Description owner address The account of the token owner spender address The account of the token spender Name Type Description [0] uint256 The current allowance granted by owner to spender approve function approve(address spender, uint256 amount) external returns (bool) Sets the allowance of a spender from the msg.sender to the value amount Name Type Description spender address The account which will be allowed to spend a given amount of the owners tokens amount uint256 The amount of tokens allowed to be used by spender Name Type Description [0] bool Returns true for a successful approval, false for unsuccessful transferFrom function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) Transfers amount tokens from sender to recipient up to the allowance given to the msg.sender Name Type Description sender address The account from which the transfer will be initiated recipient address The recipient of the transfer amount uint256 The amount of the transfer Name Type Description [0] bool Returns true for a successful transfer, false for unsuccessful Transfer event Transfer(address from, address to, uint256 value) Event emitted when tokens are transferred from one address to another, either via #transfer or #transferFrom . Name Type Description from address The account from which the tokens were sent, i.e. the balance decreased to address The account to which the tokens were sent, i.e. the balance increased value uint256 The amount of tokens that were transferred Approval event Approval(address owner, address spender, uint256 value) Event emitted when the approval amount for the spender of a given owner's tokens changes. Name Type Description owner address The account that approved spending of its tokens spender address The account for which the spending allowance was modified value uint256 The new allowance from the owner to the spender","title":"IERC20Minimal"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#ierc20minimal","text":"Contains a subset of the full ERC20 interface that is used in Uniswap V3","title":"IERC20Minimal"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#balanceof","text":"function balanceOf(address account) external view returns (uint256) Returns the balance of a token Name Type Description account address The account for which to look up the number of tokens it has, i.e. its balance Name Type Description [0] uint256 The number of tokens held by the account","title":"balanceOf"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#transfer","text":"function transfer(address recipient, uint256 amount) external returns (bool) Transfers the amount of token from the msg.sender to the recipient Name Type Description recipient address The account that will receive the amount transferred amount uint256 The number of tokens to send from the sender to the recipient Name Type Description [0] bool Returns true for a successful transfer, false for an unsuccessful transfer","title":"transfer"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#allowance","text":"function allowance(address owner, address spender) external view returns (uint256) Returns the current allowance given to a spender by an owner Name Type Description owner address The account of the token owner spender address The account of the token spender Name Type Description [0] uint256 The current allowance granted by owner to spender","title":"allowance"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#approve","text":"function approve(address spender, uint256 amount) external returns (bool) Sets the allowance of a spender from the msg.sender to the value amount Name Type Description spender address The account which will be allowed to spend a given amount of the owners tokens amount uint256 The amount of tokens allowed to be used by spender Name Type Description [0] bool Returns true for a successful approval, false for unsuccessful","title":"approve"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#transferfrom","text":"function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) Transfers amount tokens from sender to recipient up to the allowance given to the msg.sender Name Type Description sender address The account from which the transfer will be initiated recipient address The recipient of the transfer amount uint256 The amount of the transfer Name Type Description [0] bool Returns true for a successful transfer, false for unsuccessful","title":"transferFrom"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#transfer_1","text":"event Transfer(address from, address to, uint256 value) Event emitted when tokens are transferred from one address to another, either via #transfer or #transferFrom . Name Type Description from address The account from which the tokens were sent, i.e. the balance decreased to address The account to which the tokens were sent, i.e. the balance increased value uint256 The amount of tokens that were transferred","title":"Transfer"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#approval","text":"event Approval(address owner, address spender, uint256 value) Event emitted when the approval amount for the spender of a given owner's tokens changes. Name Type Description owner address The account that approved spending of its tokens spender address The account for which the spending allowance was modified value uint256 The new allowance from the owner to the spender","title":"Approval"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#ierc20minimal_1","text":"Contains a subset of the full ERC20 interface that is used in Uniswap V3","title":"IERC20Minimal"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#balanceof_1","text":"function balanceOf(address account) external view returns (uint256) Returns the balance of a token Name Type Description account address The account for which to look up the number of tokens it has, i.e. its balance Name Type Description [0] uint256 The number of tokens held by the account","title":"balanceOf"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#transfer_2","text":"function transfer(address recipient, uint256 amount) external returns (bool) Transfers the amount of token from the msg.sender to the recipient Name Type Description recipient address The account that will receive the amount transferred amount uint256 The number of tokens to send from the sender to the recipient Name Type Description [0] bool Returns true for a successful transfer, false for an unsuccessful transfer","title":"transfer"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#allowance_1","text":"function allowance(address owner, address spender) external view returns (uint256) Returns the current allowance given to a spender by an owner Name Type Description owner address The account of the token owner spender address The account of the token spender Name Type Description [0] uint256 The current allowance granted by owner to spender","title":"allowance"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#approve_1","text":"function approve(address spender, uint256 amount) external returns (bool) Sets the allowance of a spender from the msg.sender to the value amount Name Type Description spender address The account which will be allowed to spend a given amount of the owners tokens amount uint256 The amount of tokens allowed to be used by spender Name Type Description [0] bool Returns true for a successful approval, false for unsuccessful","title":"approve"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#transferfrom_1","text":"function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) Transfers amount tokens from sender to recipient up to the allowance given to the msg.sender Name Type Description sender address The account from which the transfer will be initiated recipient address The recipient of the transfer amount uint256 The amount of the transfer Name Type Description [0] bool Returns true for a successful transfer, false for unsuccessful","title":"transferFrom"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#transfer_3","text":"event Transfer(address from, address to, uint256 value) Event emitted when tokens are transferred from one address to another, either via #transfer or #transferFrom . Name Type Description from address The account from which the tokens were sent, i.e. the balance decreased to address The account to which the tokens were sent, i.e. the balance increased value uint256 The amount of tokens that were transferred","title":"Transfer"},{"location":"uniswap-v3-core/interfaces/IERC20Minimal/#approval_1","text":"event Approval(address owner, address spender, uint256 value) Event emitted when the approval amount for the spender of a given owner's tokens changes. Name Type Description owner address The account that approved spending of its tokens spender address The account for which the spending allowance was modified value uint256 The new allowance from the owner to the spender","title":"Approval"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/","text":"IUniswapV3Factory The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees OwnerChanged event OwnerChanged(address oldOwner, address newOwner) Emitted when the owner of the factory is changed Name Type Description oldOwner address The owner before the owner was changed newOwner address The owner after the owner was changed PoolCreated event PoolCreated(address token0, address token1, uint24 fee, int24 tickSpacing, address pool) Emitted when a pool is created Name Type Description token0 address The first token of the pool by address sort order token1 address The second token of the pool by address sort order fee uint24 The fee collected upon every swap in the pool, denominated in hundredths of a bip tickSpacing int24 The minimum number of ticks between initialized ticks pool address The address of the created pool FeeAmountEnabled event FeeAmountEnabled(uint24 fee, int24 tickSpacing) Emitted when a new fee amount is enabled for pool creation via the factory Name Type Description fee uint24 The enabled fee, denominated in hundredths of a bip tickSpacing int24 The minimum number of ticks between initialized ticks for pools created with the given fee owner function owner() external view returns (address) Returns the current owner of the factory Can be changed by the current owner via setOwner Name Type Description [0] address The address of the factory owner feeAmountTickSpacing function feeAmountTickSpacing(uint24 fee) external view returns (int24) Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled A fee amount can never be removed, so this value should be hard coded or cached in the calling context Name Type Description fee uint24 The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee Name Type Description [0] int24 The tick spacing getPool function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool) Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist tokenA and tokenB may be passed in either token0/token1 or token1/token0 order Name Type Description tokenA address The contract address of either token0 or token1 tokenB address The contract address of the other token fee uint24 The fee collected upon every swap in the pool, denominated in hundredths of a bip Name Type Description pool address The pool address createPool function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool) Creates a pool for the given two tokens and fee tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments are invalid. Name Type Description tokenA address One of the two tokens in the desired pool tokenB address The other of the two tokens in the desired pool fee uint24 The desired fee for the pool Name Type Description pool address The address of the newly created pool setOwner function setOwner(address _owner) external Updates the owner of the factory Must be called by the current owner Name Type Description _owner address The new owner of the factory enableFeeAmount function enableFeeAmount(uint24 fee, int24 tickSpacing) external Enables a fee amount with the given tickSpacing Fee amounts may never be removed once enabled Name Type Description fee uint24 The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6) tickSpacing int24 The spacing between ticks to be enforced for all pools created with the given fee amount IUniswapV3Factory The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees OwnerChanged event OwnerChanged(address oldOwner, address newOwner) Emitted when the owner of the factory is changed Name Type Description oldOwner address The owner before the owner was changed newOwner address The owner after the owner was changed PoolCreated event PoolCreated(address token0, address token1, uint24 fee, int24 tickSpacing, address pool) Emitted when a pool is created Name Type Description token0 address The first token of the pool by address sort order token1 address The second token of the pool by address sort order fee uint24 The fee collected upon every swap in the pool, denominated in hundredths of a bip tickSpacing int24 The minimum number of ticks between initialized ticks pool address The address of the created pool FeeAmountEnabled event FeeAmountEnabled(uint24 fee, int24 tickSpacing) Emitted when a new fee amount is enabled for pool creation via the factory Name Type Description fee uint24 The enabled fee, denominated in hundredths of a bip tickSpacing int24 The minimum number of ticks between initialized ticks for pools created with the given fee owner function owner() external view returns (address) Returns the current owner of the factory Can be changed by the current owner via setOwner Name Type Description [0] address The address of the factory owner feeAmountTickSpacing function feeAmountTickSpacing(uint24 fee) external view returns (int24) Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled A fee amount can never be removed, so this value should be hard coded or cached in the calling context Name Type Description fee uint24 The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee Name Type Description [0] int24 The tick spacing getPool function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool) Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist tokenA and tokenB may be passed in either token0/token1 or token1/token0 order Name Type Description tokenA address The contract address of either token0 or token1 tokenB address The contract address of the other token fee uint24 The fee collected upon every swap in the pool, denominated in hundredths of a bip Name Type Description pool address The pool address createPool function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool) Creates a pool for the given two tokens and fee tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments are invalid. Name Type Description tokenA address One of the two tokens in the desired pool tokenB address The other of the two tokens in the desired pool fee uint24 The desired fee for the pool Name Type Description pool address The address of the newly created pool setOwner function setOwner(address _owner) external Updates the owner of the factory Must be called by the current owner Name Type Description _owner address The new owner of the factory enableFeeAmount function enableFeeAmount(uint24 fee, int24 tickSpacing) external Enables a fee amount with the given tickSpacing Fee amounts may never be removed once enabled Name Type Description fee uint24 The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6) tickSpacing int24 The spacing between ticks to be enforced for all pools created with the given fee amount","title":"IUniswapV3Factory"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#iuniswapv3factory","text":"The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees","title":"IUniswapV3Factory"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#ownerchanged","text":"event OwnerChanged(address oldOwner, address newOwner) Emitted when the owner of the factory is changed Name Type Description oldOwner address The owner before the owner was changed newOwner address The owner after the owner was changed","title":"OwnerChanged"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#poolcreated","text":"event PoolCreated(address token0, address token1, uint24 fee, int24 tickSpacing, address pool) Emitted when a pool is created Name Type Description token0 address The first token of the pool by address sort order token1 address The second token of the pool by address sort order fee uint24 The fee collected upon every swap in the pool, denominated in hundredths of a bip tickSpacing int24 The minimum number of ticks between initialized ticks pool address The address of the created pool","title":"PoolCreated"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#feeamountenabled","text":"event FeeAmountEnabled(uint24 fee, int24 tickSpacing) Emitted when a new fee amount is enabled for pool creation via the factory Name Type Description fee uint24 The enabled fee, denominated in hundredths of a bip tickSpacing int24 The minimum number of ticks between initialized ticks for pools created with the given fee","title":"FeeAmountEnabled"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#owner","text":"function owner() external view returns (address) Returns the current owner of the factory Can be changed by the current owner via setOwner Name Type Description [0] address The address of the factory owner","title":"owner"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#feeamounttickspacing","text":"function feeAmountTickSpacing(uint24 fee) external view returns (int24) Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled A fee amount can never be removed, so this value should be hard coded or cached in the calling context Name Type Description fee uint24 The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee Name Type Description [0] int24 The tick spacing","title":"feeAmountTickSpacing"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#getpool","text":"function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool) Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist tokenA and tokenB may be passed in either token0/token1 or token1/token0 order Name Type Description tokenA address The contract address of either token0 or token1 tokenB address The contract address of the other token fee uint24 The fee collected upon every swap in the pool, denominated in hundredths of a bip Name Type Description pool address The pool address","title":"getPool"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#createpool","text":"function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool) Creates a pool for the given two tokens and fee tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments are invalid. Name Type Description tokenA address One of the two tokens in the desired pool tokenB address The other of the two tokens in the desired pool fee uint24 The desired fee for the pool Name Type Description pool address The address of the newly created pool","title":"createPool"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#setowner","text":"function setOwner(address _owner) external Updates the owner of the factory Must be called by the current owner Name Type Description _owner address The new owner of the factory","title":"setOwner"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#enablefeeamount","text":"function enableFeeAmount(uint24 fee, int24 tickSpacing) external Enables a fee amount with the given tickSpacing Fee amounts may never be removed once enabled Name Type Description fee uint24 The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6) tickSpacing int24 The spacing between ticks to be enforced for all pools created with the given fee amount","title":"enableFeeAmount"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#iuniswapv3factory_1","text":"The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees","title":"IUniswapV3Factory"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#ownerchanged_1","text":"event OwnerChanged(address oldOwner, address newOwner) Emitted when the owner of the factory is changed Name Type Description oldOwner address The owner before the owner was changed newOwner address The owner after the owner was changed","title":"OwnerChanged"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#poolcreated_1","text":"event PoolCreated(address token0, address token1, uint24 fee, int24 tickSpacing, address pool) Emitted when a pool is created Name Type Description token0 address The first token of the pool by address sort order token1 address The second token of the pool by address sort order fee uint24 The fee collected upon every swap in the pool, denominated in hundredths of a bip tickSpacing int24 The minimum number of ticks between initialized ticks pool address The address of the created pool","title":"PoolCreated"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#feeamountenabled_1","text":"event FeeAmountEnabled(uint24 fee, int24 tickSpacing) Emitted when a new fee amount is enabled for pool creation via the factory Name Type Description fee uint24 The enabled fee, denominated in hundredths of a bip tickSpacing int24 The minimum number of ticks between initialized ticks for pools created with the given fee","title":"FeeAmountEnabled"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#owner_1","text":"function owner() external view returns (address) Returns the current owner of the factory Can be changed by the current owner via setOwner Name Type Description [0] address The address of the factory owner","title":"owner"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#feeamounttickspacing_1","text":"function feeAmountTickSpacing(uint24 fee) external view returns (int24) Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled A fee amount can never be removed, so this value should be hard coded or cached in the calling context Name Type Description fee uint24 The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee Name Type Description [0] int24 The tick spacing","title":"feeAmountTickSpacing"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#getpool_1","text":"function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool) Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist tokenA and tokenB may be passed in either token0/token1 or token1/token0 order Name Type Description tokenA address The contract address of either token0 or token1 tokenB address The contract address of the other token fee uint24 The fee collected upon every swap in the pool, denominated in hundredths of a bip Name Type Description pool address The pool address","title":"getPool"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#createpool_1","text":"function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool) Creates a pool for the given two tokens and fee tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments are invalid. Name Type Description tokenA address One of the two tokens in the desired pool tokenB address The other of the two tokens in the desired pool fee uint24 The desired fee for the pool Name Type Description pool address The address of the newly created pool","title":"createPool"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#setowner_1","text":"function setOwner(address _owner) external Updates the owner of the factory Must be called by the current owner Name Type Description _owner address The new owner of the factory","title":"setOwner"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Factory/#enablefeeamount_1","text":"function enableFeeAmount(uint24 fee, int24 tickSpacing) external Enables a fee amount with the given tickSpacing Fee amounts may never be removed once enabled Name Type Description fee uint24 The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6) tickSpacing int24 The spacing between ticks to be enforced for all pools created with the given fee amount","title":"enableFeeAmount"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Pool/","text":"IUniswapV3Pool A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform to the ERC20 specification The pool interface is broken up into many smaller pieces IUniswapV3Pool A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform to the ERC20 specification The pool interface is broken up into many smaller pieces","title":"IUniswapV3Pool"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Pool/#iuniswapv3pool","text":"A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform to the ERC20 specification The pool interface is broken up into many smaller pieces","title":"IUniswapV3Pool"},{"location":"uniswap-v3-core/interfaces/IUniswapV3Pool/#iuniswapv3pool_1","text":"A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform to the ERC20 specification The pool interface is broken up into many smaller pieces","title":"IUniswapV3Pool"},{"location":"uniswap-v3-core/interfaces/IUniswapV3PoolDeployer/","text":"IUniswapV3PoolDeployer A contract that constructs a pool must implement this to pass arguments to the pool This is used to avoid having constructor arguments in the pool contract, which results in the init code hash of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain parameters function parameters() external view returns (address factory, address token0, address token1, uint24 fee, int24 tickSpacing) Get the parameters to be used in constructing the pool, set transiently during pool creation. Called by the pool constructor to fetch the parameters of the pool Returns factory The factory address Returns token0 The first token of the pool by address sort order Returns token1 The second token of the pool by address sort order Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip Returns tickSpacing The minimum number of ticks between initialized ticks IUniswapV3PoolDeployer A contract that constructs a pool must implement this to pass arguments to the pool This is used to avoid having constructor arguments in the pool contract, which results in the init code hash of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain parameters function parameters() external view returns (address factory, address token0, address token1, uint24 fee, int24 tickSpacing) Get the parameters to be used in constructing the pool, set transiently during pool creation. Called by the pool constructor to fetch the parameters of the pool Returns factory The factory address Returns token0 The first token of the pool by address sort order Returns token1 The second token of the pool by address sort order Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip Returns tickSpacing The minimum number of ticks between initialized ticks","title":"IUniswapV3PoolDeployer"},{"location":"uniswap-v3-core/interfaces/IUniswapV3PoolDeployer/#iuniswapv3pooldeployer","text":"A contract that constructs a pool must implement this to pass arguments to the pool This is used to avoid having constructor arguments in the pool contract, which results in the init code hash of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain","title":"IUniswapV3PoolDeployer"},{"location":"uniswap-v3-core/interfaces/IUniswapV3PoolDeployer/#parameters","text":"function parameters() external view returns (address factory, address token0, address token1, uint24 fee, int24 tickSpacing) Get the parameters to be used in constructing the pool, set transiently during pool creation. Called by the pool constructor to fetch the parameters of the pool Returns factory The factory address Returns token0 The first token of the pool by address sort order Returns token1 The second token of the pool by address sort order Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip Returns tickSpacing The minimum number of ticks between initialized ticks","title":"parameters"},{"location":"uniswap-v3-core/interfaces/IUniswapV3PoolDeployer/#iuniswapv3pooldeployer_1","text":"A contract that constructs a pool must implement this to pass arguments to the pool This is used to avoid having constructor arguments in the pool contract, which results in the init code hash of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain","title":"IUniswapV3PoolDeployer"},{"location":"uniswap-v3-core/interfaces/IUniswapV3PoolDeployer/#parameters_1","text":"function parameters() external view returns (address factory, address token0, address token1, uint24 fee, int24 tickSpacing) Get the parameters to be used in constructing the pool, set transiently during pool creation. Called by the pool constructor to fetch the parameters of the pool Returns factory The factory address Returns token0 The first token of the pool by address sort order Returns token1 The second token of the pool by address sort order Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip Returns tickSpacing The minimum number of ticks between initialized ticks","title":"parameters"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3FlashCallback/","text":"IUniswapV3FlashCallback Any contract that calls IUniswapV3PoolActions#flash must implement this interface uniswapV3FlashCallback function uniswapV3FlashCallback(uint256 fee0, uint256 fee1, bytes data) external Called to msg.sender after transferring to the recipient from IUniswapV3Pool#flash. In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. Name Type Description fee0 uint256 The fee amount in token0 due to the pool by the end of the flash fee1 uint256 The fee amount in token1 due to the pool by the end of the flash data bytes Any data passed through by the caller via the IUniswapV3PoolActions#flash call IUniswapV3FlashCallback Any contract that calls IUniswapV3PoolActions#flash must implement this interface uniswapV3FlashCallback function uniswapV3FlashCallback(uint256 fee0, uint256 fee1, bytes data) external Called to msg.sender after transferring to the recipient from IUniswapV3Pool#flash. In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. Name Type Description fee0 uint256 The fee amount in token0 due to the pool by the end of the flash fee1 uint256 The fee amount in token1 due to the pool by the end of the flash data bytes Any data passed through by the caller via the IUniswapV3PoolActions#flash call","title":"IUniswapV3FlashCallback"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3FlashCallback/#iuniswapv3flashcallback","text":"Any contract that calls IUniswapV3PoolActions#flash must implement this interface","title":"IUniswapV3FlashCallback"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3FlashCallback/#uniswapv3flashcallback","text":"function uniswapV3FlashCallback(uint256 fee0, uint256 fee1, bytes data) external Called to msg.sender after transferring to the recipient from IUniswapV3Pool#flash. In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. Name Type Description fee0 uint256 The fee amount in token0 due to the pool by the end of the flash fee1 uint256 The fee amount in token1 due to the pool by the end of the flash data bytes Any data passed through by the caller via the IUniswapV3PoolActions#flash call","title":"uniswapV3FlashCallback"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3FlashCallback/#iuniswapv3flashcallback_1","text":"Any contract that calls IUniswapV3PoolActions#flash must implement this interface","title":"IUniswapV3FlashCallback"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3FlashCallback/#uniswapv3flashcallback_1","text":"function uniswapV3FlashCallback(uint256 fee0, uint256 fee1, bytes data) external Called to msg.sender after transferring to the recipient from IUniswapV3Pool#flash. In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. Name Type Description fee0 uint256 The fee amount in token0 due to the pool by the end of the flash fee1 uint256 The fee amount in token1 due to the pool by the end of the flash data bytes Any data passed through by the caller via the IUniswapV3PoolActions#flash call","title":"uniswapV3FlashCallback"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3MintCallback/","text":"IUniswapV3MintCallback Any contract that calls IUniswapV3PoolActions#mint must implement this interface uniswapV3MintCallback function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes data) external Called to msg.sender after minting liquidity to a position from IUniswapV3Pool#mint. In the implementation you must pay the pool tokens owed for the minted liquidity. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. Name Type Description amount0Owed uint256 The amount of token0 due to the pool for the minted liquidity amount1Owed uint256 The amount of token1 due to the pool for the minted liquidity data bytes Any data passed through by the caller via the IUniswapV3PoolActions#mint call IUniswapV3MintCallback Any contract that calls IUniswapV3PoolActions#mint must implement this interface uniswapV3MintCallback function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes data) external Called to msg.sender after minting liquidity to a position from IUniswapV3Pool#mint. In the implementation you must pay the pool tokens owed for the minted liquidity. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. Name Type Description amount0Owed uint256 The amount of token0 due to the pool for the minted liquidity amount1Owed uint256 The amount of token1 due to the pool for the minted liquidity data bytes Any data passed through by the caller via the IUniswapV3PoolActions#mint call","title":"IUniswapV3MintCallback"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3MintCallback/#iuniswapv3mintcallback","text":"Any contract that calls IUniswapV3PoolActions#mint must implement this interface","title":"IUniswapV3MintCallback"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3MintCallback/#uniswapv3mintcallback","text":"function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes data) external Called to msg.sender after minting liquidity to a position from IUniswapV3Pool#mint. In the implementation you must pay the pool tokens owed for the minted liquidity. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. Name Type Description amount0Owed uint256 The amount of token0 due to the pool for the minted liquidity amount1Owed uint256 The amount of token1 due to the pool for the minted liquidity data bytes Any data passed through by the caller via the IUniswapV3PoolActions#mint call","title":"uniswapV3MintCallback"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3MintCallback/#iuniswapv3mintcallback_1","text":"Any contract that calls IUniswapV3PoolActions#mint must implement this interface","title":"IUniswapV3MintCallback"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3MintCallback/#uniswapv3mintcallback_1","text":"function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes data) external Called to msg.sender after minting liquidity to a position from IUniswapV3Pool#mint. In the implementation you must pay the pool tokens owed for the minted liquidity. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. Name Type Description amount0Owed uint256 The amount of token0 due to the pool for the minted liquidity amount1Owed uint256 The amount of token1 due to the pool for the minted liquidity data bytes Any data passed through by the caller via the IUniswapV3PoolActions#mint call","title":"uniswapV3MintCallback"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3SwapCallback/","text":"IUniswapV3SwapCallback Any contract that calls IUniswapV3PoolActions#swap must implement this interface uniswapV3SwapCallback function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes data) external Called to msg.sender after executing a swap via IUniswapV3Pool#swap. In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped. Name Type Description amount0Delta int256 The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool. amount1Delta int256 The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool. data bytes Any data passed through by the caller via the IUniswapV3PoolActions#swap call IUniswapV3SwapCallback Any contract that calls IUniswapV3PoolActions#swap must implement this interface uniswapV3SwapCallback function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes data) external Called to msg.sender after executing a swap via IUniswapV3Pool#swap. In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped. Name Type Description amount0Delta int256 The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool. amount1Delta int256 The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool. data bytes Any data passed through by the caller via the IUniswapV3PoolActions#swap call","title":"IUniswapV3SwapCallback"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3SwapCallback/#iuniswapv3swapcallback","text":"Any contract that calls IUniswapV3PoolActions#swap must implement this interface","title":"IUniswapV3SwapCallback"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3SwapCallback/#uniswapv3swapcallback","text":"function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes data) external Called to msg.sender after executing a swap via IUniswapV3Pool#swap. In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped. Name Type Description amount0Delta int256 The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool. amount1Delta int256 The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool. data bytes Any data passed through by the caller via the IUniswapV3PoolActions#swap call","title":"uniswapV3SwapCallback"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3SwapCallback/#iuniswapv3swapcallback_1","text":"Any contract that calls IUniswapV3PoolActions#swap must implement this interface","title":"IUniswapV3SwapCallback"},{"location":"uniswap-v3-core/interfaces/callback/IUniswapV3SwapCallback/#uniswapv3swapcallback_1","text":"function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes data) external Called to msg.sender after executing a swap via IUniswapV3Pool#swap. In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped. Name Type Description amount0Delta int256 The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool. amount1Delta int256 The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool. data bytes Any data passed through by the caller via the IUniswapV3PoolActions#swap call","title":"uniswapV3SwapCallback"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/","text":"IUniswapV3PoolActions Contains pool methods that can be called by anyone initialize function initialize(uint160 sqrtPriceX96) external Sets the initial price for the pool Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value Name Type Description sqrtPriceX96 uint160 the initial sqrt price of the pool as a Q64.96 mint function mint(address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes data) external returns (uint256 amount0, uint256 amount1) Adds liquidity for the given recipient/tickLower/tickUpper position The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends on tickLower, tickUpper, the amount of liquidity, and the current price. Name Type Description recipient address The address for which the liquidity will be created tickLower int24 The lower tick of the position in which to add liquidity tickUpper int24 The upper tick of the position in which to add liquidity amount uint128 The amount of liquidity to mint data bytes Any data that should be passed through to the callback Name Type Description amount0 uint256 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback amount1 uint256 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback collect function collect(address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128 amount0, uint128 amount1) Collects tokens owed to a position Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity. Name Type Description recipient address The address which should receive the fees collected tickLower int24 The lower tick of the position for which to collect fees tickUpper int24 The upper tick of the position for which to collect fees amount0Requested uint128 How much token0 should be withdrawn from the fees owed amount1Requested uint128 How much token1 should be withdrawn from the fees owed Name Type Description amount0 uint128 The amount of fees collected in token0 amount1 uint128 The amount of fees collected in token1 burn function burn(int24 tickLower, int24 tickUpper, uint128 amount) external returns (uint256 amount0, uint256 amount1) Burn liquidity from the sender and account tokens owed for the liquidity to the position Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0 Fees must be collected separately via a call to #collect Name Type Description tickLower int24 The lower tick of the position for which to burn liquidity tickUpper int24 The upper tick of the position for which to burn liquidity amount uint128 How much liquidity to burn Name Type Description amount0 uint256 The amount of token0 sent to the recipient amount1 uint256 The amount of token1 sent to the recipient swap function swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) external returns (int256 amount0, int256 amount1) Swap token0 for token1, or token1 for token0 The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback Name Type Description recipient address The address to receive the output of the swap zeroForOne bool The direction of the swap, true for token0 to token1, false for token1 to token0 amountSpecified int256 The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative) sqrtPriceLimitX96 uint160 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap data bytes Any data to be passed through to the callback Name Type Description amount0 int256 The delta of the balance of token0 of the pool, exact when negative, minimum when positive amount1 int256 The delta of the balance of token1 of the pool, exact when negative, minimum when positive flash function flash(address recipient, uint256 amount0, uint256 amount1, bytes data) external Receive token0 and/or token1 and pay it back, plus a fee, in the callback The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount{0,1} and sending the donation amount(s) from the callback Name Type Description recipient address The address which will receive the token0 and token1 amounts amount0 uint256 The amount of token0 to send amount1 uint256 The amount of token1 to send data bytes Any data to be passed through to the callback increaseObservationCardinalityNext function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external Increase the maximum number of price and liquidity observations that this pool will store This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext. Name Type Description observationCardinalityNext uint16 The desired minimum number of observations for the pool to store IUniswapV3PoolActions Contains pool methods that can be called by anyone initialize function initialize(uint160 sqrtPriceX96) external Sets the initial price for the pool Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value Name Type Description sqrtPriceX96 uint160 the initial sqrt price of the pool as a Q64.96 mint function mint(address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes data) external returns (uint256 amount0, uint256 amount1) Adds liquidity for the given recipient/tickLower/tickUpper position The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends on tickLower, tickUpper, the amount of liquidity, and the current price. Name Type Description recipient address The address for which the liquidity will be created tickLower int24 The lower tick of the position in which to add liquidity tickUpper int24 The upper tick of the position in which to add liquidity amount uint128 The amount of liquidity to mint data bytes Any data that should be passed through to the callback Name Type Description amount0 uint256 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback amount1 uint256 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback collect function collect(address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128 amount0, uint128 amount1) Collects tokens owed to a position Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity. Name Type Description recipient address The address which should receive the fees collected tickLower int24 The lower tick of the position for which to collect fees tickUpper int24 The upper tick of the position for which to collect fees amount0Requested uint128 How much token0 should be withdrawn from the fees owed amount1Requested uint128 How much token1 should be withdrawn from the fees owed Name Type Description amount0 uint128 The amount of fees collected in token0 amount1 uint128 The amount of fees collected in token1 burn function burn(int24 tickLower, int24 tickUpper, uint128 amount) external returns (uint256 amount0, uint256 amount1) Burn liquidity from the sender and account tokens owed for the liquidity to the position Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0 Fees must be collected separately via a call to #collect Name Type Description tickLower int24 The lower tick of the position for which to burn liquidity tickUpper int24 The upper tick of the position for which to burn liquidity amount uint128 How much liquidity to burn Name Type Description amount0 uint256 The amount of token0 sent to the recipient amount1 uint256 The amount of token1 sent to the recipient swap function swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) external returns (int256 amount0, int256 amount1) Swap token0 for token1, or token1 for token0 The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback Name Type Description recipient address The address to receive the output of the swap zeroForOne bool The direction of the swap, true for token0 to token1, false for token1 to token0 amountSpecified int256 The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative) sqrtPriceLimitX96 uint160 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap data bytes Any data to be passed through to the callback Name Type Description amount0 int256 The delta of the balance of token0 of the pool, exact when negative, minimum when positive amount1 int256 The delta of the balance of token1 of the pool, exact when negative, minimum when positive flash function flash(address recipient, uint256 amount0, uint256 amount1, bytes data) external Receive token0 and/or token1 and pay it back, plus a fee, in the callback The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount{0,1} and sending the donation amount(s) from the callback Name Type Description recipient address The address which will receive the token0 and token1 amounts amount0 uint256 The amount of token0 to send amount1 uint256 The amount of token1 to send data bytes Any data to be passed through to the callback increaseObservationCardinalityNext function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external Increase the maximum number of price and liquidity observations that this pool will store This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext. Name Type Description observationCardinalityNext uint16 The desired minimum number of observations for the pool to store","title":"IUniswapV3PoolActions"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#iuniswapv3poolactions","text":"Contains pool methods that can be called by anyone","title":"IUniswapV3PoolActions"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#initialize","text":"function initialize(uint160 sqrtPriceX96) external Sets the initial price for the pool Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value Name Type Description sqrtPriceX96 uint160 the initial sqrt price of the pool as a Q64.96","title":"initialize"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#mint","text":"function mint(address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes data) external returns (uint256 amount0, uint256 amount1) Adds liquidity for the given recipient/tickLower/tickUpper position The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends on tickLower, tickUpper, the amount of liquidity, and the current price. Name Type Description recipient address The address for which the liquidity will be created tickLower int24 The lower tick of the position in which to add liquidity tickUpper int24 The upper tick of the position in which to add liquidity amount uint128 The amount of liquidity to mint data bytes Any data that should be passed through to the callback Name Type Description amount0 uint256 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback amount1 uint256 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback","title":"mint"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#collect","text":"function collect(address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128 amount0, uint128 amount1) Collects tokens owed to a position Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity. Name Type Description recipient address The address which should receive the fees collected tickLower int24 The lower tick of the position for which to collect fees tickUpper int24 The upper tick of the position for which to collect fees amount0Requested uint128 How much token0 should be withdrawn from the fees owed amount1Requested uint128 How much token1 should be withdrawn from the fees owed Name Type Description amount0 uint128 The amount of fees collected in token0 amount1 uint128 The amount of fees collected in token1","title":"collect"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#burn","text":"function burn(int24 tickLower, int24 tickUpper, uint128 amount) external returns (uint256 amount0, uint256 amount1) Burn liquidity from the sender and account tokens owed for the liquidity to the position Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0 Fees must be collected separately via a call to #collect Name Type Description tickLower int24 The lower tick of the position for which to burn liquidity tickUpper int24 The upper tick of the position for which to burn liquidity amount uint128 How much liquidity to burn Name Type Description amount0 uint256 The amount of token0 sent to the recipient amount1 uint256 The amount of token1 sent to the recipient","title":"burn"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#swap","text":"function swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) external returns (int256 amount0, int256 amount1) Swap token0 for token1, or token1 for token0 The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback Name Type Description recipient address The address to receive the output of the swap zeroForOne bool The direction of the swap, true for token0 to token1, false for token1 to token0 amountSpecified int256 The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative) sqrtPriceLimitX96 uint160 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap data bytes Any data to be passed through to the callback Name Type Description amount0 int256 The delta of the balance of token0 of the pool, exact when negative, minimum when positive amount1 int256 The delta of the balance of token1 of the pool, exact when negative, minimum when positive","title":"swap"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#flash","text":"function flash(address recipient, uint256 amount0, uint256 amount1, bytes data) external Receive token0 and/or token1 and pay it back, plus a fee, in the callback The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount{0,1} and sending the donation amount(s) from the callback Name Type Description recipient address The address which will receive the token0 and token1 amounts amount0 uint256 The amount of token0 to send amount1 uint256 The amount of token1 to send data bytes Any data to be passed through to the callback","title":"flash"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#increaseobservationcardinalitynext","text":"function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external Increase the maximum number of price and liquidity observations that this pool will store This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext. Name Type Description observationCardinalityNext uint16 The desired minimum number of observations for the pool to store","title":"increaseObservationCardinalityNext"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#iuniswapv3poolactions_1","text":"Contains pool methods that can be called by anyone","title":"IUniswapV3PoolActions"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#initialize_1","text":"function initialize(uint160 sqrtPriceX96) external Sets the initial price for the pool Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value Name Type Description sqrtPriceX96 uint160 the initial sqrt price of the pool as a Q64.96","title":"initialize"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#mint_1","text":"function mint(address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes data) external returns (uint256 amount0, uint256 amount1) Adds liquidity for the given recipient/tickLower/tickUpper position The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends on tickLower, tickUpper, the amount of liquidity, and the current price. Name Type Description recipient address The address for which the liquidity will be created tickLower int24 The lower tick of the position in which to add liquidity tickUpper int24 The upper tick of the position in which to add liquidity amount uint128 The amount of liquidity to mint data bytes Any data that should be passed through to the callback Name Type Description amount0 uint256 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback amount1 uint256 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback","title":"mint"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#collect_1","text":"function collect(address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128 amount0, uint128 amount1) Collects tokens owed to a position Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity. Name Type Description recipient address The address which should receive the fees collected tickLower int24 The lower tick of the position for which to collect fees tickUpper int24 The upper tick of the position for which to collect fees amount0Requested uint128 How much token0 should be withdrawn from the fees owed amount1Requested uint128 How much token1 should be withdrawn from the fees owed Name Type Description amount0 uint128 The amount of fees collected in token0 amount1 uint128 The amount of fees collected in token1","title":"collect"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#burn_1","text":"function burn(int24 tickLower, int24 tickUpper, uint128 amount) external returns (uint256 amount0, uint256 amount1) Burn liquidity from the sender and account tokens owed for the liquidity to the position Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0 Fees must be collected separately via a call to #collect Name Type Description tickLower int24 The lower tick of the position for which to burn liquidity tickUpper int24 The upper tick of the position for which to burn liquidity amount uint128 How much liquidity to burn Name Type Description amount0 uint256 The amount of token0 sent to the recipient amount1 uint256 The amount of token1 sent to the recipient","title":"burn"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#swap_1","text":"function swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) external returns (int256 amount0, int256 amount1) Swap token0 for token1, or token1 for token0 The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback Name Type Description recipient address The address to receive the output of the swap zeroForOne bool The direction of the swap, true for token0 to token1, false for token1 to token0 amountSpecified int256 The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative) sqrtPriceLimitX96 uint160 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap data bytes Any data to be passed through to the callback Name Type Description amount0 int256 The delta of the balance of token0 of the pool, exact when negative, minimum when positive amount1 int256 The delta of the balance of token1 of the pool, exact when negative, minimum when positive","title":"swap"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#flash_1","text":"function flash(address recipient, uint256 amount0, uint256 amount1, bytes data) external Receive token0 and/or token1 and pay it back, plus a fee, in the callback The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount{0,1} and sending the donation amount(s) from the callback Name Type Description recipient address The address which will receive the token0 and token1 amounts amount0 uint256 The amount of token0 to send amount1 uint256 The amount of token1 to send data bytes Any data to be passed through to the callback","title":"flash"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions/#increaseobservationcardinalitynext_1","text":"function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external Increase the maximum number of price and liquidity observations that this pool will store This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext. Name Type Description observationCardinalityNext uint16 The desired minimum number of observations for the pool to store","title":"increaseObservationCardinalityNext"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolDerivedState/","text":"IUniswapV3PoolDerivedState Contains view functions to provide information about the pool that is computed rather than stored on the blockchain. The functions here may have variable gas costs. observe function observe(uint32[] secondsAgos) external view returns (int56[] tickCumulatives, uint160[] secondsPerLiquidityCumulativeX128s) Returns the cumulative tick and liquidity as of each timestamp secondsAgo from the current block timestamp To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick, you must call it with secondsAgos = [3600, 0]. The time weighted average tick represents the geometric time weighted average price of the pool, in log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio. Name Type Description secondsAgos uint32[] From how long ago each cumulative tick and liquidity value should be returned Name Type Description tickCumulatives int56[] Cumulative tick values as of each secondsAgos from the current block timestamp secondsPerLiquidityCumulativeX128s uint160[] Cumulative seconds per liquidity-in-range value as of each secondsAgos from the current block timestamp snapshotCumulativesInside function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside) Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range Snapshots must only be compared to other snapshots, taken over a period for which a position existed. I.e., snapshots cannot be compared if a position is not held for the entire period between when the first snapshot is taken and the second snapshot is taken. Name Type Description tickLower int24 The lower tick of the range tickUpper int24 The upper tick of the range Name Type Description tickCumulativeInside int56 The snapshot of the tick accumulator for the range secondsPerLiquidityInsideX128 uint160 The snapshot of seconds per liquidity for the range secondsInside uint32 The snapshot of seconds per liquidity for the range IUniswapV3PoolDerivedState Contains view functions to provide information about the pool that is computed rather than stored on the blockchain. The functions here may have variable gas costs. observe function observe(uint32[] secondsAgos) external view returns (int56[] tickCumulatives, uint160[] secondsPerLiquidityCumulativeX128s) Returns the cumulative tick and liquidity as of each timestamp secondsAgo from the current block timestamp To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick, you must call it with secondsAgos = [3600, 0]. The time weighted average tick represents the geometric time weighted average price of the pool, in log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio. Name Type Description secondsAgos uint32[] From how long ago each cumulative tick and liquidity value should be returned Name Type Description tickCumulatives int56[] Cumulative tick values as of each secondsAgos from the current block timestamp secondsPerLiquidityCumulativeX128s uint160[] Cumulative seconds per liquidity-in-range value as of each secondsAgos from the current block timestamp snapshotCumulativesInside function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside) Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range Snapshots must only be compared to other snapshots, taken over a period for which a position existed. I.e., snapshots cannot be compared if a position is not held for the entire period between when the first snapshot is taken and the second snapshot is taken. Name Type Description tickLower int24 The lower tick of the range tickUpper int24 The upper tick of the range Name Type Description tickCumulativeInside int56 The snapshot of the tick accumulator for the range secondsPerLiquidityInsideX128 uint160 The snapshot of seconds per liquidity for the range secondsInside uint32 The snapshot of seconds per liquidity for the range","title":"IUniswapV3PoolDerivedState"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolDerivedState/#iuniswapv3poolderivedstate","text":"Contains view functions to provide information about the pool that is computed rather than stored on the blockchain. The functions here may have variable gas costs.","title":"IUniswapV3PoolDerivedState"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolDerivedState/#observe","text":"function observe(uint32[] secondsAgos) external view returns (int56[] tickCumulatives, uint160[] secondsPerLiquidityCumulativeX128s) Returns the cumulative tick and liquidity as of each timestamp secondsAgo from the current block timestamp To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick, you must call it with secondsAgos = [3600, 0]. The time weighted average tick represents the geometric time weighted average price of the pool, in log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio. Name Type Description secondsAgos uint32[] From how long ago each cumulative tick and liquidity value should be returned Name Type Description tickCumulatives int56[] Cumulative tick values as of each secondsAgos from the current block timestamp secondsPerLiquidityCumulativeX128s uint160[] Cumulative seconds per liquidity-in-range value as of each secondsAgos from the current block timestamp","title":"observe"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolDerivedState/#snapshotcumulativesinside","text":"function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside) Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range Snapshots must only be compared to other snapshots, taken over a period for which a position existed. I.e., snapshots cannot be compared if a position is not held for the entire period between when the first snapshot is taken and the second snapshot is taken. Name Type Description tickLower int24 The lower tick of the range tickUpper int24 The upper tick of the range Name Type Description tickCumulativeInside int56 The snapshot of the tick accumulator for the range secondsPerLiquidityInsideX128 uint160 The snapshot of seconds per liquidity for the range secondsInside uint32 The snapshot of seconds per liquidity for the range","title":"snapshotCumulativesInside"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolDerivedState/#iuniswapv3poolderivedstate_1","text":"Contains view functions to provide information about the pool that is computed rather than stored on the blockchain. The functions here may have variable gas costs.","title":"IUniswapV3PoolDerivedState"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolDerivedState/#observe_1","text":"function observe(uint32[] secondsAgos) external view returns (int56[] tickCumulatives, uint160[] secondsPerLiquidityCumulativeX128s) Returns the cumulative tick and liquidity as of each timestamp secondsAgo from the current block timestamp To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick, you must call it with secondsAgos = [3600, 0]. The time weighted average tick represents the geometric time weighted average price of the pool, in log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio. Name Type Description secondsAgos uint32[] From how long ago each cumulative tick and liquidity value should be returned Name Type Description tickCumulatives int56[] Cumulative tick values as of each secondsAgos from the current block timestamp secondsPerLiquidityCumulativeX128s uint160[] Cumulative seconds per liquidity-in-range value as of each secondsAgos from the current block timestamp","title":"observe"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolDerivedState/#snapshotcumulativesinside_1","text":"function snapshotCumulativesInside(int24 tickLower, int24 tickUpper) external view returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside) Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range Snapshots must only be compared to other snapshots, taken over a period for which a position existed. I.e., snapshots cannot be compared if a position is not held for the entire period between when the first snapshot is taken and the second snapshot is taken. Name Type Description tickLower int24 The lower tick of the range tickUpper int24 The upper tick of the range Name Type Description tickCumulativeInside int56 The snapshot of the tick accumulator for the range secondsPerLiquidityInsideX128 uint160 The snapshot of seconds per liquidity for the range secondsInside uint32 The snapshot of seconds per liquidity for the range","title":"snapshotCumulativesInside"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/","text":"IUniswapV3PoolEvents Contains all events emitted by the pool Initialize event Initialize(uint160 sqrtPriceX96, int24 tick) Emitted exactly once by a pool when #initialize is first called on the pool Mint/Burn/Swap cannot be emitted by the pool before Initialize Name Type Description sqrtPriceX96 uint160 The initial sqrt price of the pool, as a Q64.96 tick int24 The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool Mint event Mint(address sender, address owner, int24 tickLower, int24 tickUpper, uint128 amount, uint256 amount0, uint256 amount1) Emitted when liquidity is minted for a given position Name Type Description sender address The address that minted the liquidity owner address The owner of the position and recipient of any minted liquidity tickLower int24 The lower tick of the position tickUpper int24 The upper tick of the position amount uint128 The amount of liquidity minted to the position range amount0 uint256 How much token0 was required for the minted liquidity amount1 uint256 How much token1 was required for the minted liquidity Collect event Collect(address owner, address recipient, int24 tickLower, int24 tickUpper, uint128 amount0, uint128 amount1) Emitted when fees are collected by the owner of a position Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees Name Type Description owner address The owner of the position for which fees are collected recipient address tickLower int24 The lower tick of the position tickUpper int24 The upper tick of the position amount0 uint128 The amount of token0 fees collected amount1 uint128 The amount of token1 fees collected Burn event Burn(address owner, int24 tickLower, int24 tickUpper, uint128 amount, uint256 amount0, uint256 amount1) Emitted when a position's liquidity is removed Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect Name Type Description owner address The owner of the position for which liquidity is removed tickLower int24 The lower tick of the position tickUpper int24 The upper tick of the position amount uint128 The amount of liquidity to remove amount0 uint256 The amount of token0 withdrawn amount1 uint256 The amount of token1 withdrawn Swap event Swap(address sender, address recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick) Emitted by the pool for any swaps between token0 and token1 Name Type Description sender address The address that initiated the swap call, and that received the callback recipient address The address that received the output of the swap amount0 int256 The delta of the token0 balance of the pool amount1 int256 The delta of the token1 balance of the pool sqrtPriceX96 uint160 The sqrt(price) of the pool after the swap, as a Q64.96 liquidity uint128 The liquidity of the pool after the swap tick int24 The log base 1.0001 of price of the pool after the swap Flash event Flash(address sender, address recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1) Emitted by the pool for any flashes of token0/token1 Name Type Description sender address The address that initiated the swap call, and that received the callback recipient address The address that received the tokens from flash amount0 uint256 The amount of token0 that was flashed amount1 uint256 The amount of token1 that was flashed paid0 uint256 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee paid1 uint256 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee IncreaseObservationCardinalityNext event IncreaseObservationCardinalityNext(uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew) Emitted by the pool for increases to the number of observations that can be stored observationCardinalityNext is not the observation cardinality until an observation is written at the index just before a mint/swap/burn. Name Type Description observationCardinalityNextOld uint16 The previous value of the next observation cardinality observationCardinalityNextNew uint16 The updated value of the next observation cardinality SetFeeProtocol event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New) Emitted when the protocol fee is changed by the pool Name Type Description feeProtocol0Old uint8 The previous value of the token0 protocol fee feeProtocol1Old uint8 The previous value of the token1 protocol fee feeProtocol0New uint8 The updated value of the token0 protocol fee feeProtocol1New uint8 The updated value of the token1 protocol fee CollectProtocol event CollectProtocol(address sender, address recipient, uint128 amount0, uint128 amount1) Emitted when the collected protocol fees are withdrawn by the factory owner Name Type Description sender address The address that collects the protocol fees recipient address The address that receives the collected protocol fees amount0 uint128 The amount of token0 protocol fees that is withdrawn amount1 uint128 IUniswapV3PoolEvents Contains all events emitted by the pool Initialize event Initialize(uint160 sqrtPriceX96, int24 tick) Emitted exactly once by a pool when #initialize is first called on the pool Mint/Burn/Swap cannot be emitted by the pool before Initialize Name Type Description sqrtPriceX96 uint160 The initial sqrt price of the pool, as a Q64.96 tick int24 The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool Mint event Mint(address sender, address owner, int24 tickLower, int24 tickUpper, uint128 amount, uint256 amount0, uint256 amount1) Emitted when liquidity is minted for a given position Name Type Description sender address The address that minted the liquidity owner address The owner of the position and recipient of any minted liquidity tickLower int24 The lower tick of the position tickUpper int24 The upper tick of the position amount uint128 The amount of liquidity minted to the position range amount0 uint256 How much token0 was required for the minted liquidity amount1 uint256 How much token1 was required for the minted liquidity Collect event Collect(address owner, address recipient, int24 tickLower, int24 tickUpper, uint128 amount0, uint128 amount1) Emitted when fees are collected by the owner of a position Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees Name Type Description owner address The owner of the position for which fees are collected recipient address tickLower int24 The lower tick of the position tickUpper int24 The upper tick of the position amount0 uint128 The amount of token0 fees collected amount1 uint128 The amount of token1 fees collected Burn event Burn(address owner, int24 tickLower, int24 tickUpper, uint128 amount, uint256 amount0, uint256 amount1) Emitted when a position's liquidity is removed Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect Name Type Description owner address The owner of the position for which liquidity is removed tickLower int24 The lower tick of the position tickUpper int24 The upper tick of the position amount uint128 The amount of liquidity to remove amount0 uint256 The amount of token0 withdrawn amount1 uint256 The amount of token1 withdrawn Swap event Swap(address sender, address recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick) Emitted by the pool for any swaps between token0 and token1 Name Type Description sender address The address that initiated the swap call, and that received the callback recipient address The address that received the output of the swap amount0 int256 The delta of the token0 balance of the pool amount1 int256 The delta of the token1 balance of the pool sqrtPriceX96 uint160 The sqrt(price) of the pool after the swap, as a Q64.96 liquidity uint128 The liquidity of the pool after the swap tick int24 The log base 1.0001 of price of the pool after the swap Flash event Flash(address sender, address recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1) Emitted by the pool for any flashes of token0/token1 Name Type Description sender address The address that initiated the swap call, and that received the callback recipient address The address that received the tokens from flash amount0 uint256 The amount of token0 that was flashed amount1 uint256 The amount of token1 that was flashed paid0 uint256 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee paid1 uint256 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee IncreaseObservationCardinalityNext event IncreaseObservationCardinalityNext(uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew) Emitted by the pool for increases to the number of observations that can be stored observationCardinalityNext is not the observation cardinality until an observation is written at the index just before a mint/swap/burn. Name Type Description observationCardinalityNextOld uint16 The previous value of the next observation cardinality observationCardinalityNextNew uint16 The updated value of the next observation cardinality SetFeeProtocol event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New) Emitted when the protocol fee is changed by the pool Name Type Description feeProtocol0Old uint8 The previous value of the token0 protocol fee feeProtocol1Old uint8 The previous value of the token1 protocol fee feeProtocol0New uint8 The updated value of the token0 protocol fee feeProtocol1New uint8 The updated value of the token1 protocol fee CollectProtocol event CollectProtocol(address sender, address recipient, uint128 amount0, uint128 amount1) Emitted when the collected protocol fees are withdrawn by the factory owner Name Type Description sender address The address that collects the protocol fees recipient address The address that receives the collected protocol fees amount0 uint128 The amount of token0 protocol fees that is withdrawn amount1 uint128","title":"IUniswapV3PoolEvents"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#iuniswapv3poolevents","text":"Contains all events emitted by the pool","title":"IUniswapV3PoolEvents"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#initialize","text":"event Initialize(uint160 sqrtPriceX96, int24 tick) Emitted exactly once by a pool when #initialize is first called on the pool Mint/Burn/Swap cannot be emitted by the pool before Initialize Name Type Description sqrtPriceX96 uint160 The initial sqrt price of the pool, as a Q64.96 tick int24 The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool","title":"Initialize"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#mint","text":"event Mint(address sender, address owner, int24 tickLower, int24 tickUpper, uint128 amount, uint256 amount0, uint256 amount1) Emitted when liquidity is minted for a given position Name Type Description sender address The address that minted the liquidity owner address The owner of the position and recipient of any minted liquidity tickLower int24 The lower tick of the position tickUpper int24 The upper tick of the position amount uint128 The amount of liquidity minted to the position range amount0 uint256 How much token0 was required for the minted liquidity amount1 uint256 How much token1 was required for the minted liquidity","title":"Mint"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#collect","text":"event Collect(address owner, address recipient, int24 tickLower, int24 tickUpper, uint128 amount0, uint128 amount1) Emitted when fees are collected by the owner of a position Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees Name Type Description owner address The owner of the position for which fees are collected recipient address tickLower int24 The lower tick of the position tickUpper int24 The upper tick of the position amount0 uint128 The amount of token0 fees collected amount1 uint128 The amount of token1 fees collected","title":"Collect"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#burn","text":"event Burn(address owner, int24 tickLower, int24 tickUpper, uint128 amount, uint256 amount0, uint256 amount1) Emitted when a position's liquidity is removed Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect Name Type Description owner address The owner of the position for which liquidity is removed tickLower int24 The lower tick of the position tickUpper int24 The upper tick of the position amount uint128 The amount of liquidity to remove amount0 uint256 The amount of token0 withdrawn amount1 uint256 The amount of token1 withdrawn","title":"Burn"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#swap","text":"event Swap(address sender, address recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick) Emitted by the pool for any swaps between token0 and token1 Name Type Description sender address The address that initiated the swap call, and that received the callback recipient address The address that received the output of the swap amount0 int256 The delta of the token0 balance of the pool amount1 int256 The delta of the token1 balance of the pool sqrtPriceX96 uint160 The sqrt(price) of the pool after the swap, as a Q64.96 liquidity uint128 The liquidity of the pool after the swap tick int24 The log base 1.0001 of price of the pool after the swap","title":"Swap"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#flash","text":"event Flash(address sender, address recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1) Emitted by the pool for any flashes of token0/token1 Name Type Description sender address The address that initiated the swap call, and that received the callback recipient address The address that received the tokens from flash amount0 uint256 The amount of token0 that was flashed amount1 uint256 The amount of token1 that was flashed paid0 uint256 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee paid1 uint256 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee","title":"Flash"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#increaseobservationcardinalitynext","text":"event IncreaseObservationCardinalityNext(uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew) Emitted by the pool for increases to the number of observations that can be stored observationCardinalityNext is not the observation cardinality until an observation is written at the index just before a mint/swap/burn. Name Type Description observationCardinalityNextOld uint16 The previous value of the next observation cardinality observationCardinalityNextNew uint16 The updated value of the next observation cardinality","title":"IncreaseObservationCardinalityNext"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#setfeeprotocol","text":"event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New) Emitted when the protocol fee is changed by the pool Name Type Description feeProtocol0Old uint8 The previous value of the token0 protocol fee feeProtocol1Old uint8 The previous value of the token1 protocol fee feeProtocol0New uint8 The updated value of the token0 protocol fee feeProtocol1New uint8 The updated value of the token1 protocol fee","title":"SetFeeProtocol"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#collectprotocol","text":"event CollectProtocol(address sender, address recipient, uint128 amount0, uint128 amount1) Emitted when the collected protocol fees are withdrawn by the factory owner Name Type Description sender address The address that collects the protocol fees recipient address The address that receives the collected protocol fees amount0 uint128 The amount of token0 protocol fees that is withdrawn amount1 uint128","title":"CollectProtocol"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#iuniswapv3poolevents_1","text":"Contains all events emitted by the pool","title":"IUniswapV3PoolEvents"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#initialize_1","text":"event Initialize(uint160 sqrtPriceX96, int24 tick) Emitted exactly once by a pool when #initialize is first called on the pool Mint/Burn/Swap cannot be emitted by the pool before Initialize Name Type Description sqrtPriceX96 uint160 The initial sqrt price of the pool, as a Q64.96 tick int24 The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool","title":"Initialize"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#mint_1","text":"event Mint(address sender, address owner, int24 tickLower, int24 tickUpper, uint128 amount, uint256 amount0, uint256 amount1) Emitted when liquidity is minted for a given position Name Type Description sender address The address that minted the liquidity owner address The owner of the position and recipient of any minted liquidity tickLower int24 The lower tick of the position tickUpper int24 The upper tick of the position amount uint128 The amount of liquidity minted to the position range amount0 uint256 How much token0 was required for the minted liquidity amount1 uint256 How much token1 was required for the minted liquidity","title":"Mint"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#collect_1","text":"event Collect(address owner, address recipient, int24 tickLower, int24 tickUpper, uint128 amount0, uint128 amount1) Emitted when fees are collected by the owner of a position Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees Name Type Description owner address The owner of the position for which fees are collected recipient address tickLower int24 The lower tick of the position tickUpper int24 The upper tick of the position amount0 uint128 The amount of token0 fees collected amount1 uint128 The amount of token1 fees collected","title":"Collect"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#burn_1","text":"event Burn(address owner, int24 tickLower, int24 tickUpper, uint128 amount, uint256 amount0, uint256 amount1) Emitted when a position's liquidity is removed Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect Name Type Description owner address The owner of the position for which liquidity is removed tickLower int24 The lower tick of the position tickUpper int24 The upper tick of the position amount uint128 The amount of liquidity to remove amount0 uint256 The amount of token0 withdrawn amount1 uint256 The amount of token1 withdrawn","title":"Burn"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#swap_1","text":"event Swap(address sender, address recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick) Emitted by the pool for any swaps between token0 and token1 Name Type Description sender address The address that initiated the swap call, and that received the callback recipient address The address that received the output of the swap amount0 int256 The delta of the token0 balance of the pool amount1 int256 The delta of the token1 balance of the pool sqrtPriceX96 uint160 The sqrt(price) of the pool after the swap, as a Q64.96 liquidity uint128 The liquidity of the pool after the swap tick int24 The log base 1.0001 of price of the pool after the swap","title":"Swap"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#flash_1","text":"event Flash(address sender, address recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1) Emitted by the pool for any flashes of token0/token1 Name Type Description sender address The address that initiated the swap call, and that received the callback recipient address The address that received the tokens from flash amount0 uint256 The amount of token0 that was flashed amount1 uint256 The amount of token1 that was flashed paid0 uint256 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee paid1 uint256 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee","title":"Flash"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#increaseobservationcardinalitynext_1","text":"event IncreaseObservationCardinalityNext(uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew) Emitted by the pool for increases to the number of observations that can be stored observationCardinalityNext is not the observation cardinality until an observation is written at the index just before a mint/swap/burn. Name Type Description observationCardinalityNextOld uint16 The previous value of the next observation cardinality observationCardinalityNextNew uint16 The updated value of the next observation cardinality","title":"IncreaseObservationCardinalityNext"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#setfeeprotocol_1","text":"event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New) Emitted when the protocol fee is changed by the pool Name Type Description feeProtocol0Old uint8 The previous value of the token0 protocol fee feeProtocol1Old uint8 The previous value of the token1 protocol fee feeProtocol0New uint8 The updated value of the token0 protocol fee feeProtocol1New uint8 The updated value of the token1 protocol fee","title":"SetFeeProtocol"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents/#collectprotocol_1","text":"event CollectProtocol(address sender, address recipient, uint128 amount0, uint128 amount1) Emitted when the collected protocol fees are withdrawn by the factory owner Name Type Description sender address The address that collects the protocol fees recipient address The address that receives the collected protocol fees amount0 uint128 The amount of token0 protocol fees that is withdrawn amount1 uint128","title":"CollectProtocol"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/","text":"IUniswapV3PoolImmutables These parameters are fixed for a pool forever, i.e., the methods will always return the same values factory function factory() external view returns (address) The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface Name Type Description [0] address The contract address token0 function token0() external view returns (address) The first of the two tokens of the pool, sorted by address Name Type Description [0] address The token contract address token1 function token1() external view returns (address) The second of the two tokens of the pool, sorted by address Name Type Description [0] address The token contract address fee function fee() external view returns (uint24) The pool's fee in hundredths of a bip, i.e. 1e-6 Name Type Description [0] uint24 The fee tickSpacing function tickSpacing() external view returns (int24) The pool tick spacing Ticks can only be used at multiples of this value, minimum of 1 and always positive e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ... This value is an int24 to avoid casting even though it is always positive. Name Type Description [0] int24 The tick spacing maxLiquidityPerTick function maxLiquidityPerTick() external view returns (uint128) The maximum amount of position liquidity that can use any tick in the range This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool Name Type Description [0] uint128 The max amount of liquidity per tick IUniswapV3PoolImmutables These parameters are fixed for a pool forever, i.e., the methods will always return the same values factory function factory() external view returns (address) The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface Name Type Description [0] address The contract address token0 function token0() external view returns (address) The first of the two tokens of the pool, sorted by address Name Type Description [0] address The token contract address token1 function token1() external view returns (address) The second of the two tokens of the pool, sorted by address Name Type Description [0] address The token contract address fee function fee() external view returns (uint24) The pool's fee in hundredths of a bip, i.e. 1e-6 Name Type Description [0] uint24 The fee tickSpacing function tickSpacing() external view returns (int24) The pool tick spacing Ticks can only be used at multiples of this value, minimum of 1 and always positive e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ... This value is an int24 to avoid casting even though it is always positive. Name Type Description [0] int24 The tick spacing maxLiquidityPerTick function maxLiquidityPerTick() external view returns (uint128) The maximum amount of position liquidity that can use any tick in the range This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool Name Type Description [0] uint128 The max amount of liquidity per tick","title":"IUniswapV3PoolImmutables"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/#iuniswapv3poolimmutables","text":"These parameters are fixed for a pool forever, i.e., the methods will always return the same values","title":"IUniswapV3PoolImmutables"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/#factory","text":"function factory() external view returns (address) The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface Name Type Description [0] address The contract address","title":"factory"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/#token0","text":"function token0() external view returns (address) The first of the two tokens of the pool, sorted by address Name Type Description [0] address The token contract address","title":"token0"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/#token1","text":"function token1() external view returns (address) The second of the two tokens of the pool, sorted by address Name Type Description [0] address The token contract address","title":"token1"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/#fee","text":"function fee() external view returns (uint24) The pool's fee in hundredths of a bip, i.e. 1e-6 Name Type Description [0] uint24 The fee","title":"fee"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/#tickspacing","text":"function tickSpacing() external view returns (int24) The pool tick spacing Ticks can only be used at multiples of this value, minimum of 1 and always positive e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ... This value is an int24 to avoid casting even though it is always positive. Name Type Description [0] int24 The tick spacing","title":"tickSpacing"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/#maxliquiditypertick","text":"function maxLiquidityPerTick() external view returns (uint128) The maximum amount of position liquidity that can use any tick in the range This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool Name Type Description [0] uint128 The max amount of liquidity per tick","title":"maxLiquidityPerTick"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/#iuniswapv3poolimmutables_1","text":"These parameters are fixed for a pool forever, i.e., the methods will always return the same values","title":"IUniswapV3PoolImmutables"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/#factory_1","text":"function factory() external view returns (address) The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface Name Type Description [0] address The contract address","title":"factory"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/#token0_1","text":"function token0() external view returns (address) The first of the two tokens of the pool, sorted by address Name Type Description [0] address The token contract address","title":"token0"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/#token1_1","text":"function token1() external view returns (address) The second of the two tokens of the pool, sorted by address Name Type Description [0] address The token contract address","title":"token1"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/#fee_1","text":"function fee() external view returns (uint24) The pool's fee in hundredths of a bip, i.e. 1e-6 Name Type Description [0] uint24 The fee","title":"fee"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/#tickspacing_1","text":"function tickSpacing() external view returns (int24) The pool tick spacing Ticks can only be used at multiples of this value, minimum of 1 and always positive e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ... This value is an int24 to avoid casting even though it is always positive. Name Type Description [0] int24 The tick spacing","title":"tickSpacing"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables/#maxliquiditypertick_1","text":"function maxLiquidityPerTick() external view returns (uint128) The maximum amount of position liquidity that can use any tick in the range This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool Name Type Description [0] uint128 The max amount of liquidity per tick","title":"maxLiquidityPerTick"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolOwnerActions/","text":"IUniswapV3PoolOwnerActions Contains pool methods that may only be called by the factory owner setFeeProtocol function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external Set the denominator of the protocol's % share of the fees Name Type Description feeProtocol0 uint8 new protocol fee for token0 of the pool feeProtocol1 uint8 new protocol fee for token1 of the pool collectProtocol function collectProtocol(address recipient, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128 amount0, uint128 amount1) Collect the protocol fee accrued to the pool Name Type Description recipient address The address to which collected protocol fees should be sent amount0Requested uint128 The maximum amount of token0 to send, can be 0 to collect fees in only token1 amount1Requested uint128 The maximum amount of token1 to send, can be 0 to collect fees in only token0 Name Type Description amount0 uint128 The protocol fee collected in token0 amount1 uint128 The protocol fee collected in token1 IUniswapV3PoolOwnerActions Contains pool methods that may only be called by the factory owner setFeeProtocol function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external Set the denominator of the protocol's % share of the fees Name Type Description feeProtocol0 uint8 new protocol fee for token0 of the pool feeProtocol1 uint8 new protocol fee for token1 of the pool collectProtocol function collectProtocol(address recipient, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128 amount0, uint128 amount1) Collect the protocol fee accrued to the pool Name Type Description recipient address The address to which collected protocol fees should be sent amount0Requested uint128 The maximum amount of token0 to send, can be 0 to collect fees in only token1 amount1Requested uint128 The maximum amount of token1 to send, can be 0 to collect fees in only token0 Name Type Description amount0 uint128 The protocol fee collected in token0 amount1 uint128 The protocol fee collected in token1","title":"IUniswapV3PoolOwnerActions"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolOwnerActions/#iuniswapv3poolowneractions","text":"Contains pool methods that may only be called by the factory owner","title":"IUniswapV3PoolOwnerActions"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolOwnerActions/#setfeeprotocol","text":"function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external Set the denominator of the protocol's % share of the fees Name Type Description feeProtocol0 uint8 new protocol fee for token0 of the pool feeProtocol1 uint8 new protocol fee for token1 of the pool","title":"setFeeProtocol"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolOwnerActions/#collectprotocol","text":"function collectProtocol(address recipient, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128 amount0, uint128 amount1) Collect the protocol fee accrued to the pool Name Type Description recipient address The address to which collected protocol fees should be sent amount0Requested uint128 The maximum amount of token0 to send, can be 0 to collect fees in only token1 amount1Requested uint128 The maximum amount of token1 to send, can be 0 to collect fees in only token0 Name Type Description amount0 uint128 The protocol fee collected in token0 amount1 uint128 The protocol fee collected in token1","title":"collectProtocol"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolOwnerActions/#iuniswapv3poolowneractions_1","text":"Contains pool methods that may only be called by the factory owner","title":"IUniswapV3PoolOwnerActions"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolOwnerActions/#setfeeprotocol_1","text":"function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external Set the denominator of the protocol's % share of the fees Name Type Description feeProtocol0 uint8 new protocol fee for token0 of the pool feeProtocol1 uint8 new protocol fee for token1 of the pool","title":"setFeeProtocol"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolOwnerActions/#collectprotocol_1","text":"function collectProtocol(address recipient, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128 amount0, uint128 amount1) Collect the protocol fee accrued to the pool Name Type Description recipient address The address to which collected protocol fees should be sent amount0Requested uint128 The maximum amount of token0 to send, can be 0 to collect fees in only token1 amount1Requested uint128 The maximum amount of token1 to send, can be 0 to collect fees in only token0 Name Type Description amount0 uint128 The protocol fee collected in token0 amount1 uint128 The protocol fee collected in token1","title":"collectProtocol"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/","text":"IUniswapV3PoolState These methods compose the pool's state, and can change with any frequency including multiple times per transaction slot0 function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked) The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally. Name Type Description sqrtPriceX96 uint160 The current price of the pool as a sqrt(token1/token0) Q64.96 value tick The current tick of the pool, i.e. according to the last tick transition that was run. This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick boundary. observationIndex The index of the last oracle observation that was written, observationCardinality The current maximum number of observations stored in the pool, observationCardinalityNext The next maximum number of observations, to be updated when the observation. feeProtocol The protocol fee for both tokens of the pool. Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0 is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee. unlocked Whether the pool is currently locked to reentrancy tick int24 observationIndex uint16 observationCardinality uint16 observationCardinalityNext uint16 feeProtocol uint8 unlocked bool feeGrowthGlobal0X128 function feeGrowthGlobal0X128() external view returns (uint256) The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool This value can overflow the uint256 feeGrowthGlobal1X128 function feeGrowthGlobal1X128() external view returns (uint256) The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool This value can overflow the uint256 protocolFees function protocolFees() external view returns (uint128 token0, uint128 token1) The amounts of token0 and token1 that are owed to the protocol Protocol fees will never exceed uint128 max in either token liquidity function liquidity() external view returns (uint128) The currently in range liquidity available to the pool This value has no relationship to the total liquidity across all ticks ticks function ticks(int24 tick) external view returns (uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized) Look up information about a specific tick in the pool Name Type Description tick int24 The tick to look up Name Type Description liquidityGross uint128 the total amount of position liquidity that uses the pool either as tick lower or tick upper, liquidityNet how much liquidity changes when the pool price crosses the tick, feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0, feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1, tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick, secondsOutside the seconds spent on the other side of the tick from the current tick, initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false. Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0. In addition, these values are only relative and must be used only in comparison to previous snapshots for a specific position. liquidityNet int128 feeGrowthOutside0X128 uint256 feeGrowthOutside1X128 uint256 tickCumulativeOutside int56 secondsPerLiquidityOutsideX128 uint160 secondsOutside uint32 initialized bool tickBitmap function tickBitmap(int16 wordPosition) external view returns (uint256) Returns 256 packed tick initialized boolean values. See TickBitmap for more information positions function positions(bytes32 key) external view returns (uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1) Returns the information about a position by the position's key Name Type Description key bytes32 The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper Name Type Description _liquidity uint128 The amount of liquidity in the position, Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke, Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke, Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke, Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke feeGrowthInside0LastX128 uint256 feeGrowthInside1LastX128 uint256 tokensOwed0 uint128 tokensOwed1 uint128 observations function observations(uint256 index) external view returns (uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized) Returns data about a specific observation index You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array. Name Type Description index uint256 The element of the observations array to fetch Name Type Description blockTimestamp uint32 The timestamp of the observation, Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp, Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp, Returns initialized whether the observation has been initialized and the values are safe to use tickCumulative int56 secondsPerLiquidityCumulativeX128 uint160 initialized bool IUniswapV3PoolState These methods compose the pool's state, and can change with any frequency including multiple times per transaction slot0 function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked) The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally. Name Type Description sqrtPriceX96 uint160 The current price of the pool as a sqrt(token1/token0) Q64.96 value tick The current tick of the pool, i.e. according to the last tick transition that was run. This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick boundary. observationIndex The index of the last oracle observation that was written, observationCardinality The current maximum number of observations stored in the pool, observationCardinalityNext The next maximum number of observations, to be updated when the observation. feeProtocol The protocol fee for both tokens of the pool. Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0 is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee. unlocked Whether the pool is currently locked to reentrancy tick int24 observationIndex uint16 observationCardinality uint16 observationCardinalityNext uint16 feeProtocol uint8 unlocked bool feeGrowthGlobal0X128 function feeGrowthGlobal0X128() external view returns (uint256) The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool This value can overflow the uint256 feeGrowthGlobal1X128 function feeGrowthGlobal1X128() external view returns (uint256) The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool This value can overflow the uint256 protocolFees function protocolFees() external view returns (uint128 token0, uint128 token1) The amounts of token0 and token1 that are owed to the protocol Protocol fees will never exceed uint128 max in either token liquidity function liquidity() external view returns (uint128) The currently in range liquidity available to the pool This value has no relationship to the total liquidity across all ticks ticks function ticks(int24 tick) external view returns (uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized) Look up information about a specific tick in the pool Name Type Description tick int24 The tick to look up Name Type Description liquidityGross uint128 the total amount of position liquidity that uses the pool either as tick lower or tick upper, liquidityNet how much liquidity changes when the pool price crosses the tick, feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0, feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1, tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick, secondsOutside the seconds spent on the other side of the tick from the current tick, initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false. Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0. In addition, these values are only relative and must be used only in comparison to previous snapshots for a specific position. liquidityNet int128 feeGrowthOutside0X128 uint256 feeGrowthOutside1X128 uint256 tickCumulativeOutside int56 secondsPerLiquidityOutsideX128 uint160 secondsOutside uint32 initialized bool tickBitmap function tickBitmap(int16 wordPosition) external view returns (uint256) Returns 256 packed tick initialized boolean values. See TickBitmap for more information positions function positions(bytes32 key) external view returns (uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1) Returns the information about a position by the position's key Name Type Description key bytes32 The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper Name Type Description _liquidity uint128 The amount of liquidity in the position, Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke, Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke, Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke, Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke feeGrowthInside0LastX128 uint256 feeGrowthInside1LastX128 uint256 tokensOwed0 uint128 tokensOwed1 uint128 observations function observations(uint256 index) external view returns (uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized) Returns data about a specific observation index You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array. Name Type Description index uint256 The element of the observations array to fetch Name Type Description blockTimestamp uint32 The timestamp of the observation, Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp, Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp, Returns initialized whether the observation has been initialized and the values are safe to use tickCumulative int56 secondsPerLiquidityCumulativeX128 uint160 initialized bool","title":"IUniswapV3PoolState"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#iuniswapv3poolstate","text":"These methods compose the pool's state, and can change with any frequency including multiple times per transaction","title":"IUniswapV3PoolState"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#slot0","text":"function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked) The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally. Name Type Description sqrtPriceX96 uint160 The current price of the pool as a sqrt(token1/token0) Q64.96 value tick The current tick of the pool, i.e. according to the last tick transition that was run. This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick boundary. observationIndex The index of the last oracle observation that was written, observationCardinality The current maximum number of observations stored in the pool, observationCardinalityNext The next maximum number of observations, to be updated when the observation. feeProtocol The protocol fee for both tokens of the pool. Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0 is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee. unlocked Whether the pool is currently locked to reentrancy tick int24 observationIndex uint16 observationCardinality uint16 observationCardinalityNext uint16 feeProtocol uint8 unlocked bool","title":"slot0"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#feegrowthglobal0x128","text":"function feeGrowthGlobal0X128() external view returns (uint256) The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool This value can overflow the uint256","title":"feeGrowthGlobal0X128"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#feegrowthglobal1x128","text":"function feeGrowthGlobal1X128() external view returns (uint256) The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool This value can overflow the uint256","title":"feeGrowthGlobal1X128"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#protocolfees","text":"function protocolFees() external view returns (uint128 token0, uint128 token1) The amounts of token0 and token1 that are owed to the protocol Protocol fees will never exceed uint128 max in either token","title":"protocolFees"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#liquidity","text":"function liquidity() external view returns (uint128) The currently in range liquidity available to the pool This value has no relationship to the total liquidity across all ticks","title":"liquidity"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#ticks","text":"function ticks(int24 tick) external view returns (uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized) Look up information about a specific tick in the pool Name Type Description tick int24 The tick to look up Name Type Description liquidityGross uint128 the total amount of position liquidity that uses the pool either as tick lower or tick upper, liquidityNet how much liquidity changes when the pool price crosses the tick, feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0, feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1, tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick, secondsOutside the seconds spent on the other side of the tick from the current tick, initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false. Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0. In addition, these values are only relative and must be used only in comparison to previous snapshots for a specific position. liquidityNet int128 feeGrowthOutside0X128 uint256 feeGrowthOutside1X128 uint256 tickCumulativeOutside int56 secondsPerLiquidityOutsideX128 uint160 secondsOutside uint32 initialized bool","title":"ticks"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#tickbitmap","text":"function tickBitmap(int16 wordPosition) external view returns (uint256) Returns 256 packed tick initialized boolean values. See TickBitmap for more information","title":"tickBitmap"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#positions","text":"function positions(bytes32 key) external view returns (uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1) Returns the information about a position by the position's key Name Type Description key bytes32 The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper Name Type Description _liquidity uint128 The amount of liquidity in the position, Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke, Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke, Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke, Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke feeGrowthInside0LastX128 uint256 feeGrowthInside1LastX128 uint256 tokensOwed0 uint128 tokensOwed1 uint128","title":"positions"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#observations","text":"function observations(uint256 index) external view returns (uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized) Returns data about a specific observation index You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array. Name Type Description index uint256 The element of the observations array to fetch Name Type Description blockTimestamp uint32 The timestamp of the observation, Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp, Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp, Returns initialized whether the observation has been initialized and the values are safe to use tickCumulative int56 secondsPerLiquidityCumulativeX128 uint160 initialized bool","title":"observations"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#iuniswapv3poolstate_1","text":"These methods compose the pool's state, and can change with any frequency including multiple times per transaction","title":"IUniswapV3PoolState"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#slot0_1","text":"function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked) The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally. Name Type Description sqrtPriceX96 uint160 The current price of the pool as a sqrt(token1/token0) Q64.96 value tick The current tick of the pool, i.e. according to the last tick transition that was run. This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick boundary. observationIndex The index of the last oracle observation that was written, observationCardinality The current maximum number of observations stored in the pool, observationCardinalityNext The next maximum number of observations, to be updated when the observation. feeProtocol The protocol fee for both tokens of the pool. Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0 is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee. unlocked Whether the pool is currently locked to reentrancy tick int24 observationIndex uint16 observationCardinality uint16 observationCardinalityNext uint16 feeProtocol uint8 unlocked bool","title":"slot0"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#feegrowthglobal0x128_1","text":"function feeGrowthGlobal0X128() external view returns (uint256) The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool This value can overflow the uint256","title":"feeGrowthGlobal0X128"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#feegrowthglobal1x128_1","text":"function feeGrowthGlobal1X128() external view returns (uint256) The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool This value can overflow the uint256","title":"feeGrowthGlobal1X128"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#protocolfees_1","text":"function protocolFees() external view returns (uint128 token0, uint128 token1) The amounts of token0 and token1 that are owed to the protocol Protocol fees will never exceed uint128 max in either token","title":"protocolFees"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#liquidity_1","text":"function liquidity() external view returns (uint128) The currently in range liquidity available to the pool This value has no relationship to the total liquidity across all ticks","title":"liquidity"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#ticks_1","text":"function ticks(int24 tick) external view returns (uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized) Look up information about a specific tick in the pool Name Type Description tick int24 The tick to look up Name Type Description liquidityGross uint128 the total amount of position liquidity that uses the pool either as tick lower or tick upper, liquidityNet how much liquidity changes when the pool price crosses the tick, feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0, feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1, tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick, secondsOutside the seconds spent on the other side of the tick from the current tick, initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false. Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0. In addition, these values are only relative and must be used only in comparison to previous snapshots for a specific position. liquidityNet int128 feeGrowthOutside0X128 uint256 feeGrowthOutside1X128 uint256 tickCumulativeOutside int56 secondsPerLiquidityOutsideX128 uint160 secondsOutside uint32 initialized bool","title":"ticks"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#tickbitmap_1","text":"function tickBitmap(int16 wordPosition) external view returns (uint256) Returns 256 packed tick initialized boolean values. See TickBitmap for more information","title":"tickBitmap"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#positions_1","text":"function positions(bytes32 key) external view returns (uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1) Returns the information about a position by the position's key Name Type Description key bytes32 The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper Name Type Description _liquidity uint128 The amount of liquidity in the position, Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke, Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke, Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke, Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke feeGrowthInside0LastX128 uint256 feeGrowthInside1LastX128 uint256 tokensOwed0 uint128 tokensOwed1 uint128","title":"positions"},{"location":"uniswap-v3-core/interfaces/pool/IUniswapV3PoolState/#observations_1","text":"function observations(uint256 index) external view returns (uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized) Returns data about a specific observation index You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array. Name Type Description index uint256 The element of the observations array to fetch Name Type Description blockTimestamp uint32 The timestamp of the observation, Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp, Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp, Returns initialized whether the observation has been initialized and the values are safe to use tickCumulative int56 secondsPerLiquidityCumulativeX128 uint160 initialized bool","title":"observations"},{"location":"uniswap-v3-core/libraries/BitMath/","text":"BitMath This library provides functionality for computing bit properties of an unsigned integer mostSignificantBit function mostSignificantBit(uint256 x) internal pure returns (uint8 r) Returns the index of the most significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255 The function satisfies the property: x >= 2 mostSignificantBit(x) and x < 2 (mostSignificantBit(x)+1) Name Type Description x uint256 the value for which to compute the most significant bit, must be greater than 0 Name Type Description r uint8 the index of the most significant bit leastSignificantBit function leastSignificantBit(uint256 x) internal pure returns (uint8 r) Returns the index of the least significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255 The function satisfies the property: (x & 2 leastSignificantBit(x)) != 0 and (x & (2 (leastSignificantBit(x)) - 1)) == 0) Name Type Description x uint256 the value for which to compute the least significant bit, must be greater than 0 Name Type Description r uint8 the index of the least significant bit BitMath This library provides functionality for computing bit properties of an unsigned integer mostSignificantBit function mostSignificantBit(uint256 x) internal pure returns (uint8 r) Returns the index of the most significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255 The function satisfies the property: x >= 2 mostSignificantBit(x) and x < 2 (mostSignificantBit(x)+1) Name Type Description x uint256 the value for which to compute the most significant bit, must be greater than 0 Name Type Description r uint8 the index of the most significant bit leastSignificantBit function leastSignificantBit(uint256 x) internal pure returns (uint8 r) Returns the index of the least significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255 The function satisfies the property: (x & 2 leastSignificantBit(x)) != 0 and (x & (2 (leastSignificantBit(x)) - 1)) == 0) Name Type Description x uint256 the value for which to compute the least significant bit, must be greater than 0 Name Type Description r uint8 the index of the least significant bit BitMath This library provides functionality for computing bit properties of an unsigned integer mostSignificantBit function mostSignificantBit(uint256 x) internal pure returns (uint8 r) Returns the index of the most significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255 The function satisfies the property: x >= 2 mostSignificantBit(x) and x < 2 (mostSignificantBit(x)+1) Name Type Description x uint256 the value for which to compute the most significant bit, must be greater than 0 Name Type Description r uint8 the index of the most significant bit leastSignificantBit function leastSignificantBit(uint256 x) internal pure returns (uint8 r) Returns the index of the least significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255 The function satisfies the property: (x & 2 leastSignificantBit(x)) != 0 and (x & (2 (leastSignificantBit(x)) - 1)) == 0) Name Type Description x uint256 the value for which to compute the least significant bit, must be greater than 0 Name Type Description r uint8 the index of the least significant bit","title":"BitMath"},{"location":"uniswap-v3-core/libraries/BitMath/#bitmath","text":"This library provides functionality for computing bit properties of an unsigned integer","title":"BitMath"},{"location":"uniswap-v3-core/libraries/BitMath/#mostsignificantbit","text":"function mostSignificantBit(uint256 x) internal pure returns (uint8 r) Returns the index of the most significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255 The function satisfies the property: x >= 2 mostSignificantBit(x) and x < 2 (mostSignificantBit(x)+1) Name Type Description x uint256 the value for which to compute the most significant bit, must be greater than 0 Name Type Description r uint8 the index of the most significant bit","title":"mostSignificantBit"},{"location":"uniswap-v3-core/libraries/BitMath/#leastsignificantbit","text":"function leastSignificantBit(uint256 x) internal pure returns (uint8 r) Returns the index of the least significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255 The function satisfies the property: (x & 2 leastSignificantBit(x)) != 0 and (x & (2 (leastSignificantBit(x)) - 1)) == 0) Name Type Description x uint256 the value for which to compute the least significant bit, must be greater than 0 Name Type Description r uint8 the index of the least significant bit","title":"leastSignificantBit"},{"location":"uniswap-v3-core/libraries/BitMath/#bitmath_1","text":"This library provides functionality for computing bit properties of an unsigned integer","title":"BitMath"},{"location":"uniswap-v3-core/libraries/BitMath/#mostsignificantbit_1","text":"function mostSignificantBit(uint256 x) internal pure returns (uint8 r) Returns the index of the most significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255 The function satisfies the property: x >= 2 mostSignificantBit(x) and x < 2 (mostSignificantBit(x)+1) Name Type Description x uint256 the value for which to compute the most significant bit, must be greater than 0 Name Type Description r uint8 the index of the most significant bit","title":"mostSignificantBit"},{"location":"uniswap-v3-core/libraries/BitMath/#leastsignificantbit_1","text":"function leastSignificantBit(uint256 x) internal pure returns (uint8 r) Returns the index of the least significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255 The function satisfies the property: (x & 2 leastSignificantBit(x)) != 0 and (x & (2 (leastSignificantBit(x)) - 1)) == 0) Name Type Description x uint256 the value for which to compute the least significant bit, must be greater than 0 Name Type Description r uint8 the index of the least significant bit","title":"leastSignificantBit"},{"location":"uniswap-v3-core/libraries/BitMath/#bitmath_2","text":"This library provides functionality for computing bit properties of an unsigned integer","title":"BitMath"},{"location":"uniswap-v3-core/libraries/BitMath/#mostsignificantbit_2","text":"function mostSignificantBit(uint256 x) internal pure returns (uint8 r) Returns the index of the most significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255 The function satisfies the property: x >= 2 mostSignificantBit(x) and x < 2 (mostSignificantBit(x)+1) Name Type Description x uint256 the value for which to compute the most significant bit, must be greater than 0 Name Type Description r uint8 the index of the most significant bit","title":"mostSignificantBit"},{"location":"uniswap-v3-core/libraries/BitMath/#leastsignificantbit_2","text":"function leastSignificantBit(uint256 x) internal pure returns (uint8 r) Returns the index of the least significant bit of the number, where the least significant bit is at index 0 and the most significant bit is at index 255 The function satisfies the property: (x & 2 leastSignificantBit(x)) != 0 and (x & (2 (leastSignificantBit(x)) - 1)) == 0) Name Type Description x uint256 the value for which to compute the least significant bit, must be greater than 0 Name Type Description r uint8 the index of the least significant bit","title":"leastSignificantBit"},{"location":"uniswap-v3-core/libraries/FixedPoint128/","text":"FixedPoint128 A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format) Q128 uint256 Q128 FixedPoint128 A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format) Q128 uint256 Q128","title":"FixedPoint128"},{"location":"uniswap-v3-core/libraries/FixedPoint128/#fixedpoint128","text":"A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)","title":"FixedPoint128"},{"location":"uniswap-v3-core/libraries/FixedPoint128/#q128","text":"uint256 Q128","title":"Q128"},{"location":"uniswap-v3-core/libraries/FixedPoint128/#fixedpoint128_1","text":"A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)","title":"FixedPoint128"},{"location":"uniswap-v3-core/libraries/FixedPoint128/#q128_1","text":"uint256 Q128","title":"Q128"},{"location":"uniswap-v3-core/libraries/FixedPoint96/","text":"FixedPoint96 A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format) Used in SqrtPriceMath.sol RESOLUTION uint8 RESOLUTION Q96 uint256 Q96 FixedPoint96 A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format) Used in SqrtPriceMath.sol RESOLUTION uint8 RESOLUTION Q96 uint256 Q96","title":"FixedPoint96"},{"location":"uniswap-v3-core/libraries/FixedPoint96/#fixedpoint96","text":"A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format) Used in SqrtPriceMath.sol","title":"FixedPoint96"},{"location":"uniswap-v3-core/libraries/FixedPoint96/#resolution","text":"uint8 RESOLUTION","title":"RESOLUTION"},{"location":"uniswap-v3-core/libraries/FixedPoint96/#q96","text":"uint256 Q96","title":"Q96"},{"location":"uniswap-v3-core/libraries/FixedPoint96/#fixedpoint96_1","text":"A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format) Used in SqrtPriceMath.sol","title":"FixedPoint96"},{"location":"uniswap-v3-core/libraries/FixedPoint96/#resolution_1","text":"uint8 RESOLUTION","title":"RESOLUTION"},{"location":"uniswap-v3-core/libraries/FixedPoint96/#q96_1","text":"uint256 Q96","title":"Q96"},{"location":"uniswap-v3-core/libraries/FullMath/","text":"FullMath Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits mulDiv function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0 Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv Name Type Description a uint256 The multiplicand b uint256 The multiplier denominator uint256 The divisor Name Type Description result uint256 The 256-bit result mulDivRoundingUp function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0 Name Type Description a uint256 The multiplicand b uint256 The multiplier denominator uint256 The divisor Name Type Description result uint256 The 256-bit result","title":"FullMath"},{"location":"uniswap-v3-core/libraries/FullMath/#fullmath","text":"Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits","title":"FullMath"},{"location":"uniswap-v3-core/libraries/FullMath/#muldiv","text":"function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0 Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv Name Type Description a uint256 The multiplicand b uint256 The multiplier denominator uint256 The divisor Name Type Description result uint256 The 256-bit result","title":"mulDiv"},{"location":"uniswap-v3-core/libraries/FullMath/#muldivroundingup","text":"function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0 Name Type Description a uint256 The multiplicand b uint256 The multiplier denominator uint256 The divisor Name Type Description result uint256 The 256-bit result","title":"mulDivRoundingUp"},{"location":"uniswap-v3-core/libraries/LiquidityMath/","text":"LiquidityMath addDelta function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) Add a signed liquidity delta to liquidity and revert if it overflows or underflows Name Type Description x uint128 The liquidity before change y int128 The delta by which liquidity should be changed Name Type Description z uint128 The liquidity delta LiquidityMath addDelta function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) Add a signed liquidity delta to liquidity and revert if it overflows or underflows Name Type Description x uint128 The liquidity before change y int128 The delta by which liquidity should be changed Name Type Description z uint128 The liquidity delta","title":"LiquidityMath"},{"location":"uniswap-v3-core/libraries/LiquidityMath/#liquiditymath","text":"","title":"LiquidityMath"},{"location":"uniswap-v3-core/libraries/LiquidityMath/#adddelta","text":"function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) Add a signed liquidity delta to liquidity and revert if it overflows or underflows Name Type Description x uint128 The liquidity before change y int128 The delta by which liquidity should be changed Name Type Description z uint128 The liquidity delta","title":"addDelta"},{"location":"uniswap-v3-core/libraries/LiquidityMath/#liquiditymath_1","text":"","title":"LiquidityMath"},{"location":"uniswap-v3-core/libraries/LiquidityMath/#adddelta_1","text":"function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) Add a signed liquidity delta to liquidity and revert if it overflows or underflows Name Type Description x uint128 The liquidity before change y int128 The delta by which liquidity should be changed Name Type Description z uint128 The liquidity delta","title":"addDelta"},{"location":"uniswap-v3-core/libraries/LowGasSafeMath/","text":"LowGasSafeMath Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost add function add(uint256 x, uint256 y) internal pure returns (uint256 z) Returns x + y, reverts if sum overflows uint256 Name Type Description x uint256 The augend y uint256 The addend Name Type Description z uint256 The sum of x and y sub function sub(uint256 x, uint256 y) internal pure returns (uint256 z) Returns x - y, reverts if underflows Name Type Description x uint256 The minuend y uint256 The subtrahend Name Type Description z uint256 The difference of x and y mul function mul(uint256 x, uint256 y) internal pure returns (uint256 z) Returns x * y, reverts if overflows Name Type Description x uint256 The multiplicand y uint256 The multiplier Name Type Description z uint256 The product of x and y add function add(int256 x, int256 y) internal pure returns (int256 z) Returns x + y, reverts if overflows or underflows Name Type Description x int256 The augend y int256 The addend Name Type Description z int256 The sum of x and y sub function sub(int256 x, int256 y) internal pure returns (int256 z) Returns x - y, reverts if overflows or underflows Name Type Description x int256 The minuend y int256 The subtrahend Name Type Description z int256 The difference of x and y LowGasSafeMath Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost add function add(uint256 x, uint256 y) internal pure returns (uint256 z) Returns x + y, reverts if sum overflows uint256 Name Type Description x uint256 The augend y uint256 The addend Name Type Description z uint256 The sum of x and y sub function sub(uint256 x, uint256 y) internal pure returns (uint256 z) Returns x - y, reverts if underflows Name Type Description x uint256 The minuend y uint256 The subtrahend Name Type Description z uint256 The difference of x and y mul function mul(uint256 x, uint256 y) internal pure returns (uint256 z) Returns x * y, reverts if overflows Name Type Description x uint256 The multiplicand y uint256 The multiplier Name Type Description z uint256 The product of x and y add function add(int256 x, int256 y) internal pure returns (int256 z) Returns x + y, reverts if overflows or underflows Name Type Description x int256 The augend y int256 The addend Name Type Description z int256 The sum of x and y sub function sub(int256 x, int256 y) internal pure returns (int256 z) Returns x - y, reverts if overflows or underflows Name Type Description x int256 The minuend y int256 The subtrahend Name Type Description z int256 The difference of x and y","title":"LowGasSafeMath"},{"location":"uniswap-v3-core/libraries/LowGasSafeMath/#lowgassafemath","text":"Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost","title":"LowGasSafeMath"},{"location":"uniswap-v3-core/libraries/LowGasSafeMath/#add","text":"function add(uint256 x, uint256 y) internal pure returns (uint256 z) Returns x + y, reverts if sum overflows uint256 Name Type Description x uint256 The augend y uint256 The addend Name Type Description z uint256 The sum of x and y","title":"add"},{"location":"uniswap-v3-core/libraries/LowGasSafeMath/#sub","text":"function sub(uint256 x, uint256 y) internal pure returns (uint256 z) Returns x - y, reverts if underflows Name Type Description x uint256 The minuend y uint256 The subtrahend Name Type Description z uint256 The difference of x and y","title":"sub"},{"location":"uniswap-v3-core/libraries/LowGasSafeMath/#mul","text":"function mul(uint256 x, uint256 y) internal pure returns (uint256 z) Returns x * y, reverts if overflows Name Type Description x uint256 The multiplicand y uint256 The multiplier Name Type Description z uint256 The product of x and y","title":"mul"},{"location":"uniswap-v3-core/libraries/LowGasSafeMath/#add_1","text":"function add(int256 x, int256 y) internal pure returns (int256 z) Returns x + y, reverts if overflows or underflows Name Type Description x int256 The augend y int256 The addend Name Type Description z int256 The sum of x and y","title":"add"},{"location":"uniswap-v3-core/libraries/LowGasSafeMath/#sub_1","text":"function sub(int256 x, int256 y) internal pure returns (int256 z) Returns x - y, reverts if overflows or underflows Name Type Description x int256 The minuend y int256 The subtrahend Name Type Description z int256 The difference of x and y","title":"sub"},{"location":"uniswap-v3-core/libraries/LowGasSafeMath/#lowgassafemath_1","text":"Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost","title":"LowGasSafeMath"},{"location":"uniswap-v3-core/libraries/LowGasSafeMath/#add_2","text":"function add(uint256 x, uint256 y) internal pure returns (uint256 z) Returns x + y, reverts if sum overflows uint256 Name Type Description x uint256 The augend y uint256 The addend Name Type Description z uint256 The sum of x and y","title":"add"},{"location":"uniswap-v3-core/libraries/LowGasSafeMath/#sub_2","text":"function sub(uint256 x, uint256 y) internal pure returns (uint256 z) Returns x - y, reverts if underflows Name Type Description x uint256 The minuend y uint256 The subtrahend Name Type Description z uint256 The difference of x and y","title":"sub"},{"location":"uniswap-v3-core/libraries/LowGasSafeMath/#mul_1","text":"function mul(uint256 x, uint256 y) internal pure returns (uint256 z) Returns x * y, reverts if overflows Name Type Description x uint256 The multiplicand y uint256 The multiplier Name Type Description z uint256 The product of x and y","title":"mul"},{"location":"uniswap-v3-core/libraries/LowGasSafeMath/#add_3","text":"function add(int256 x, int256 y) internal pure returns (int256 z) Returns x + y, reverts if overflows or underflows Name Type Description x int256 The augend y int256 The addend Name Type Description z int256 The sum of x and y","title":"add"},{"location":"uniswap-v3-core/libraries/LowGasSafeMath/#sub_3","text":"function sub(int256 x, int256 y) internal pure returns (int256 z) Returns x - y, reverts if overflows or underflows Name Type Description x int256 The minuend y int256 The subtrahend Name Type Description z int256 The difference of x and y","title":"sub"},{"location":"uniswap-v3-core/libraries/Oracle/","text":"Oracle Provides price and liquidity data useful for a wide variety of system designs Instances of stored oracle data, \"observations\", are collected in the oracle array Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the maximum length of the oracle array. New slots will be added when the array is fully populated. Observations are overwritten when the full length of the oracle array is populated. The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe() Observation struct Observation { uint32 blockTimestamp; int56 tickCumulative; uint160 secondsPerLiquidityCumulativeX128; bool initialized; } transform function transform(struct Oracle.Observation last, uint32 blockTimestamp, int24 tick, uint128 liquidity) private pure returns (struct Oracle.Observation) Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values blockTimestamp _must be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows_ Name Type Description last struct Oracle.Observation The specified observation to be transformed blockTimestamp uint32 The timestamp of the new observation tick int24 The active tick at the time of the new observation liquidity uint128 The total in-range liquidity at the time of the new observation Name Type Description [0] struct Oracle.Observation Observation The newly populated observation initialize function initialize(struct Oracle.Observation[65535] self, uint32 time) internal returns (uint16 cardinality, uint16 cardinalityNext) Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array Name Type Description self struct Oracle.Observation[65535] The stored oracle array time uint32 The time of the oracle initialization, via block.timestamp truncated to uint32 Name Type Description cardinality uint16 The number of populated elements in the oracle array cardinalityNext uint16 The new length of the oracle array, independent of population write function write(struct Oracle.Observation[65535] self, uint16 index, uint32 blockTimestamp, int24 tick, uint128 liquidity, uint16 cardinality, uint16 cardinalityNext) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) Writes an oracle observation to the array Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally. If the index is at the end of the allowable array length (according to cardinality), and the next cardinality is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering. Name Type Description self struct Oracle.Observation[65535] The stored oracle array index uint16 The index of the observation that was most recently written to the observations array blockTimestamp uint32 The timestamp of the new observation tick int24 The active tick at the time of the new observation liquidity uint128 The total in-range liquidity at the time of the new observation cardinality uint16 The number of populated elements in the oracle array cardinalityNext uint16 The new length of the oracle array, independent of population Name Type Description indexUpdated uint16 The new index of the most recently written element in the oracle array cardinalityUpdated uint16 The new cardinality of the oracle array grow function grow(struct Oracle.Observation[65535] self, uint16 current, uint16 next) internal returns (uint16) Prepares the oracle array to store up to next observations Name Type Description self struct Oracle.Observation[65535] The stored oracle array current uint16 The current next cardinality of the oracle array next uint16 The proposed next cardinality which will be populated in the oracle array Name Type Description [0] uint16 next The next cardinality which will be populated in the oracle array lte function lte(uint32 time, uint32 a, uint32 b) private pure returns (bool) comparator for 32-bit timestamps safe for 0 or 1 overflows, a and b _must be chronologically before or equal to time_ Name Type Description time uint32 A timestamp truncated to 32 bits a uint32 A comparison timestamp from which to determine the relative position of time b uint32 From which to determine the relative position of time Name Type Description [0] bool bool Whether a is chronologically <= b binarySearch function binarySearch(struct Oracle.Observation[65535] self, uint32 time, uint32 target, uint16 index, uint16 cardinality) private view returns (struct Oracle.Observation beforeOrAt, struct Oracle.Observation atOrAfter) Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied. The result may be the same observation, or adjacent observations. The answer must be contained in the array, used when the target is located within the stored observation boundaries: older than the most recent observation and younger, or the same age as, the oldest observation Name Type Description self struct Oracle.Observation[65535] The stored oracle array time uint32 The current block.timestamp target uint32 The timestamp at which the reserved observation should be for index uint16 The index of the observation that was most recently written to the observations array cardinality uint16 The number of populated elements in the oracle array Name Type Description beforeOrAt struct Oracle.Observation The observation recorded before, or at, the target atOrAfter struct Oracle.Observation The observation recorded at, or after, the target getSurroundingObservations function getSurroundingObservations(struct Oracle.Observation[65535] self, uint32 time, uint32 target, int24 tick, uint16 index, uint128 liquidity, uint16 cardinality) private view returns (struct Oracle.Observation beforeOrAt, struct Oracle.Observation atOrAfter) Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied Assumes there is at least 1 initialized observation. Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp. Name Type Description self struct Oracle.Observation[65535] The stored oracle array time uint32 The current block.timestamp target uint32 The timestamp at which the reserved observation should be for tick int24 The active tick at the time of the returned or simulated observation index uint16 The index of the observation that was most recently written to the observations array liquidity uint128 The total pool liquidity at the time of the call cardinality uint16 The number of populated elements in the oracle array Name Type Description beforeOrAt struct Oracle.Observation The observation which occurred at, or before, the given timestamp atOrAfter struct Oracle.Observation The observation which occurred at, or after, the given timestamp observeSingle function observeSingle(struct Oracle.Observation[65535] self, uint32 time, uint32 secondsAgo, int24 tick, uint16 index, uint128 liquidity, uint16 cardinality) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) Reverts if an observation at or before the desired observation timestamp does not exist. 0 may be passed as `secondsAgo' to return the current cumulative values. If called with a timestamp falling between two observations, returns the counterfactual accumulator values at exactly the timestamp between the two observations. Name Type Description self struct Oracle.Observation[65535] The stored oracle array time uint32 The current block timestamp secondsAgo uint32 The amount of time to look back, in seconds, at which point to return an observation tick int24 The current tick index uint16 The index of the observation that was most recently written to the observations array liquidity uint128 The current in-range pool liquidity cardinality uint16 The number of populated elements in the oracle array Name Type Description tickCumulative int56 The tick * time elapsed since the pool was first initialized, as of secondsAgo secondsPerLiquidityCumulativeX128 uint160 The time elapsed / max(1, liquidity) since the pool was first initialized, as of secondsAgo observe function observe(struct Oracle.Observation[65535] self, uint32 time, uint32[] secondsAgos, int24 tick, uint16 index, uint128 liquidity, uint16 cardinality) internal view returns (int56[] tickCumulatives, uint160[] secondsPerLiquidityCumulativeX128s) Returns the accumulator values as of each time seconds ago from the given time in the array of secondsAgos Reverts if secondsAgos > oldest observation Name Type Description self struct Oracle.Observation[65535] The stored oracle array time uint32 The current block.timestamp secondsAgos uint32[] Each amount of time to look back, in seconds, at which point to return an observation tick int24 The current tick index uint16 The index of the observation that was most recently written to the observations array liquidity uint128 The current in-range pool liquidity cardinality uint16 The number of populated elements in the oracle array Name Type Description tickCumulatives int56[] The tick * time elapsed since the pool was first initialized, as of each secondsAgo secondsPerLiquidityCumulativeX128s uint160[] The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each secondsAgo","title":"Oracle"},{"location":"uniswap-v3-core/libraries/Oracle/#oracle","text":"Provides price and liquidity data useful for a wide variety of system designs Instances of stored oracle data, \"observations\", are collected in the oracle array Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the maximum length of the oracle array. New slots will be added when the array is fully populated. Observations are overwritten when the full length of the oracle array is populated. The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()","title":"Oracle"},{"location":"uniswap-v3-core/libraries/Oracle/#observation","text":"struct Observation { uint32 blockTimestamp; int56 tickCumulative; uint160 secondsPerLiquidityCumulativeX128; bool initialized; }","title":"Observation"},{"location":"uniswap-v3-core/libraries/Oracle/#transform","text":"function transform(struct Oracle.Observation last, uint32 blockTimestamp, int24 tick, uint128 liquidity) private pure returns (struct Oracle.Observation) Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values blockTimestamp _must be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows_ Name Type Description last struct Oracle.Observation The specified observation to be transformed blockTimestamp uint32 The timestamp of the new observation tick int24 The active tick at the time of the new observation liquidity uint128 The total in-range liquidity at the time of the new observation Name Type Description [0] struct Oracle.Observation Observation The newly populated observation","title":"transform"},{"location":"uniswap-v3-core/libraries/Oracle/#initialize","text":"function initialize(struct Oracle.Observation[65535] self, uint32 time) internal returns (uint16 cardinality, uint16 cardinalityNext) Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array Name Type Description self struct Oracle.Observation[65535] The stored oracle array time uint32 The time of the oracle initialization, via block.timestamp truncated to uint32 Name Type Description cardinality uint16 The number of populated elements in the oracle array cardinalityNext uint16 The new length of the oracle array, independent of population","title":"initialize"},{"location":"uniswap-v3-core/libraries/Oracle/#write","text":"function write(struct Oracle.Observation[65535] self, uint16 index, uint32 blockTimestamp, int24 tick, uint128 liquidity, uint16 cardinality, uint16 cardinalityNext) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) Writes an oracle observation to the array Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally. If the index is at the end of the allowable array length (according to cardinality), and the next cardinality is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering. Name Type Description self struct Oracle.Observation[65535] The stored oracle array index uint16 The index of the observation that was most recently written to the observations array blockTimestamp uint32 The timestamp of the new observation tick int24 The active tick at the time of the new observation liquidity uint128 The total in-range liquidity at the time of the new observation cardinality uint16 The number of populated elements in the oracle array cardinalityNext uint16 The new length of the oracle array, independent of population Name Type Description indexUpdated uint16 The new index of the most recently written element in the oracle array cardinalityUpdated uint16 The new cardinality of the oracle array","title":"write"},{"location":"uniswap-v3-core/libraries/Oracle/#grow","text":"function grow(struct Oracle.Observation[65535] self, uint16 current, uint16 next) internal returns (uint16) Prepares the oracle array to store up to next observations Name Type Description self struct Oracle.Observation[65535] The stored oracle array current uint16 The current next cardinality of the oracle array next uint16 The proposed next cardinality which will be populated in the oracle array Name Type Description [0] uint16 next The next cardinality which will be populated in the oracle array","title":"grow"},{"location":"uniswap-v3-core/libraries/Oracle/#lte","text":"function lte(uint32 time, uint32 a, uint32 b) private pure returns (bool) comparator for 32-bit timestamps safe for 0 or 1 overflows, a and b _must be chronologically before or equal to time_ Name Type Description time uint32 A timestamp truncated to 32 bits a uint32 A comparison timestamp from which to determine the relative position of time b uint32 From which to determine the relative position of time Name Type Description [0] bool bool Whether a is chronologically <= b","title":"lte"},{"location":"uniswap-v3-core/libraries/Oracle/#binarysearch","text":"function binarySearch(struct Oracle.Observation[65535] self, uint32 time, uint32 target, uint16 index, uint16 cardinality) private view returns (struct Oracle.Observation beforeOrAt, struct Oracle.Observation atOrAfter) Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied. The result may be the same observation, or adjacent observations. The answer must be contained in the array, used when the target is located within the stored observation boundaries: older than the most recent observation and younger, or the same age as, the oldest observation Name Type Description self struct Oracle.Observation[65535] The stored oracle array time uint32 The current block.timestamp target uint32 The timestamp at which the reserved observation should be for index uint16 The index of the observation that was most recently written to the observations array cardinality uint16 The number of populated elements in the oracle array Name Type Description beforeOrAt struct Oracle.Observation The observation recorded before, or at, the target atOrAfter struct Oracle.Observation The observation recorded at, or after, the target","title":"binarySearch"},{"location":"uniswap-v3-core/libraries/Oracle/#getsurroundingobservations","text":"function getSurroundingObservations(struct Oracle.Observation[65535] self, uint32 time, uint32 target, int24 tick, uint16 index, uint128 liquidity, uint16 cardinality) private view returns (struct Oracle.Observation beforeOrAt, struct Oracle.Observation atOrAfter) Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied Assumes there is at least 1 initialized observation. Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp. Name Type Description self struct Oracle.Observation[65535] The stored oracle array time uint32 The current block.timestamp target uint32 The timestamp at which the reserved observation should be for tick int24 The active tick at the time of the returned or simulated observation index uint16 The index of the observation that was most recently written to the observations array liquidity uint128 The total pool liquidity at the time of the call cardinality uint16 The number of populated elements in the oracle array Name Type Description beforeOrAt struct Oracle.Observation The observation which occurred at, or before, the given timestamp atOrAfter struct Oracle.Observation The observation which occurred at, or after, the given timestamp","title":"getSurroundingObservations"},{"location":"uniswap-v3-core/libraries/Oracle/#observesingle","text":"function observeSingle(struct Oracle.Observation[65535] self, uint32 time, uint32 secondsAgo, int24 tick, uint16 index, uint128 liquidity, uint16 cardinality) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) Reverts if an observation at or before the desired observation timestamp does not exist. 0 may be passed as `secondsAgo' to return the current cumulative values. If called with a timestamp falling between two observations, returns the counterfactual accumulator values at exactly the timestamp between the two observations. Name Type Description self struct Oracle.Observation[65535] The stored oracle array time uint32 The current block timestamp secondsAgo uint32 The amount of time to look back, in seconds, at which point to return an observation tick int24 The current tick index uint16 The index of the observation that was most recently written to the observations array liquidity uint128 The current in-range pool liquidity cardinality uint16 The number of populated elements in the oracle array Name Type Description tickCumulative int56 The tick * time elapsed since the pool was first initialized, as of secondsAgo secondsPerLiquidityCumulativeX128 uint160 The time elapsed / max(1, liquidity) since the pool was first initialized, as of secondsAgo","title":"observeSingle"},{"location":"uniswap-v3-core/libraries/Oracle/#observe","text":"function observe(struct Oracle.Observation[65535] self, uint32 time, uint32[] secondsAgos, int24 tick, uint16 index, uint128 liquidity, uint16 cardinality) internal view returns (int56[] tickCumulatives, uint160[] secondsPerLiquidityCumulativeX128s) Returns the accumulator values as of each time seconds ago from the given time in the array of secondsAgos Reverts if secondsAgos > oldest observation Name Type Description self struct Oracle.Observation[65535] The stored oracle array time uint32 The current block.timestamp secondsAgos uint32[] Each amount of time to look back, in seconds, at which point to return an observation tick int24 The current tick index uint16 The index of the observation that was most recently written to the observations array liquidity uint128 The current in-range pool liquidity cardinality uint16 The number of populated elements in the oracle array Name Type Description tickCumulatives int56[] The tick * time elapsed since the pool was first initialized, as of each secondsAgo secondsPerLiquidityCumulativeX128s uint160[] The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each secondsAgo","title":"observe"},{"location":"uniswap-v3-core/libraries/Position/","text":"Position Positions represent an owner address' liquidity between a lower and upper tick boundary Positions store additional state for tracking fees owed to the position Info struct Info { uint128 liquidity; uint256 feeGrowthInside0LastX128; uint256 feeGrowthInside1LastX128; uint128 tokensOwed0; uint128 tokensOwed1; } get function get(mapping(bytes32 => struct Position.Info) self, address owner, int24 tickLower, int24 tickUpper) internal view returns (struct Position.Info position) Returns the Info struct of a position, given an owner and position boundaries Name Type Description self mapping(bytes32 => struct Position.Info) The mapping containing all user positions owner address The address of the position owner tickLower int24 The lower tick boundary of the position tickUpper int24 The upper tick boundary of the position Name Type Description position struct Position.Info The position info struct of the given owners' position update function update(struct Position.Info self, int128 liquidityDelta, uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) internal Credits accumulated fees to a user's position Name Type Description self struct Position.Info The individual position to update liquidityDelta int128 The change in pool liquidity as a result of the position update feeGrowthInside0X128 uint256 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries feeGrowthInside1X128 uint256 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries","title":"Position"},{"location":"uniswap-v3-core/libraries/Position/#position","text":"Positions represent an owner address' liquidity between a lower and upper tick boundary Positions store additional state for tracking fees owed to the position","title":"Position"},{"location":"uniswap-v3-core/libraries/Position/#info","text":"struct Info { uint128 liquidity; uint256 feeGrowthInside0LastX128; uint256 feeGrowthInside1LastX128; uint128 tokensOwed0; uint128 tokensOwed1; }","title":"Info"},{"location":"uniswap-v3-core/libraries/Position/#get","text":"function get(mapping(bytes32 => struct Position.Info) self, address owner, int24 tickLower, int24 tickUpper) internal view returns (struct Position.Info position) Returns the Info struct of a position, given an owner and position boundaries Name Type Description self mapping(bytes32 => struct Position.Info) The mapping containing all user positions owner address The address of the position owner tickLower int24 The lower tick boundary of the position tickUpper int24 The upper tick boundary of the position Name Type Description position struct Position.Info The position info struct of the given owners' position","title":"get"},{"location":"uniswap-v3-core/libraries/Position/#update","text":"function update(struct Position.Info self, int128 liquidityDelta, uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) internal Credits accumulated fees to a user's position Name Type Description self struct Position.Info The individual position to update liquidityDelta int128 The change in pool liquidity as a result of the position update feeGrowthInside0X128 uint256 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries feeGrowthInside1X128 uint256 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries","title":"update"},{"location":"uniswap-v3-core/libraries/SafeCast/","text":"SafeCast Contains methods for safely casting between types toUint160 function toUint160(uint256 y) internal pure returns (uint160 z) Cast a uint256 to a uint160, revert on overflow Name Type Description y uint256 The uint256 to be downcasted Name Type Description z uint160 The downcasted integer, now type uint160 toInt128 function toInt128(int256 y) internal pure returns (int128 z) Cast a int256 to a int128, revert on overflow or underflow Name Type Description y int256 The int256 to be downcasted Name Type Description z int128 The downcasted integer, now type int128 toInt256 function toInt256(uint256 y) internal pure returns (int256 z) Cast a uint256 to a int256, revert on overflow Name Type Description y uint256 The uint256 to be casted Name Type Description z int256 The casted integer, now type int256 SafeCast Contains methods for safely casting between types toUint160 function toUint160(uint256 y) internal pure returns (uint160 z) Cast a uint256 to a uint160, revert on overflow Name Type Description y uint256 The uint256 to be downcasted Name Type Description z uint160 The downcasted integer, now type uint160 toInt128 function toInt128(int256 y) internal pure returns (int128 z) Cast a int256 to a int128, revert on overflow or underflow Name Type Description y int256 The int256 to be downcasted Name Type Description z int128 The downcasted integer, now type int128 toInt256 function toInt256(uint256 y) internal pure returns (int256 z) Cast a uint256 to a int256, revert on overflow Name Type Description y uint256 The uint256 to be casted Name Type Description z int256 The casted integer, now type int256","title":"SafeCast"},{"location":"uniswap-v3-core/libraries/SafeCast/#safecast","text":"Contains methods for safely casting between types","title":"SafeCast"},{"location":"uniswap-v3-core/libraries/SafeCast/#touint160","text":"function toUint160(uint256 y) internal pure returns (uint160 z) Cast a uint256 to a uint160, revert on overflow Name Type Description y uint256 The uint256 to be downcasted Name Type Description z uint160 The downcasted integer, now type uint160","title":"toUint160"},{"location":"uniswap-v3-core/libraries/SafeCast/#toint128","text":"function toInt128(int256 y) internal pure returns (int128 z) Cast a int256 to a int128, revert on overflow or underflow Name Type Description y int256 The int256 to be downcasted Name Type Description z int128 The downcasted integer, now type int128","title":"toInt128"},{"location":"uniswap-v3-core/libraries/SafeCast/#toint256","text":"function toInt256(uint256 y) internal pure returns (int256 z) Cast a uint256 to a int256, revert on overflow Name Type Description y uint256 The uint256 to be casted Name Type Description z int256 The casted integer, now type int256","title":"toInt256"},{"location":"uniswap-v3-core/libraries/SafeCast/#safecast_1","text":"Contains methods for safely casting between types","title":"SafeCast"},{"location":"uniswap-v3-core/libraries/SafeCast/#touint160_1","text":"function toUint160(uint256 y) internal pure returns (uint160 z) Cast a uint256 to a uint160, revert on overflow Name Type Description y uint256 The uint256 to be downcasted Name Type Description z uint160 The downcasted integer, now type uint160","title":"toUint160"},{"location":"uniswap-v3-core/libraries/SafeCast/#toint128_1","text":"function toInt128(int256 y) internal pure returns (int128 z) Cast a int256 to a int128, revert on overflow or underflow Name Type Description y int256 The int256 to be downcasted Name Type Description z int128 The downcasted integer, now type int128","title":"toInt128"},{"location":"uniswap-v3-core/libraries/SafeCast/#toint256_1","text":"function toInt256(uint256 y) internal pure returns (int256 z) Cast a uint256 to a int256, revert on overflow Name Type Description y uint256 The uint256 to be casted Name Type Description z int256 The casted integer, now type int256","title":"toInt256"},{"location":"uniswap-v3-core/libraries/SqrtPriceMath/","text":"SqrtPriceMath Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas getNextSqrtPriceFromAmount0RoundingUp function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add) internal pure returns (uint160) Gets the next sqrt price given a delta of token0 Always rounds up, because in the exact output case (increasing price) we need to move the price at least far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the price less in order to not send too much output. The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96), if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount). Name Type Description sqrtPX96 uint160 The starting price, i.e. before accounting for the token0 delta liquidity uint128 The amount of usable liquidity amount uint256 How much of token0 to add or remove from virtual reserves add bool Whether to add or remove the amount of token0 Name Type Description [0] uint160 The price after adding or removing amount, depending on add getNextSqrtPriceFromAmount1RoundingDown function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add) internal pure returns (uint160) Gets the next sqrt price given a delta of token1 Always rounds down, because in the exact output case (decreasing price) we need to move the price at least far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the price less in order to not send too much output. The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity Name Type Description sqrtPX96 uint160 The starting price, i.e., before accounting for the token1 delta liquidity uint128 The amount of usable liquidity amount uint256 How much of token1 to add, or remove, from virtual reserves add bool Whether to add, or remove, the amount of token1 Name Type Description [0] uint160 The price after adding or removing amount getNextSqrtPriceFromInput function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne) internal pure returns (uint160 sqrtQX96) Gets the next sqrt price given an input amount of token0 or token1 Throws if price or liquidity are 0, or if the next price is out of bounds Name Type Description sqrtPX96 uint160 The starting price, i.e., before accounting for the input amount liquidity uint128 The amount of usable liquidity amountIn uint256 How much of token0, or token1, is being swapped in zeroForOne bool Whether the amount in is token0 or token1 Name Type Description sqrtQX96 uint160 The price after adding the input amount to token0 or token1 getNextSqrtPriceFromOutput function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne) internal pure returns (uint160 sqrtQX96) Gets the next sqrt price given an output amount of token0 or token1 Throws if price or liquidity are 0 or the next price is out of bounds Name Type Description sqrtPX96 uint160 The starting price before accounting for the output amount liquidity uint128 The amount of usable liquidity amountOut uint256 How much of token0, or token1, is being swapped out zeroForOne bool Whether the amount out is token0 or token1 Name Type Description sqrtQX96 uint160 The price after removing the output amount of token0 or token1 getAmount0Delta function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp) internal pure returns (uint256 amount0) Gets the amount0 delta between two prices Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper), i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower)) Name Type Description sqrtRatioAX96 uint160 A sqrt price sqrtRatioBX96 uint160 Another sqrt price liquidity uint128 The amount of usable liquidity roundUp bool Whether to round the amount up or down Name Type Description amount0 uint256 Amount of token0 required to cover a position of size liquidity between the two passed prices getAmount1Delta function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp) internal pure returns (uint256 amount1) Gets the amount1 delta between two prices Calculates liquidity * (sqrt(upper) - sqrt(lower)) Name Type Description sqrtRatioAX96 uint160 A sqrt price sqrtRatioBX96 uint160 Another sqrt price liquidity uint128 The amount of usable liquidity roundUp bool Whether to round the amount up, or down Name Type Description amount1 uint256 Amount of token1 required to cover a position of size liquidity between the two passed prices getAmount0Delta function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity) internal pure returns (int256 amount0) Helper that gets signed token0 delta Name Type Description sqrtRatioAX96 uint160 A sqrt price sqrtRatioBX96 uint160 Another sqrt price liquidity int128 The change in liquidity for which to compute the amount0 delta Name Type Description amount0 int256 Amount of token0 corresponding to the passed liquidityDelta between the two prices getAmount1Delta function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity) internal pure returns (int256 amount1) Helper that gets signed token1 delta Name Type Description sqrtRatioAX96 uint160 A sqrt price sqrtRatioBX96 uint160 Another sqrt price liquidity int128 The change in liquidity for which to compute the amount1 delta Name Type Description amount1 int256 Amount of token1 corresponding to the passed liquidityDelta between the two prices","title":"SqrtPriceMath"},{"location":"uniswap-v3-core/libraries/SqrtPriceMath/#sqrtpricemath","text":"Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas","title":"SqrtPriceMath"},{"location":"uniswap-v3-core/libraries/SqrtPriceMath/#getnextsqrtpricefromamount0roundingup","text":"function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add) internal pure returns (uint160) Gets the next sqrt price given a delta of token0 Always rounds up, because in the exact output case (increasing price) we need to move the price at least far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the price less in order to not send too much output. The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96), if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount). Name Type Description sqrtPX96 uint160 The starting price, i.e. before accounting for the token0 delta liquidity uint128 The amount of usable liquidity amount uint256 How much of token0 to add or remove from virtual reserves add bool Whether to add or remove the amount of token0 Name Type Description [0] uint160 The price after adding or removing amount, depending on add","title":"getNextSqrtPriceFromAmount0RoundingUp"},{"location":"uniswap-v3-core/libraries/SqrtPriceMath/#getnextsqrtpricefromamount1roundingdown","text":"function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add) internal pure returns (uint160) Gets the next sqrt price given a delta of token1 Always rounds down, because in the exact output case (decreasing price) we need to move the price at least far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the price less in order to not send too much output. The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity Name Type Description sqrtPX96 uint160 The starting price, i.e., before accounting for the token1 delta liquidity uint128 The amount of usable liquidity amount uint256 How much of token1 to add, or remove, from virtual reserves add bool Whether to add, or remove, the amount of token1 Name Type Description [0] uint160 The price after adding or removing amount","title":"getNextSqrtPriceFromAmount1RoundingDown"},{"location":"uniswap-v3-core/libraries/SqrtPriceMath/#getnextsqrtpricefrominput","text":"function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne) internal pure returns (uint160 sqrtQX96) Gets the next sqrt price given an input amount of token0 or token1 Throws if price or liquidity are 0, or if the next price is out of bounds Name Type Description sqrtPX96 uint160 The starting price, i.e., before accounting for the input amount liquidity uint128 The amount of usable liquidity amountIn uint256 How much of token0, or token1, is being swapped in zeroForOne bool Whether the amount in is token0 or token1 Name Type Description sqrtQX96 uint160 The price after adding the input amount to token0 or token1","title":"getNextSqrtPriceFromInput"},{"location":"uniswap-v3-core/libraries/SqrtPriceMath/#getnextsqrtpricefromoutput","text":"function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne) internal pure returns (uint160 sqrtQX96) Gets the next sqrt price given an output amount of token0 or token1 Throws if price or liquidity are 0 or the next price is out of bounds Name Type Description sqrtPX96 uint160 The starting price before accounting for the output amount liquidity uint128 The amount of usable liquidity amountOut uint256 How much of token0, or token1, is being swapped out zeroForOne bool Whether the amount out is token0 or token1 Name Type Description sqrtQX96 uint160 The price after removing the output amount of token0 or token1","title":"getNextSqrtPriceFromOutput"},{"location":"uniswap-v3-core/libraries/SqrtPriceMath/#getamount0delta","text":"function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp) internal pure returns (uint256 amount0) Gets the amount0 delta between two prices Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper), i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower)) Name Type Description sqrtRatioAX96 uint160 A sqrt price sqrtRatioBX96 uint160 Another sqrt price liquidity uint128 The amount of usable liquidity roundUp bool Whether to round the amount up or down Name Type Description amount0 uint256 Amount of token0 required to cover a position of size liquidity between the two passed prices","title":"getAmount0Delta"},{"location":"uniswap-v3-core/libraries/SqrtPriceMath/#getamount1delta","text":"function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp) internal pure returns (uint256 amount1) Gets the amount1 delta between two prices Calculates liquidity * (sqrt(upper) - sqrt(lower)) Name Type Description sqrtRatioAX96 uint160 A sqrt price sqrtRatioBX96 uint160 Another sqrt price liquidity uint128 The amount of usable liquidity roundUp bool Whether to round the amount up, or down Name Type Description amount1 uint256 Amount of token1 required to cover a position of size liquidity between the two passed prices","title":"getAmount1Delta"},{"location":"uniswap-v3-core/libraries/SqrtPriceMath/#getamount0delta_1","text":"function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity) internal pure returns (int256 amount0) Helper that gets signed token0 delta Name Type Description sqrtRatioAX96 uint160 A sqrt price sqrtRatioBX96 uint160 Another sqrt price liquidity int128 The change in liquidity for which to compute the amount0 delta Name Type Description amount0 int256 Amount of token0 corresponding to the passed liquidityDelta between the two prices","title":"getAmount0Delta"},{"location":"uniswap-v3-core/libraries/SqrtPriceMath/#getamount1delta_1","text":"function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity) internal pure returns (int256 amount1) Helper that gets signed token1 delta Name Type Description sqrtRatioAX96 uint160 A sqrt price sqrtRatioBX96 uint160 Another sqrt price liquidity int128 The change in liquidity for which to compute the amount1 delta Name Type Description amount1 int256 Amount of token1 corresponding to the passed liquidityDelta between the two prices","title":"getAmount1Delta"},{"location":"uniswap-v3-core/libraries/SwapMath/","text":"SwapMath Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick. computeSwapStep function computeSwapStep(uint160 sqrtRatioCurrentX96, uint160 sqrtRatioTargetX96, uint128 liquidity, int256 amountRemaining, uint24 feePips) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount) Computes the result of swapping some amount in, or amount out, given the parameters of the swap The fee, plus the amount in, will never exceed the amount remaining if the swap's amountSpecified is positive Name Type Description sqrtRatioCurrentX96 uint160 The current sqrt price of the pool sqrtRatioTargetX96 uint160 The price that cannot be exceeded, from which the direction of the swap is inferred liquidity uint128 The usable liquidity amountRemaining int256 How much input or output amount is remaining to be swapped in/out feePips uint24 The fee taken from the input amount, expressed in hundredths of a bip Name Type Description sqrtRatioNextX96 uint160 The price after swapping the amount in/out, not to exceed the price target amountIn uint256 The amount to be swapped in, of either token0 or token1, based on the direction of the swap amountOut uint256 The amount to be received, of either token0 or token1, based on the direction of the swap feeAmount uint256 The amount of input that will be taken as a fee","title":"SwapMath"},{"location":"uniswap-v3-core/libraries/SwapMath/#swapmath","text":"Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.","title":"SwapMath"},{"location":"uniswap-v3-core/libraries/SwapMath/#computeswapstep","text":"function computeSwapStep(uint160 sqrtRatioCurrentX96, uint160 sqrtRatioTargetX96, uint128 liquidity, int256 amountRemaining, uint24 feePips) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount) Computes the result of swapping some amount in, or amount out, given the parameters of the swap The fee, plus the amount in, will never exceed the amount remaining if the swap's amountSpecified is positive Name Type Description sqrtRatioCurrentX96 uint160 The current sqrt price of the pool sqrtRatioTargetX96 uint160 The price that cannot be exceeded, from which the direction of the swap is inferred liquidity uint128 The usable liquidity amountRemaining int256 How much input or output amount is remaining to be swapped in/out feePips uint24 The fee taken from the input amount, expressed in hundredths of a bip Name Type Description sqrtRatioNextX96 uint160 The price after swapping the amount in/out, not to exceed the price target amountIn uint256 The amount to be swapped in, of either token0 or token1, based on the direction of the swap amountOut uint256 The amount to be received, of either token0 or token1, based on the direction of the swap feeAmount uint256 The amount of input that will be taken as a fee","title":"computeSwapStep"},{"location":"uniswap-v3-core/libraries/Tick/","text":"Tick Contains functions for managing tick processes and relevant calculations Info struct Info { uint128 liquidityGross; int128 liquidityNet; uint256 feeGrowthOutside0X128; uint256 feeGrowthOutside1X128; int56 tickCumulativeOutside; uint160 secondsPerLiquidityOutsideX128; uint32 secondsOutside; bool initialized; } tickSpacingToMaxLiquidityPerTick function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) Derives max liquidity per tick from given tick spacing Executed within the pool constructor Name Type Description tickSpacing int24 The amount of required tick separation, realized in multiples of tickSpacing e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ... Name Type Description [0] uint128 The max liquidity per tick getFeeGrowthInside function getFeeGrowthInside(mapping(int24 => struct Tick.Info) self, int24 tickLower, int24 tickUpper, int24 tickCurrent, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) Retrieves fee growth data Name Type Description self mapping(int24 => struct Tick.Info) The mapping containing all tick information for initialized ticks tickLower int24 The lower tick boundary of the position tickUpper int24 The upper tick boundary of the position tickCurrent int24 The current tick feeGrowthGlobal0X128 uint256 The all-time global fee growth, per unit of liquidity, in token0 feeGrowthGlobal1X128 uint256 The all-time global fee growth, per unit of liquidity, in token1 Name Type Description feeGrowthInside0X128 uint256 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries feeGrowthInside1X128 uint256 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries update function update(mapping(int24 => struct Tick.Info) self, int24 tick, int24 tickCurrent, int128 liquidityDelta, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128, uint160 secondsPerLiquidityCumulativeX128, int56 tickCumulative, uint32 time, bool upper, uint128 maxLiquidity) internal returns (bool flipped) Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa Name Type Description self mapping(int24 => struct Tick.Info) The mapping containing all tick information for initialized ticks tick int24 The tick that will be updated tickCurrent int24 The current tick liquidityDelta int128 A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left) feeGrowthGlobal0X128 uint256 The all-time global fee growth, per unit of liquidity, in token0 feeGrowthGlobal1X128 uint256 The all-time global fee growth, per unit of liquidity, in token1 secondsPerLiquidityCumulativeX128 uint160 The all-time seconds per max(1, liquidity) of the pool tickCumulative int56 The tick * time elapsed since the pool was first initialized time uint32 The current block timestamp cast to a uint32 upper bool true for updating a position's upper tick, or false for updating a position's lower tick maxLiquidity uint128 The maximum liquidity allocation for a single tick Name Type Description flipped bool Whether the tick was flipped from initialized to uninitialized, or vice versa clear function clear(mapping(int24 => struct Tick.Info) self, int24 tick) internal Clears tick data Name Type Description self mapping(int24 => struct Tick.Info) The mapping containing all initialized tick information for initialized ticks tick int24 The tick that will be cleared cross function cross(mapping(int24 => struct Tick.Info) self, int24 tick, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128, uint160 secondsPerLiquidityCumulativeX128, int56 tickCumulative, uint32 time) internal returns (int128 liquidityNet) Transitions to next tick as needed by price movement Name Type Description self mapping(int24 => struct Tick.Info) The mapping containing all tick information for initialized ticks tick int24 The destination tick of the transition feeGrowthGlobal0X128 uint256 The all-time global fee growth, per unit of liquidity, in token0 feeGrowthGlobal1X128 uint256 The all-time global fee growth, per unit of liquidity, in token1 secondsPerLiquidityCumulativeX128 uint160 The current seconds per liquidity tickCumulative int56 The tick * time elapsed since the pool was first initialized time uint32 The current block.timestamp Name Type Description liquidityNet int128 The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)","title":"Tick"},{"location":"uniswap-v3-core/libraries/Tick/#tick","text":"Contains functions for managing tick processes and relevant calculations","title":"Tick"},{"location":"uniswap-v3-core/libraries/Tick/#info","text":"struct Info { uint128 liquidityGross; int128 liquidityNet; uint256 feeGrowthOutside0X128; uint256 feeGrowthOutside1X128; int56 tickCumulativeOutside; uint160 secondsPerLiquidityOutsideX128; uint32 secondsOutside; bool initialized; }","title":"Info"},{"location":"uniswap-v3-core/libraries/Tick/#tickspacingtomaxliquiditypertick","text":"function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) Derives max liquidity per tick from given tick spacing Executed within the pool constructor Name Type Description tickSpacing int24 The amount of required tick separation, realized in multiples of tickSpacing e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ... Name Type Description [0] uint128 The max liquidity per tick","title":"tickSpacingToMaxLiquidityPerTick"},{"location":"uniswap-v3-core/libraries/Tick/#getfeegrowthinside","text":"function getFeeGrowthInside(mapping(int24 => struct Tick.Info) self, int24 tickLower, int24 tickUpper, int24 tickCurrent, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) Retrieves fee growth data Name Type Description self mapping(int24 => struct Tick.Info) The mapping containing all tick information for initialized ticks tickLower int24 The lower tick boundary of the position tickUpper int24 The upper tick boundary of the position tickCurrent int24 The current tick feeGrowthGlobal0X128 uint256 The all-time global fee growth, per unit of liquidity, in token0 feeGrowthGlobal1X128 uint256 The all-time global fee growth, per unit of liquidity, in token1 Name Type Description feeGrowthInside0X128 uint256 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries feeGrowthInside1X128 uint256 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries","title":"getFeeGrowthInside"},{"location":"uniswap-v3-core/libraries/Tick/#update","text":"function update(mapping(int24 => struct Tick.Info) self, int24 tick, int24 tickCurrent, int128 liquidityDelta, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128, uint160 secondsPerLiquidityCumulativeX128, int56 tickCumulative, uint32 time, bool upper, uint128 maxLiquidity) internal returns (bool flipped) Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa Name Type Description self mapping(int24 => struct Tick.Info) The mapping containing all tick information for initialized ticks tick int24 The tick that will be updated tickCurrent int24 The current tick liquidityDelta int128 A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left) feeGrowthGlobal0X128 uint256 The all-time global fee growth, per unit of liquidity, in token0 feeGrowthGlobal1X128 uint256 The all-time global fee growth, per unit of liquidity, in token1 secondsPerLiquidityCumulativeX128 uint160 The all-time seconds per max(1, liquidity) of the pool tickCumulative int56 The tick * time elapsed since the pool was first initialized time uint32 The current block timestamp cast to a uint32 upper bool true for updating a position's upper tick, or false for updating a position's lower tick maxLiquidity uint128 The maximum liquidity allocation for a single tick Name Type Description flipped bool Whether the tick was flipped from initialized to uninitialized, or vice versa","title":"update"},{"location":"uniswap-v3-core/libraries/Tick/#clear","text":"function clear(mapping(int24 => struct Tick.Info) self, int24 tick) internal Clears tick data Name Type Description self mapping(int24 => struct Tick.Info) The mapping containing all initialized tick information for initialized ticks tick int24 The tick that will be cleared","title":"clear"},{"location":"uniswap-v3-core/libraries/Tick/#cross","text":"function cross(mapping(int24 => struct Tick.Info) self, int24 tick, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128, uint160 secondsPerLiquidityCumulativeX128, int56 tickCumulative, uint32 time) internal returns (int128 liquidityNet) Transitions to next tick as needed by price movement Name Type Description self mapping(int24 => struct Tick.Info) The mapping containing all tick information for initialized ticks tick int24 The destination tick of the transition feeGrowthGlobal0X128 uint256 The all-time global fee growth, per unit of liquidity, in token0 feeGrowthGlobal1X128 uint256 The all-time global fee growth, per unit of liquidity, in token1 secondsPerLiquidityCumulativeX128 uint160 The current seconds per liquidity tickCumulative int56 The tick * time elapsed since the pool was first initialized time uint32 The current block.timestamp Name Type Description liquidityNet int128 The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)","title":"cross"},{"location":"uniswap-v3-core/libraries/TickBitmap/","text":"TickBitmap Stores a packed mapping of tick index to its initialized state The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word. position function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) Computes the position in the mapping where the initialized bit for a tick lives Name Type Description tick int24 The tick for which to compute the position Name Type Description wordPos int16 The key in the mapping containing the word in which the bit is stored bitPos uint8 The bit position in the word where the flag is stored flipTick function flipTick(mapping(int16 => uint256) self, int24 tick, int24 tickSpacing) internal Flips the initialized state for a given tick from false to true, or vice versa Name Type Description self mapping(int16 => uint256) The mapping in which to flip the tick tick int24 The tick to flip tickSpacing int24 The spacing between usable ticks nextInitializedTickWithinOneWord function nextInitializedTickWithinOneWord(mapping(int16 => uint256) self, int24 tick, int24 tickSpacing, bool lte) internal view returns (int24 next, bool initialized) Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either to the left (less than or equal to) or right (greater than) of the given tick Name Type Description self mapping(int16 => uint256) The mapping in which to compute the next initialized tick tick int24 The starting tick tickSpacing int24 The spacing between usable ticks lte bool Whether to search for the next initialized tick to the left (less than or equal to the starting tick) Name Type Description next int24 The next initialized or uninitialized tick up to 256 ticks away from the current tick initialized bool Whether the next tick is initialized, as the function only searches within up to 256 ticks TickBitmap Stores a packed mapping of tick index to its initialized state The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word. position function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) Computes the position in the mapping where the initialized bit for a tick lives Name Type Description tick int24 The tick for which to compute the position Name Type Description wordPos int16 The key in the mapping containing the word in which the bit is stored bitPos uint8 The bit position in the word where the flag is stored flipTick function flipTick(mapping(int16 => uint256) self, int24 tick, int24 tickSpacing) internal Flips the initialized state for a given tick from false to true, or vice versa Name Type Description self mapping(int16 => uint256) The mapping in which to flip the tick tick int24 The tick to flip tickSpacing int24 The spacing between usable ticks nextInitializedTickWithinOneWord function nextInitializedTickWithinOneWord(mapping(int16 => uint256) self, int24 tick, int24 tickSpacing, bool lte) internal view returns (int24 next, bool initialized) Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either to the left (less than or equal to) or right (greater than) of the given tick Name Type Description self mapping(int16 => uint256) The mapping in which to compute the next initialized tick tick int24 The starting tick tickSpacing int24 The spacing between usable ticks lte bool Whether to search for the next initialized tick to the left (less than or equal to the starting tick) Name Type Description next int24 The next initialized or uninitialized tick up to 256 ticks away from the current tick initialized bool Whether the next tick is initialized, as the function only searches within up to 256 ticks","title":"TickBitmap"},{"location":"uniswap-v3-core/libraries/TickBitmap/#tickbitmap","text":"Stores a packed mapping of tick index to its initialized state The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.","title":"TickBitmap"},{"location":"uniswap-v3-core/libraries/TickBitmap/#position","text":"function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) Computes the position in the mapping where the initialized bit for a tick lives Name Type Description tick int24 The tick for which to compute the position Name Type Description wordPos int16 The key in the mapping containing the word in which the bit is stored bitPos uint8 The bit position in the word where the flag is stored","title":"position"},{"location":"uniswap-v3-core/libraries/TickBitmap/#fliptick","text":"function flipTick(mapping(int16 => uint256) self, int24 tick, int24 tickSpacing) internal Flips the initialized state for a given tick from false to true, or vice versa Name Type Description self mapping(int16 => uint256) The mapping in which to flip the tick tick int24 The tick to flip tickSpacing int24 The spacing between usable ticks","title":"flipTick"},{"location":"uniswap-v3-core/libraries/TickBitmap/#nextinitializedtickwithinoneword","text":"function nextInitializedTickWithinOneWord(mapping(int16 => uint256) self, int24 tick, int24 tickSpacing, bool lte) internal view returns (int24 next, bool initialized) Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either to the left (less than or equal to) or right (greater than) of the given tick Name Type Description self mapping(int16 => uint256) The mapping in which to compute the next initialized tick tick int24 The starting tick tickSpacing int24 The spacing between usable ticks lte bool Whether to search for the next initialized tick to the left (less than or equal to the starting tick) Name Type Description next int24 The next initialized or uninitialized tick up to 256 ticks away from the current tick initialized bool Whether the next tick is initialized, as the function only searches within up to 256 ticks","title":"nextInitializedTickWithinOneWord"},{"location":"uniswap-v3-core/libraries/TickBitmap/#tickbitmap_1","text":"Stores a packed mapping of tick index to its initialized state The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.","title":"TickBitmap"},{"location":"uniswap-v3-core/libraries/TickBitmap/#position_1","text":"function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) Computes the position in the mapping where the initialized bit for a tick lives Name Type Description tick int24 The tick for which to compute the position Name Type Description wordPos int16 The key in the mapping containing the word in which the bit is stored bitPos uint8 The bit position in the word where the flag is stored","title":"position"},{"location":"uniswap-v3-core/libraries/TickBitmap/#fliptick_1","text":"function flipTick(mapping(int16 => uint256) self, int24 tick, int24 tickSpacing) internal Flips the initialized state for a given tick from false to true, or vice versa Name Type Description self mapping(int16 => uint256) The mapping in which to flip the tick tick int24 The tick to flip tickSpacing int24 The spacing between usable ticks","title":"flipTick"},{"location":"uniswap-v3-core/libraries/TickBitmap/#nextinitializedtickwithinoneword_1","text":"function nextInitializedTickWithinOneWord(mapping(int16 => uint256) self, int24 tick, int24 tickSpacing, bool lte) internal view returns (int24 next, bool initialized) Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either to the left (less than or equal to) or right (greater than) of the given tick Name Type Description self mapping(int16 => uint256) The mapping in which to compute the next initialized tick tick int24 The starting tick tickSpacing int24 The spacing between usable ticks lte bool Whether to search for the next initialized tick to the left (less than or equal to the starting tick) Name Type Description next int24 The next initialized or uninitialized tick up to 256 ticks away from the current tick initialized bool Whether the next tick is initialized, as the function only searches within up to 256 ticks","title":"nextInitializedTickWithinOneWord"},{"location":"uniswap-v3-core/libraries/TickMath/","text":"TickMath Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports prices between 2 -128 and 2 128 MIN_TICK int24 MIN_TICK The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128 MAX_TICK int24 MAX_TICK The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128 MIN_SQRT_RATIO uint160 MIN_SQRT_RATIO The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK) MAX_SQRT_RATIO uint160 MAX_SQRT_RATIO The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK) getSqrtRatioAtTick function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) Calculates sqrt(1.0001^tick) * 2^96 Throws if |tick| > max tick Name Type Description tick int24 The input tick for the above formula Name Type Description sqrtPriceX96 uint160 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0) at the given tick getTickAtSqrtRatio function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may ever return. Name Type Description sqrtPriceX96 uint160 The sqrt ratio for which to compute the tick as a Q64.96 Name Type Description tick int24 The greatest tick for which the ratio is less than or equal to the input ratio","title":"TickMath"},{"location":"uniswap-v3-core/libraries/TickMath/#tickmath","text":"Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports prices between 2 -128 and 2 128","title":"TickMath"},{"location":"uniswap-v3-core/libraries/TickMath/#min_tick","text":"int24 MIN_TICK The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128","title":"MIN_TICK"},{"location":"uniswap-v3-core/libraries/TickMath/#max_tick","text":"int24 MAX_TICK The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128","title":"MAX_TICK"},{"location":"uniswap-v3-core/libraries/TickMath/#min_sqrt_ratio","text":"uint160 MIN_SQRT_RATIO The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)","title":"MIN_SQRT_RATIO"},{"location":"uniswap-v3-core/libraries/TickMath/#max_sqrt_ratio","text":"uint160 MAX_SQRT_RATIO The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)","title":"MAX_SQRT_RATIO"},{"location":"uniswap-v3-core/libraries/TickMath/#getsqrtratioattick","text":"function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) Calculates sqrt(1.0001^tick) * 2^96 Throws if |tick| > max tick Name Type Description tick int24 The input tick for the above formula Name Type Description sqrtPriceX96 uint160 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0) at the given tick","title":"getSqrtRatioAtTick"},{"location":"uniswap-v3-core/libraries/TickMath/#gettickatsqrtratio","text":"function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may ever return. Name Type Description sqrtPriceX96 uint160 The sqrt ratio for which to compute the tick as a Q64.96 Name Type Description tick int24 The greatest tick for which the ratio is less than or equal to the input ratio","title":"getTickAtSqrtRatio"},{"location":"uniswap-v3-core/libraries/TransferHelper/","text":"TransferHelper Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false safeTransfer function safeTransfer(address token, address to, uint256 value) internal Transfers tokens from msg.sender to a recipient Calls transfer on token contract, errors with TF if transfer fails Name Type Description token address The contract address of the token which will be transferred to address The recipient of the transfer value uint256 The value of the transfer TransferHelper Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false safeTransfer function safeTransfer(address token, address to, uint256 value) internal Transfers tokens from msg.sender to a recipient Calls transfer on token contract, errors with TF if transfer fails Name Type Description token address The contract address of the token which will be transferred to address The recipient of the transfer value uint256 The value of the transfer","title":"TransferHelper"},{"location":"uniswap-v3-core/libraries/TransferHelper/#transferhelper","text":"Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false","title":"TransferHelper"},{"location":"uniswap-v3-core/libraries/TransferHelper/#safetransfer","text":"function safeTransfer(address token, address to, uint256 value) internal Transfers tokens from msg.sender to a recipient Calls transfer on token contract, errors with TF if transfer fails Name Type Description token address The contract address of the token which will be transferred to address The recipient of the transfer value uint256 The value of the transfer","title":"safeTransfer"},{"location":"uniswap-v3-core/libraries/TransferHelper/#transferhelper_1","text":"Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false","title":"TransferHelper"},{"location":"uniswap-v3-core/libraries/TransferHelper/#safetransfer_1","text":"function safeTransfer(address token, address to, uint256 value) internal Transfers tokens from msg.sender to a recipient Calls transfer on token contract, errors with TF if transfer fails Name Type Description token address The contract address of the token which will be transferred to address The recipient of the transfer value uint256 The value of the transfer","title":"safeTransfer"},{"location":"uniswap-v3-core/libraries/UnsafeMath/","text":"UnsafeMath Contains methods that perform common math functions but do not do any overflow or underflow checks divRoundingUp function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) Returns ceil(x / y) division by 0 has unspecified behavior, and must be checked externally Name Type Description x uint256 The dividend y uint256 The divisor Name Type Description z uint256 The quotient, ceil(x / y) UnsafeMath Contains methods that perform common math functions but do not do any overflow or underflow checks divRoundingUp function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) Returns ceil(x / y) division by 0 has unspecified behavior, and must be checked externally Name Type Description x uint256 The dividend y uint256 The divisor Name Type Description z uint256 The quotient, ceil(x / y)","title":"UnsafeMath"},{"location":"uniswap-v3-core/libraries/UnsafeMath/#unsafemath","text":"Contains methods that perform common math functions but do not do any overflow or underflow checks","title":"UnsafeMath"},{"location":"uniswap-v3-core/libraries/UnsafeMath/#divroundingup","text":"function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) Returns ceil(x / y) division by 0 has unspecified behavior, and must be checked externally Name Type Description x uint256 The dividend y uint256 The divisor Name Type Description z uint256 The quotient, ceil(x / y)","title":"divRoundingUp"},{"location":"uniswap-v3-core/libraries/UnsafeMath/#unsafemath_1","text":"Contains methods that perform common math functions but do not do any overflow or underflow checks","title":"UnsafeMath"},{"location":"uniswap-v3-core/libraries/UnsafeMath/#divroundingup_1","text":"function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) Returns ceil(x / y) division by 0 has unspecified behavior, and must be checked externally Name Type Description x uint256 The dividend y uint256 The divisor Name Type Description z uint256 The quotient, ceil(x / y)","title":"divRoundingUp"}]}