{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Spatial/","text":"Spatial This library is intended to give Ethereum developers access to spatial functions to calculate geometric values and topologicial relationships on the EVM. It is a translation of Turf.js, a geospatial analysis library in Javascript. http://turfjs.org/ Code first developed by John IV (johnx25bd, Founder at Astral) at ETHParis 2019. earthRadius uint256 earthRadius in nanometers, piScaled uint256 piScaled approx ... will affect precision sinDegrees function sinDegrees(uint256 _degrees) public pure returns (int256) sinNanodegrees function sinNanodegrees(uint256 _nanodegrees) public pure returns (int256) cosDegrees function cosDegrees(uint256 _degrees) public pure returns (int256) cosNanodegrees function cosNanodegrees(uint256 _nanodegrees) public pure returns (int256) isPolygon function isPolygon(int256[2][] _coordinates) public pure returns (bool) Checks to make sure first and last coordinates are the same. Otherwise it is a linestring. isLine function isLine(int256[2][] _coordinates) public pure returns (bool) sqrt function sqrt(int256 _x) public pure returns (uint256 y_) Babylonian method of finding square root, From https://ethereum.stackexchange.com/questions/2910/can-i-square-root-in-solidity degreesToNanoradians function degreesToNanoradians(uint256 _degrees) public pure returns (uint256 radians_) nanodegreesToNanoradians function nanodegreesToNanoradians(uint256 _nanodegrees) public pure returns (uint256 radians_) nanoradiansToDegrees function nanoradiansToDegrees(uint256 _nanoradians) public pure returns (uint256 degrees_) earthNanoradiansToNanometers function earthNanoradiansToNanometers(uint256 _nanoradians) public pure returns (uint256 nanometers_) earthNanodegreesToNanometers function earthNanodegreesToNanometers(uint256 _nanodegrees) public pure returns (uint256 nanometers_) distance function distance(int256[2] ptA, int256[2] ptB) public view returns (uint256 distanceNanometers_) area function area(int256[2][] _coordinates) public pure returns (uint256 area_) @notice // https://www.mathopenref.com/coordpolygonarea.html Only accepts simple polygons, not multigeometry polygons centroid function centroid(int256[2][] _coordinates) public pure returns (int256[2]) Returns centroid of group of points or boundingBox function boundingBox(int256[2][] _coordinates) public pure returns (int256[2][2]) Returns bounding box of geometry as [[minLon, minLat], [maxLon, maxLat]] length function length(int256[2][] _coordinates) public view returns (uint256 length_) perimeter function perimeter(int256[2][] _coordinates) public view returns (uint256 perimeter_) distanceBetweenAzimuthalEquidistantProjectedPoints function distanceBetweenAzimuthalEquidistantProjectedPoints(uint256[2] ptA, uint256[2] ptB) public view returns (uint256) bearingFromAzimuthalEquidistantProjectedPoints function bearingFromAzimuthalEquidistantProjectedPoints(uint256[2] ptA, uint256[2] ptB) public view returns (uint256) boundingBoxBuffer function boundingBoxBuffer(int256[2] _point, int256 _buffer) public pure returns (int256[2][2]) pointInBbox function pointInBbox(int256[2] _point, int256[2][2] _bbox) public pure returns (bool ptInsideBbox_) pointInPolygon function pointInPolygon(int256[2] _point, int256[] _polygon) public pure returns (bool)","title":"Spatial"},{"location":"Spatial/#spatial","text":"This library is intended to give Ethereum developers access to spatial functions to calculate geometric values and topologicial relationships on the EVM. It is a translation of Turf.js, a geospatial analysis library in Javascript. http://turfjs.org/ Code first developed by John IV (johnx25bd, Founder at Astral) at ETHParis 2019.","title":"Spatial"},{"location":"Spatial/#earthradius","text":"uint256 earthRadius in nanometers,","title":"earthRadius"},{"location":"Spatial/#piscaled","text":"uint256 piScaled approx ... will affect precision","title":"piScaled"},{"location":"Spatial/#sindegrees","text":"function sinDegrees(uint256 _degrees) public pure returns (int256)","title":"sinDegrees"},{"location":"Spatial/#sinnanodegrees","text":"function sinNanodegrees(uint256 _nanodegrees) public pure returns (int256)","title":"sinNanodegrees"},{"location":"Spatial/#cosdegrees","text":"function cosDegrees(uint256 _degrees) public pure returns (int256)","title":"cosDegrees"},{"location":"Spatial/#cosnanodegrees","text":"function cosNanodegrees(uint256 _nanodegrees) public pure returns (int256)","title":"cosNanodegrees"},{"location":"Spatial/#ispolygon","text":"function isPolygon(int256[2][] _coordinates) public pure returns (bool) Checks to make sure first and last coordinates are the same. Otherwise it is a linestring.","title":"isPolygon"},{"location":"Spatial/#isline","text":"function isLine(int256[2][] _coordinates) public pure returns (bool)","title":"isLine"},{"location":"Spatial/#sqrt","text":"function sqrt(int256 _x) public pure returns (uint256 y_) Babylonian method of finding square root, From https://ethereum.stackexchange.com/questions/2910/can-i-square-root-in-solidity","title":"sqrt"},{"location":"Spatial/#degreestonanoradians","text":"function degreesToNanoradians(uint256 _degrees) public pure returns (uint256 radians_)","title":"degreesToNanoradians"},{"location":"Spatial/#nanodegreestonanoradians","text":"function nanodegreesToNanoradians(uint256 _nanodegrees) public pure returns (uint256 radians_)","title":"nanodegreesToNanoradians"},{"location":"Spatial/#nanoradianstodegrees","text":"function nanoradiansToDegrees(uint256 _nanoradians) public pure returns (uint256 degrees_)","title":"nanoradiansToDegrees"},{"location":"Spatial/#earthnanoradianstonanometers","text":"function earthNanoradiansToNanometers(uint256 _nanoradians) public pure returns (uint256 nanometers_)","title":"earthNanoradiansToNanometers"},{"location":"Spatial/#earthnanodegreestonanometers","text":"function earthNanodegreesToNanometers(uint256 _nanodegrees) public pure returns (uint256 nanometers_)","title":"earthNanodegreesToNanometers"},{"location":"Spatial/#distance","text":"function distance(int256[2] ptA, int256[2] ptB) public view returns (uint256 distanceNanometers_)","title":"distance"},{"location":"Spatial/#area","text":"function area(int256[2][] _coordinates) public pure returns (uint256 area_) @notice // https://www.mathopenref.com/coordpolygonarea.html Only accepts simple polygons, not multigeometry polygons","title":"area"},{"location":"Spatial/#centroid","text":"function centroid(int256[2][] _coordinates) public pure returns (int256[2]) Returns centroid of group of points or","title":"centroid"},{"location":"Spatial/#boundingbox","text":"function boundingBox(int256[2][] _coordinates) public pure returns (int256[2][2]) Returns bounding box of geometry as [[minLon, minLat], [maxLon, maxLat]]","title":"boundingBox"},{"location":"Spatial/#length","text":"function length(int256[2][] _coordinates) public view returns (uint256 length_)","title":"length"},{"location":"Spatial/#perimeter","text":"function perimeter(int256[2][] _coordinates) public view returns (uint256 perimeter_)","title":"perimeter"},{"location":"Spatial/#distancebetweenazimuthalequidistantprojectedpoints","text":"function distanceBetweenAzimuthalEquidistantProjectedPoints(uint256[2] ptA, uint256[2] ptB) public view returns (uint256)","title":"distanceBetweenAzimuthalEquidistantProjectedPoints"},{"location":"Spatial/#bearingfromazimuthalequidistantprojectedpoints","text":"function bearingFromAzimuthalEquidistantProjectedPoints(uint256[2] ptA, uint256[2] ptB) public view returns (uint256)","title":"bearingFromAzimuthalEquidistantProjectedPoints"},{"location":"Spatial/#boundingboxbuffer","text":"function boundingBoxBuffer(int256[2] _point, int256 _buffer) public pure returns (int256[2][2])","title":"boundingBoxBuffer"},{"location":"Spatial/#pointinbbox","text":"function pointInBbox(int256[2] _point, int256[2][2] _bbox) public pure returns (bool ptInsideBbox_)","title":"pointInBbox"},{"location":"Spatial/#pointinpolygon","text":"function pointInPolygon(int256[2] _point, int256[] _polygon) public pure returns (bool)","title":"pointInPolygon"},{"location":"Trigonometry/","text":"Trigonometry Solidity library offering the functionality of basic trigonometry functions with both input and output being integer approximated. This is useful since at the moment no floating/fixed point math can happen in solidity, and this should be (?) cheaper than the actual operations using floating point if and when they are implemented. The implementation is based off Dave Dribin's trigint C library http://www.dribin.org/dave/trigint/ Which in turn is based from a now deleted article which can be found in the internet wayback machine: http://web.archive.org/web/20120301144605/http://www.dattalo.com/technical/software/pic/picsine.html Original author Lefteris Karapetsas INDEX_WIDTH uint256 INDEX_WIDTH Table index into the trigonometric table INTERP_WIDTH uint256 INTERP_WIDTH Interpolation between successive entries in the tables INDEX_OFFSET uint256 INDEX_OFFSET INTERP_OFFSET uint256 INTERP_OFFSET ANGLES_IN_CYCLE uint16 ANGLES_IN_CYCLE QUADRANT_HIGH_MASK uint16 QUADRANT_HIGH_MASK QUADRANT_LOW_MASK uint16 QUADRANT_LOW_MASK SINE_TABLE_SIZE uint256 SINE_TABLE_SIZE entry_bytes uint8 entry_bytes Constant sine lookup table generated by gen_tables.py We have no other choice but this since constant arrays don't yet exist sin_table bytes sin_table bits function bits(uint256 _value, uint256 _width, uint256 _offset) internal pure returns (uint256) Convenience function to apply a mask on an integer to extract a certain number of bits. Using exponents since solidity still does not support shifting. Name Type Description _value uint256 The integer whose bits we want to get _width uint256 The width of the bits (in bits) we want to extract _offset uint256 The offset of the bits (in bits) we want to extract Name Type Description [0] uint256 An integer containing _width bits of _value starting at the _offset bit sin_table_lookup function sin_table_lookup(uint256 index) internal pure returns (uint16) sin function sin(uint16 _angle) public pure returns (int256) Return the sine of an integer approximated angle as a signed 16-bit integer. Name Type Description _angle uint16 A 16-bit angle. This divides the circle into 16384 angle units, instead of the standard 360 degrees. Name Type Description [0] int256 The sine result as a number in the range -32767 to 32767. cos function cos(uint16 _angle) public pure returns (int256) Return the cos of an integer approximated angle. It functions just like the sin() method but uses the trigonometric identity sin(x + pi/2) = cos(x) to quickly calculate the cos.","title":"Trigonometry"},{"location":"Trigonometry/#trigonometry","text":"Solidity library offering the functionality of basic trigonometry functions with both input and output being integer approximated. This is useful since at the moment no floating/fixed point math can happen in solidity, and this should be (?) cheaper than the actual operations using floating point if and when they are implemented. The implementation is based off Dave Dribin's trigint C library http://www.dribin.org/dave/trigint/ Which in turn is based from a now deleted article which can be found in the internet wayback machine: http://web.archive.org/web/20120301144605/http://www.dattalo.com/technical/software/pic/picsine.html Original author Lefteris Karapetsas","title":"Trigonometry"},{"location":"Trigonometry/#index_width","text":"uint256 INDEX_WIDTH Table index into the trigonometric table","title":"INDEX_WIDTH"},{"location":"Trigonometry/#interp_width","text":"uint256 INTERP_WIDTH Interpolation between successive entries in the tables","title":"INTERP_WIDTH"},{"location":"Trigonometry/#index_offset","text":"uint256 INDEX_OFFSET","title":"INDEX_OFFSET"},{"location":"Trigonometry/#interp_offset","text":"uint256 INTERP_OFFSET","title":"INTERP_OFFSET"},{"location":"Trigonometry/#angles_in_cycle","text":"uint16 ANGLES_IN_CYCLE","title":"ANGLES_IN_CYCLE"},{"location":"Trigonometry/#quadrant_high_mask","text":"uint16 QUADRANT_HIGH_MASK","title":"QUADRANT_HIGH_MASK"},{"location":"Trigonometry/#quadrant_low_mask","text":"uint16 QUADRANT_LOW_MASK","title":"QUADRANT_LOW_MASK"},{"location":"Trigonometry/#sine_table_size","text":"uint256 SINE_TABLE_SIZE","title":"SINE_TABLE_SIZE"},{"location":"Trigonometry/#entry_bytes","text":"uint8 entry_bytes Constant sine lookup table generated by gen_tables.py We have no other choice but this since constant arrays don't yet exist","title":"entry_bytes"},{"location":"Trigonometry/#sin_table","text":"bytes sin_table","title":"sin_table"},{"location":"Trigonometry/#bits","text":"function bits(uint256 _value, uint256 _width, uint256 _offset) internal pure returns (uint256) Convenience function to apply a mask on an integer to extract a certain number of bits. Using exponents since solidity still does not support shifting. Name Type Description _value uint256 The integer whose bits we want to get _width uint256 The width of the bits (in bits) we want to extract _offset uint256 The offset of the bits (in bits) we want to extract Name Type Description [0] uint256 An integer containing _width bits of _value starting at the _offset bit","title":"bits"},{"location":"Trigonometry/#sin_table_lookup","text":"function sin_table_lookup(uint256 index) internal pure returns (uint16)","title":"sin_table_lookup"},{"location":"Trigonometry/#sin","text":"function sin(uint16 _angle) public pure returns (int256) Return the sine of an integer approximated angle as a signed 16-bit integer. Name Type Description _angle uint16 A 16-bit angle. This divides the circle into 16384 angle units, instead of the standard 360 degrees. Name Type Description [0] int256 The sine result as a number in the range -32767 to 32767.","title":"sin"},{"location":"Trigonometry/#cos","text":"function cos(uint16 _angle) public pure returns (int256) Return the cos of an integer approximated angle. It functions just like the sin() method but uses the trigonometric identity sin(x + pi/2) = cos(x) to quickly calculate the cos.","title":"cos"}]}