{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"PRBMath/","text":"PRBMath__MulDivFixedPointOverflow error PRBMath__MulDivFixedPointOverflow(uint256 prod1) Emitted when the result overflows uint256. PRBMath__MulDivOverflow error PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator) Emitted when the result overflows uint256. PRBMath__MulDivSignedInputTooSmall error PRBMath__MulDivSignedInputTooSmall() Emitted when one of the inputs is type(int256).min. PRBMath__MulDivSignedOverflow error PRBMath__MulDivSignedOverflow(uint256 rAbs) Emitted when the intermediary absolute result overflows int256. PRBMathSD59x18__AbsInputTooSmall error PRBMathSD59x18__AbsInputTooSmall() Emitted when the input is MIN_SD59x18. PRBMathSD59x18__CeilOverflow error PRBMathSD59x18__CeilOverflow(int256 x) Emitted when ceiling a number overflows SD59x18. PRBMathSD59x18__DivInputTooSmall error PRBMathSD59x18__DivInputTooSmall() Emitted when one of the inputs is MIN_SD59x18. PRBMathSD59x18__DivOverflow error PRBMathSD59x18__DivOverflow(uint256 rAbs) Emitted when one of the intermediary unsigned results overflows SD59x18. PRBMathSD59x18__ExpInputTooBig error PRBMathSD59x18__ExpInputTooBig(int256 x) Emitted when the input is greater than 133.084258667509499441. PRBMathSD59x18__Exp2InputTooBig error PRBMathSD59x18__Exp2InputTooBig(int256 x) Emitted when the input is greater than 192. PRBMathSD59x18__FloorUnderflow error PRBMathSD59x18__FloorUnderflow(int256 x) Emitted when flooring a number underflows SD59x18. PRBMathSD59x18__FromIntOverflow error PRBMathSD59x18__FromIntOverflow(int256 x) Emitted when converting a basic integer to the fixed-point format overflows SD59x18. PRBMathSD59x18__FromIntUnderflow error PRBMathSD59x18__FromIntUnderflow(int256 x) Emitted when converting a basic integer to the fixed-point format underflows SD59x18. PRBMathSD59x18__GmNegativeProduct error PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y) Emitted when the product of the inputs is negative. PRBMathSD59x18__GmOverflow error PRBMathSD59x18__GmOverflow(int256 x, int256 y) Emitted when multiplying the inputs overflows SD59x18. PRBMathSD59x18__LogInputTooSmall error PRBMathSD59x18__LogInputTooSmall(int256 x) Emitted when the input is less than or equal to zero. PRBMathSD59x18__MulInputTooSmall error PRBMathSD59x18__MulInputTooSmall() Emitted when one of the inputs is MIN_SD59x18. PRBMathSD59x18__MulOverflow error PRBMathSD59x18__MulOverflow(uint256 rAbs) Emitted when the intermediary absolute result overflows SD59x18. PRBMathSD59x18__PowuOverflow error PRBMathSD59x18__PowuOverflow(uint256 rAbs) Emitted when the intermediary absolute result overflows SD59x18. PRBMathSD59x18__SqrtNegativeInput error PRBMathSD59x18__SqrtNegativeInput(int256 x) Emitted when the input is negative. PRBMathSD59x18__SqrtOverflow error PRBMathSD59x18__SqrtOverflow(int256 x) Emitted when the calculating the square root overflows SD59x18. PRBMathUD60x18__AddOverflow error PRBMathUD60x18__AddOverflow(uint256 x, uint256 y) Emitted when addition overflows UD60x18. PRBMathUD60x18__CeilOverflow error PRBMathUD60x18__CeilOverflow(uint256 x) Emitted when ceiling a number overflows UD60x18. PRBMathUD60x18__ExpInputTooBig error PRBMathUD60x18__ExpInputTooBig(uint256 x) Emitted when the input is greater than 133.084258667509499441. PRBMathUD60x18__Exp2InputTooBig error PRBMathUD60x18__Exp2InputTooBig(uint256 x) Emitted when the input is greater than 192. PRBMathUD60x18__FromUintOverflow error PRBMathUD60x18__FromUintOverflow(uint256 x) Emitted when converting a basic integer to the fixed-point format format overflows UD60x18. PRBMathUD60x18__GmOverflow error PRBMathUD60x18__GmOverflow(uint256 x, uint256 y) Emitted when multiplying the inputs overflows UD60x18. PRBMathUD60x18__LogInputTooSmall error PRBMathUD60x18__LogInputTooSmall(uint256 x) Emitted when the input is less than 1. PRBMathUD60x18__SqrtOverflow error PRBMathUD60x18__SqrtOverflow(uint256 x) Emitted when the calculating the square root overflows UD60x18. PRBMathUD60x18__SubUnderflow error PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y) Emitted when subtraction underflows UD60x18. PRBMath Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point representation. When it does not, it is explicitly mentioned in the NatSpec documentation. SD59x18 struct SD59x18 { int256 value; } UD60x18 struct UD60x18 { uint256 value; } SCALE uint256 SCALE How many trailing decimals can be represented. SCALE_LPOTD uint256 SCALE_LPOTD Largest power of two divisor of SCALE. SCALE_INVERSE uint256 SCALE_INVERSE SCALE inverted mod 2^256. exp2 function exp2(uint256 x) internal pure returns (uint256 result) Calculates the binary exponent of x using the binary fraction method. Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693. Name Type Description x uint256 The exponent as an unsigned 192.64-bit fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number. mostSignificantBit function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) Finds the zero-based index of the first one in the binary representation of x. See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set Name Type Description x uint256 The uint256 number for which to find the index of the most significant bit. Name Type Description msb uint256 The index of the most significant bit as an uint256. mulDiv function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) Calculates floor(x*y\u00f7denominator) with full precision. _Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv. Requirements: - The denominator cannot be zero. - The result must fit within uint256. Caveats: - This function does not work with fixed-point numbers._ Name Type Description x uint256 The multiplicand as an uint256. y uint256 The multiplier as an uint256. denominator uint256 The divisor as an uint256. Name Type Description result uint256 The result as an uint256. mulDivFixedPoint function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) Calculates floor(x*y\u00f71e18) with full precision. _Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of being rounded to 1e-18. See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717. Requirements: - The result must fit within uint256. Caveats: - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works. - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations: 1. x * y = type(uint256).max * SCALE 2. (x * y) % SCALE >= SCALE / 2_ Name Type Description x uint256 The multiplicand as an unsigned 60.18-decimal fixed-point number. y uint256 The multiplier as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number. mulDivSigned function mulDivSigned(int256 x, int256 y, int256 denominator) internal pure returns (int256 result) Calculates floor(x*y\u00f7denominator) with full precision. _An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately. Requirements: - None of the inputs can be type(int256).min. - The result must fit within int256._ Name Type Description x int256 The multiplicand as an int256. y int256 The multiplier as an int256. denominator int256 The divisor as an int256. Name Type Description result int256 The result as an int256. sqrt function sqrt(uint256 x) internal pure returns (uint256 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Caveats: - This function does not work with fixed-point numbers._ Name Type Description x uint256 The uint256 number for which to calculate the square root. Name Type Description result uint256 The result as an uint256.","title":"PRBMath"},{"location":"PRBMath/#prbmath__muldivfixedpointoverflow","text":"error PRBMath__MulDivFixedPointOverflow(uint256 prod1) Emitted when the result overflows uint256.","title":"PRBMath__MulDivFixedPointOverflow"},{"location":"PRBMath/#prbmath__muldivoverflow","text":"error PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator) Emitted when the result overflows uint256.","title":"PRBMath__MulDivOverflow"},{"location":"PRBMath/#prbmath__muldivsignedinputtoosmall","text":"error PRBMath__MulDivSignedInputTooSmall() Emitted when one of the inputs is type(int256).min.","title":"PRBMath__MulDivSignedInputTooSmall"},{"location":"PRBMath/#prbmath__muldivsignedoverflow","text":"error PRBMath__MulDivSignedOverflow(uint256 rAbs) Emitted when the intermediary absolute result overflows int256.","title":"PRBMath__MulDivSignedOverflow"},{"location":"PRBMath/#prbmathsd59x18__absinputtoosmall","text":"error PRBMathSD59x18__AbsInputTooSmall() Emitted when the input is MIN_SD59x18.","title":"PRBMathSD59x18__AbsInputTooSmall"},{"location":"PRBMath/#prbmathsd59x18__ceiloverflow","text":"error PRBMathSD59x18__CeilOverflow(int256 x) Emitted when ceiling a number overflows SD59x18.","title":"PRBMathSD59x18__CeilOverflow"},{"location":"PRBMath/#prbmathsd59x18__divinputtoosmall","text":"error PRBMathSD59x18__DivInputTooSmall() Emitted when one of the inputs is MIN_SD59x18.","title":"PRBMathSD59x18__DivInputTooSmall"},{"location":"PRBMath/#prbmathsd59x18__divoverflow","text":"error PRBMathSD59x18__DivOverflow(uint256 rAbs) Emitted when one of the intermediary unsigned results overflows SD59x18.","title":"PRBMathSD59x18__DivOverflow"},{"location":"PRBMath/#prbmathsd59x18__expinputtoobig","text":"error PRBMathSD59x18__ExpInputTooBig(int256 x) Emitted when the input is greater than 133.084258667509499441.","title":"PRBMathSD59x18__ExpInputTooBig"},{"location":"PRBMath/#prbmathsd59x18__exp2inputtoobig","text":"error PRBMathSD59x18__Exp2InputTooBig(int256 x) Emitted when the input is greater than 192.","title":"PRBMathSD59x18__Exp2InputTooBig"},{"location":"PRBMath/#prbmathsd59x18__floorunderflow","text":"error PRBMathSD59x18__FloorUnderflow(int256 x) Emitted when flooring a number underflows SD59x18.","title":"PRBMathSD59x18__FloorUnderflow"},{"location":"PRBMath/#prbmathsd59x18__fromintoverflow","text":"error PRBMathSD59x18__FromIntOverflow(int256 x) Emitted when converting a basic integer to the fixed-point format overflows SD59x18.","title":"PRBMathSD59x18__FromIntOverflow"},{"location":"PRBMath/#prbmathsd59x18__fromintunderflow","text":"error PRBMathSD59x18__FromIntUnderflow(int256 x) Emitted when converting a basic integer to the fixed-point format underflows SD59x18.","title":"PRBMathSD59x18__FromIntUnderflow"},{"location":"PRBMath/#prbmathsd59x18__gmnegativeproduct","text":"error PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y) Emitted when the product of the inputs is negative.","title":"PRBMathSD59x18__GmNegativeProduct"},{"location":"PRBMath/#prbmathsd59x18__gmoverflow","text":"error PRBMathSD59x18__GmOverflow(int256 x, int256 y) Emitted when multiplying the inputs overflows SD59x18.","title":"PRBMathSD59x18__GmOverflow"},{"location":"PRBMath/#prbmathsd59x18__loginputtoosmall","text":"error PRBMathSD59x18__LogInputTooSmall(int256 x) Emitted when the input is less than or equal to zero.","title":"PRBMathSD59x18__LogInputTooSmall"},{"location":"PRBMath/#prbmathsd59x18__mulinputtoosmall","text":"error PRBMathSD59x18__MulInputTooSmall() Emitted when one of the inputs is MIN_SD59x18.","title":"PRBMathSD59x18__MulInputTooSmall"},{"location":"PRBMath/#prbmathsd59x18__muloverflow","text":"error PRBMathSD59x18__MulOverflow(uint256 rAbs) Emitted when the intermediary absolute result overflows SD59x18.","title":"PRBMathSD59x18__MulOverflow"},{"location":"PRBMath/#prbmathsd59x18__powuoverflow","text":"error PRBMathSD59x18__PowuOverflow(uint256 rAbs) Emitted when the intermediary absolute result overflows SD59x18.","title":"PRBMathSD59x18__PowuOverflow"},{"location":"PRBMath/#prbmathsd59x18__sqrtnegativeinput","text":"error PRBMathSD59x18__SqrtNegativeInput(int256 x) Emitted when the input is negative.","title":"PRBMathSD59x18__SqrtNegativeInput"},{"location":"PRBMath/#prbmathsd59x18__sqrtoverflow","text":"error PRBMathSD59x18__SqrtOverflow(int256 x) Emitted when the calculating the square root overflows SD59x18.","title":"PRBMathSD59x18__SqrtOverflow"},{"location":"PRBMath/#prbmathud60x18__addoverflow","text":"error PRBMathUD60x18__AddOverflow(uint256 x, uint256 y) Emitted when addition overflows UD60x18.","title":"PRBMathUD60x18__AddOverflow"},{"location":"PRBMath/#prbmathud60x18__ceiloverflow","text":"error PRBMathUD60x18__CeilOverflow(uint256 x) Emitted when ceiling a number overflows UD60x18.","title":"PRBMathUD60x18__CeilOverflow"},{"location":"PRBMath/#prbmathud60x18__expinputtoobig","text":"error PRBMathUD60x18__ExpInputTooBig(uint256 x) Emitted when the input is greater than 133.084258667509499441.","title":"PRBMathUD60x18__ExpInputTooBig"},{"location":"PRBMath/#prbmathud60x18__exp2inputtoobig","text":"error PRBMathUD60x18__Exp2InputTooBig(uint256 x) Emitted when the input is greater than 192.","title":"PRBMathUD60x18__Exp2InputTooBig"},{"location":"PRBMath/#prbmathud60x18__fromuintoverflow","text":"error PRBMathUD60x18__FromUintOverflow(uint256 x) Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.","title":"PRBMathUD60x18__FromUintOverflow"},{"location":"PRBMath/#prbmathud60x18__gmoverflow","text":"error PRBMathUD60x18__GmOverflow(uint256 x, uint256 y) Emitted when multiplying the inputs overflows UD60x18.","title":"PRBMathUD60x18__GmOverflow"},{"location":"PRBMath/#prbmathud60x18__loginputtoosmall","text":"error PRBMathUD60x18__LogInputTooSmall(uint256 x) Emitted when the input is less than 1.","title":"PRBMathUD60x18__LogInputTooSmall"},{"location":"PRBMath/#prbmathud60x18__sqrtoverflow","text":"error PRBMathUD60x18__SqrtOverflow(uint256 x) Emitted when the calculating the square root overflows UD60x18.","title":"PRBMathUD60x18__SqrtOverflow"},{"location":"PRBMath/#prbmathud60x18__subunderflow","text":"error PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y) Emitted when subtraction underflows UD60x18.","title":"PRBMathUD60x18__SubUnderflow"},{"location":"PRBMath/#prbmath","text":"Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point representation. When it does not, it is explicitly mentioned in the NatSpec documentation.","title":"PRBMath"},{"location":"PRBMath/#sd59x18","text":"struct SD59x18 { int256 value; }","title":"SD59x18"},{"location":"PRBMath/#ud60x18","text":"struct UD60x18 { uint256 value; }","title":"UD60x18"},{"location":"PRBMath/#scale","text":"uint256 SCALE How many trailing decimals can be represented.","title":"SCALE"},{"location":"PRBMath/#scale_lpotd","text":"uint256 SCALE_LPOTD Largest power of two divisor of SCALE.","title":"SCALE_LPOTD"},{"location":"PRBMath/#scale_inverse","text":"uint256 SCALE_INVERSE SCALE inverted mod 2^256.","title":"SCALE_INVERSE"},{"location":"PRBMath/#exp2","text":"function exp2(uint256 x) internal pure returns (uint256 result) Calculates the binary exponent of x using the binary fraction method. Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693. Name Type Description x uint256 The exponent as an unsigned 192.64-bit fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number.","title":"exp2"},{"location":"PRBMath/#mostsignificantbit","text":"function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) Finds the zero-based index of the first one in the binary representation of x. See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set Name Type Description x uint256 The uint256 number for which to find the index of the most significant bit. Name Type Description msb uint256 The index of the most significant bit as an uint256.","title":"mostSignificantBit"},{"location":"PRBMath/#muldiv","text":"function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) Calculates floor(x*y\u00f7denominator) with full precision. _Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv. Requirements: - The denominator cannot be zero. - The result must fit within uint256. Caveats: - This function does not work with fixed-point numbers._ Name Type Description x uint256 The multiplicand as an uint256. y uint256 The multiplier as an uint256. denominator uint256 The divisor as an uint256. Name Type Description result uint256 The result as an uint256.","title":"mulDiv"},{"location":"PRBMath/#muldivfixedpoint","text":"function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) Calculates floor(x*y\u00f71e18) with full precision. _Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of being rounded to 1e-18. See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717. Requirements: - The result must fit within uint256. Caveats: - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works. - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations: 1. x * y = type(uint256).max * SCALE 2. (x * y) % SCALE >= SCALE / 2_ Name Type Description x uint256 The multiplicand as an unsigned 60.18-decimal fixed-point number. y uint256 The multiplier as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number.","title":"mulDivFixedPoint"},{"location":"PRBMath/#muldivsigned","text":"function mulDivSigned(int256 x, int256 y, int256 denominator) internal pure returns (int256 result) Calculates floor(x*y\u00f7denominator) with full precision. _An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately. Requirements: - None of the inputs can be type(int256).min. - The result must fit within int256._ Name Type Description x int256 The multiplicand as an int256. y int256 The multiplier as an int256. denominator int256 The divisor as an int256. Name Type Description result int256 The result as an int256.","title":"mulDivSigned"},{"location":"PRBMath/#sqrt","text":"function sqrt(uint256 x) internal pure returns (uint256 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Caveats: - This function does not work with fixed-point numbers._ Name Type Description x uint256 The uint256 number for which to calculate the square root. Name Type Description result uint256 The result as an uint256.","title":"sqrt"},{"location":"PRBMathSD59x18/","text":"PRBMathSD59x18 Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18 trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type int256. LOG2_E int256 LOG2_E log2(e) as a signed 59.18-decimal fixed-point number. HALF_SCALE int256 HALF_SCALE Half the SCALE number. MAX_SD59x18 int256 MAX_SD59x18 The maximum value a signed 59.18-decimal fixed-point number can have. MAX_WHOLE_SD59x18 int256 MAX_WHOLE_SD59x18 The maximum whole value a signed 59.18-decimal fixed-point number can have. MIN_SD59x18 int256 MIN_SD59x18 The minimum value a signed 59.18-decimal fixed-point number can have. MIN_WHOLE_SD59x18 int256 MIN_WHOLE_SD59x18 The minimum whole value a signed 59.18-decimal fixed-point number can have. SCALE int256 SCALE How many trailing decimals can be represented. abs function abs(int256 x) internal pure returns (int256 result) Calculate the absolute value of x. Requirements: - x must be greater than MIN_SD59x18. Name Type Description x int256 The number to calculate the absolute value for. avg function avg(int256 x, int256 y) internal pure returns (int256 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x int256 The first operand as a signed 59.18-decimal fixed-point number. y int256 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The arithmetic average as a signed 59.18-decimal fixed-point number. ceil function ceil(int256 x) internal pure returns (int256 result) Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_SD59x18._ Name Type Description x int256 The signed 59.18-decimal fixed-point number to ceil. div function div(int256 x, int256 y) internal pure returns (int256 result) Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers. Works by computing the signs and the absolute values separately. Requirements: - All from \"PRBMath.mulDiv\". - None of the inputs can be MIN_SD59x18. - The denominator cannot be zero. - The result must fit within int256. Caveats: - All from \"PRBMath.mulDiv\"._ Name Type Description x int256 The numerator as a signed 59.18-decimal fixed-point number. y int256 The denominator as a signed 59.18-decimal fixed-point number. e function e() internal pure returns (int256 result) Returns Euler's number as a signed 59.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._ exp function exp(int256 x) internal pure returns (int256 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 133.084258667509499441. Caveats: - All from \"exp2\". - For any x less than -41.446531673892822322, the result is zero._ Name Type Description x int256 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number. exp2 function exp2(int256 x) internal pure returns (int256 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_SD59x18. Caveats: - For any x less than -59.794705707972522261, the result is zero._ Name Type Description x int256 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number. floor function floor(int256 x) internal pure returns (int256 result) Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be greater than or equal to MIN_WHOLE_SD59x18._ Name Type Description x int256 The signed 59.18-decimal fixed-point number to floor. frac function frac(int256 x) internal pure returns (int256 result) Yields the excess beyond the floor of x for positive numbers and the part of the number to the right of the radix point for negative numbers. Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part Name Type Description x int256 The signed 59.18-decimal fixed-point number to get the fractional part of. fromInt function fromInt(int256 x) internal pure returns (int256 result) Converts a number from basic integer form to signed 59.18-decimal fixed-point representation. Requirements: - x must be greater than or equal to MIN_SD59x18 divided by SCALE. - x must be less than or equal to MAX_SD59x18 divided by SCALE. Name Type Description x int256 The basic integer to convert. gm function gm(int256 x, int256 y) internal pure returns (int256 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_SD59x18, lest it overflows. - x * y cannot be negative. Name Type Description x int256 The first operand as a signed 59.18-decimal fixed-point number. y int256 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number. inv function inv(int256 x) internal pure returns (int256 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result int256 The inverse as a signed 59.18-decimal fixed-point number. ln function ln(int256 x) internal pure returns (int256 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result int256 The natural logarithm as a signed 59.18-decimal fixed-point number. log10 function log10(int256 x) internal pure returns (int256 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result int256 The common logarithm as a signed 59.18-decimal fixed-point number. log2 function log2(int256 x) internal pure returns (int256 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than zero. Caveats: - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result int256 The binary logarithm as a signed 59.18-decimal fixed-point number. mul function mul(int256 x, int256 y) internal pure returns (int256 result) Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers and employs constant folding, i.e. the denominator is always 1e18. Requirements: - All from \"PRBMath.mulDivFixedPoint\". - None of the inputs can be MIN_SD59x18 - The result must fit within MAX_SD59x18. Caveats: - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works._ Name Type Description x int256 The multiplicand as a signed 59.18-decimal fixed-point number. y int256 The multiplier as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The product as a signed 59.18-decimal fixed-point number. pi function pi() internal pure returns (int256 result) Returns PI as a signed 59.18-decimal fixed-point number. pow function pow(int256 x, int256 y) internal pure returns (int256 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". - z cannot be zero. Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x int256 Number to raise to given power y, as a signed 59.18-decimal fixed-point number. y int256 Exponent to raise x to, as a signed 59.18-decimal fixed-point number. Name Type Description result int256 x raised to power y, as a signed 59.18-decimal fixed-point number. powu function powu(int256 x, uint256 y) internal pure returns (int256 result) Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - All from \"abs\" and \"PRBMath.mulDivFixedPoint\". - The result must fit within MAX_SD59x18. Caveats: - All from \"PRBMath.mulDivFixedPoint\". - Assumes 0^0 is 1._ Name Type Description x int256 The base as a signed 59.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number. scale function scale() internal pure returns (int256 result) Returns 1 as a signed 59.18-decimal fixed-point number. sqrt function sqrt(int256 x) internal pure returns (int256 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x cannot be negative. - x must be less than MAX_SD59x18 / SCALE._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the square root. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point . toInt function toInt(int256 x) internal pure returns (int256 result) Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x int256 The signed 59.18-decimal fixed-point number to convert. Name Type Description result int256 The same number in basic integer form.","title":"PRBMathSD59x18"},{"location":"PRBMathSD59x18/#prbmathsd59x18","text":"Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18 trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type int256.","title":"PRBMathSD59x18"},{"location":"PRBMathSD59x18/#log2_e","text":"int256 LOG2_E log2(e) as a signed 59.18-decimal fixed-point number.","title":"LOG2_E"},{"location":"PRBMathSD59x18/#half_scale","text":"int256 HALF_SCALE Half the SCALE number.","title":"HALF_SCALE"},{"location":"PRBMathSD59x18/#max_sd59x18","text":"int256 MAX_SD59x18 The maximum value a signed 59.18-decimal fixed-point number can have.","title":"MAX_SD59x18"},{"location":"PRBMathSD59x18/#max_whole_sd59x18","text":"int256 MAX_WHOLE_SD59x18 The maximum whole value a signed 59.18-decimal fixed-point number can have.","title":"MAX_WHOLE_SD59x18"},{"location":"PRBMathSD59x18/#min_sd59x18","text":"int256 MIN_SD59x18 The minimum value a signed 59.18-decimal fixed-point number can have.","title":"MIN_SD59x18"},{"location":"PRBMathSD59x18/#min_whole_sd59x18","text":"int256 MIN_WHOLE_SD59x18 The minimum whole value a signed 59.18-decimal fixed-point number can have.","title":"MIN_WHOLE_SD59x18"},{"location":"PRBMathSD59x18/#scale","text":"int256 SCALE How many trailing decimals can be represented.","title":"SCALE"},{"location":"PRBMathSD59x18/#abs","text":"function abs(int256 x) internal pure returns (int256 result) Calculate the absolute value of x. Requirements: - x must be greater than MIN_SD59x18. Name Type Description x int256 The number to calculate the absolute value for.","title":"abs"},{"location":"PRBMathSD59x18/#avg","text":"function avg(int256 x, int256 y) internal pure returns (int256 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x int256 The first operand as a signed 59.18-decimal fixed-point number. y int256 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The arithmetic average as a signed 59.18-decimal fixed-point number.","title":"avg"},{"location":"PRBMathSD59x18/#ceil","text":"function ceil(int256 x) internal pure returns (int256 result) Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_SD59x18._ Name Type Description x int256 The signed 59.18-decimal fixed-point number to ceil.","title":"ceil"},{"location":"PRBMathSD59x18/#div","text":"function div(int256 x, int256 y) internal pure returns (int256 result) Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers. Works by computing the signs and the absolute values separately. Requirements: - All from \"PRBMath.mulDiv\". - None of the inputs can be MIN_SD59x18. - The denominator cannot be zero. - The result must fit within int256. Caveats: - All from \"PRBMath.mulDiv\"._ Name Type Description x int256 The numerator as a signed 59.18-decimal fixed-point number. y int256 The denominator as a signed 59.18-decimal fixed-point number.","title":"div"},{"location":"PRBMathSD59x18/#e","text":"function e() internal pure returns (int256 result) Returns Euler's number as a signed 59.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._","title":"e"},{"location":"PRBMathSD59x18/#exp","text":"function exp(int256 x) internal pure returns (int256 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 133.084258667509499441. Caveats: - All from \"exp2\". - For any x less than -41.446531673892822322, the result is zero._ Name Type Description x int256 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number.","title":"exp"},{"location":"PRBMathSD59x18/#exp2","text":"function exp2(int256 x) internal pure returns (int256 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_SD59x18. Caveats: - For any x less than -59.794705707972522261, the result is zero._ Name Type Description x int256 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number.","title":"exp2"},{"location":"PRBMathSD59x18/#floor","text":"function floor(int256 x) internal pure returns (int256 result) Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be greater than or equal to MIN_WHOLE_SD59x18._ Name Type Description x int256 The signed 59.18-decimal fixed-point number to floor.","title":"floor"},{"location":"PRBMathSD59x18/#frac","text":"function frac(int256 x) internal pure returns (int256 result) Yields the excess beyond the floor of x for positive numbers and the part of the number to the right of the radix point for negative numbers. Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part Name Type Description x int256 The signed 59.18-decimal fixed-point number to get the fractional part of.","title":"frac"},{"location":"PRBMathSD59x18/#fromint","text":"function fromInt(int256 x) internal pure returns (int256 result) Converts a number from basic integer form to signed 59.18-decimal fixed-point representation. Requirements: - x must be greater than or equal to MIN_SD59x18 divided by SCALE. - x must be less than or equal to MAX_SD59x18 divided by SCALE. Name Type Description x int256 The basic integer to convert.","title":"fromInt"},{"location":"PRBMathSD59x18/#gm","text":"function gm(int256 x, int256 y) internal pure returns (int256 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_SD59x18, lest it overflows. - x * y cannot be negative. Name Type Description x int256 The first operand as a signed 59.18-decimal fixed-point number. y int256 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number.","title":"gm"},{"location":"PRBMathSD59x18/#inv","text":"function inv(int256 x) internal pure returns (int256 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result int256 The inverse as a signed 59.18-decimal fixed-point number.","title":"inv"},{"location":"PRBMathSD59x18/#ln","text":"function ln(int256 x) internal pure returns (int256 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result int256 The natural logarithm as a signed 59.18-decimal fixed-point number.","title":"ln"},{"location":"PRBMathSD59x18/#log10","text":"function log10(int256 x) internal pure returns (int256 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result int256 The common logarithm as a signed 59.18-decimal fixed-point number.","title":"log10"},{"location":"PRBMathSD59x18/#log2","text":"function log2(int256 x) internal pure returns (int256 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than zero. Caveats: - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result int256 The binary logarithm as a signed 59.18-decimal fixed-point number.","title":"log2"},{"location":"PRBMathSD59x18/#mul","text":"function mul(int256 x, int256 y) internal pure returns (int256 result) Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers and employs constant folding, i.e. the denominator is always 1e18. Requirements: - All from \"PRBMath.mulDivFixedPoint\". - None of the inputs can be MIN_SD59x18 - The result must fit within MAX_SD59x18. Caveats: - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works._ Name Type Description x int256 The multiplicand as a signed 59.18-decimal fixed-point number. y int256 The multiplier as a signed 59.18-decimal fixed-point number. Name Type Description result int256 The product as a signed 59.18-decimal fixed-point number.","title":"mul"},{"location":"PRBMathSD59x18/#pi","text":"function pi() internal pure returns (int256 result) Returns PI as a signed 59.18-decimal fixed-point number.","title":"pi"},{"location":"PRBMathSD59x18/#pow","text":"function pow(int256 x, int256 y) internal pure returns (int256 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". - z cannot be zero. Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x int256 Number to raise to given power y, as a signed 59.18-decimal fixed-point number. y int256 Exponent to raise x to, as a signed 59.18-decimal fixed-point number. Name Type Description result int256 x raised to power y, as a signed 59.18-decimal fixed-point number.","title":"pow"},{"location":"PRBMathSD59x18/#powu","text":"function powu(int256 x, uint256 y) internal pure returns (int256 result) Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - All from \"abs\" and \"PRBMath.mulDivFixedPoint\". - The result must fit within MAX_SD59x18. Caveats: - All from \"PRBMath.mulDivFixedPoint\". - Assumes 0^0 is 1._ Name Type Description x int256 The base as a signed 59.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point number.","title":"powu"},{"location":"PRBMathSD59x18/#scale_1","text":"function scale() internal pure returns (int256 result) Returns 1 as a signed 59.18-decimal fixed-point number.","title":"scale"},{"location":"PRBMathSD59x18/#sqrt","text":"function sqrt(int256 x) internal pure returns (int256 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x cannot be negative. - x must be less than MAX_SD59x18 / SCALE._ Name Type Description x int256 The signed 59.18-decimal fixed-point number for which to calculate the square root. Name Type Description result int256 The result as a signed 59.18-decimal fixed-point .","title":"sqrt"},{"location":"PRBMathSD59x18/#toint","text":"function toInt(int256 x) internal pure returns (int256 result) Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x int256 The signed 59.18-decimal fixed-point number to convert. Name Type Description result int256 The same number in basic integer form.","title":"toInt"},{"location":"PRBMathSD59x18Typed/","text":"PRBMathSD59x18Typed Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18 trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type int256. This is the same as PRBMathSD59x18, except that it works with structs instead of raw uint256s. LOG2_E int256 LOG2_E log2(e) as a signed 59.18-decimal fixed-point number. HALF_SCALE int256 HALF_SCALE Half the SCALE number. MAX_SD59x18 int256 MAX_SD59x18 The maximum value a signed 59.18-decimal fixed-point number can have. MAX_WHOLE_SD59x18 int256 MAX_WHOLE_SD59x18 The maximum whole value a signed 59.18-decimal fixed-point number can have. MIN_SD59x18 int256 MIN_SD59x18 The minimum value a signed 59.18-decimal fixed-point number can have. MIN_WHOLE_SD59x18 int256 MIN_WHOLE_SD59x18 The minimum whole value a signed 59.18-decimal fixed-point number can have. SCALE int256 SCALE How many trailing decimals can be represented. abs function abs(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculate the absolute value of x. Requirements: - x must be greater than MIN_SD59x18. Name Type Description x struct PRBMath.SD59x18 The number to calculate the absolute value for. add function add(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Adds two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal fixed-point number. Name Type Description x struct PRBMath.SD59x18 The first summand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The second summand as a signed 59.18-decimal fixed-point number. avg function avg(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x struct PRBMath.SD59x18 The first operand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The arithmetic average as a signed 59.18-decimal fixed-point number. ceil function ceil(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_SD59x18._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to ceil. div function div(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers. Works by computing the signs and the absolute values separately. Requirements: - All from \"PRBMath.mulDiv\". - None of the inputs can be type(int256).min. - The denominator cannot be zero. - The result must fit within int256. Caveats: - All from \"PRBMath.mulDiv\"._ Name Type Description x struct PRBMath.SD59x18 The numerator as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The denominator as a signed 59.18-decimal fixed-point number. e function e() internal pure returns (struct PRBMath.SD59x18 result) Returns Euler's number as a signed 59.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._ exp function exp(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 133.084258667509499441. Caveats: - All from \"exp2\". - For any x less than -41.446531673892822322, the result is zero._ Name Type Description x struct PRBMath.SD59x18 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number. exp2 function exp2(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_SD59x18. Caveats: - For any x less than -59.794705707972522261, the result is zero._ Name Type Description x struct PRBMath.SD59x18 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number. floor function floor(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be greater than or equal to MIN_WHOLE_SD59x18._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to floor. frac function frac(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Yields the excess beyond the floor of x for positive numbers and the part of the number to the right of the radix point for negative numbers. Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to get the fractional part of. fromInt function fromInt(int256 x) internal pure returns (struct PRBMath.SD59x18 result) Converts a number from basic integer form to signed 59.18-decimal fixed-point representation. Requirements: - x must be greater than or equal to MIN_SD59x18 divided by SCALE. - x must be less than or equal to MAX_SD59x18 divided by SCALE. Name Type Description x int256 The basic integer to convert. gm function gm(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_SD59x18, lest it overflows. - x * y cannot be negative. Name Type Description x struct PRBMath.SD59x18 The first operand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number. inv function inv(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result struct PRBMath.SD59x18 The inverse as a signed 59.18-decimal fixed-point number. ln function ln(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result struct PRBMath.SD59x18 The natural logarithm as a signed 59.18-decimal fixed-point number. log10 function log10(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result struct PRBMath.SD59x18 The common logarithm as a signed 59.18-decimal fixed-point number. log2 function log2(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than zero. Caveats: - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result struct PRBMath.SD59x18 The binary logarithm as a signed 59.18-decimal fixed-point number. mul function mul(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers and employs constant folding, i.e. the denominator is always 1e18. Requirements: - All from \"PRBMath.mulDivFixedPoint\". - None of the inputs can be MIN_SD59x18 - The result must fit within MAX_SD59x18. Caveats: - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works._ Name Type Description x struct PRBMath.SD59x18 The multiplicand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The multiplier as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The product as a signed 59.18-decimal fixed-point number. pi function pi() internal pure returns (struct PRBMath.SD59x18 result) Returns PI as a signed 59.18-decimal fixed-point number. pow function pow(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". - z cannot be zero. Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.SD59x18 Number to raise to given power y, as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 Exponent to raise x to, as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 x raised to power y, as a signed 59.18-decimal fixed-point number. powu function powu(struct PRBMath.SD59x18 x, uint256 y) internal pure returns (struct PRBMath.SD59x18 result) Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - All from \"abs\" and \"PRBMath.mulDivFixedPoint\". - The result must fit within MAX_SD59x18. Caveats: - All from \"PRBMath.mulDivFixedPoint\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.SD59x18 The base as a signed 59.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number. scale function scale() internal pure returns (struct PRBMath.SD59x18 result) Returns 1 as a signed 59.18-decimal fixed-point number. sqrt function sqrt(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x cannot be negative. - x must be less than MAX_SD59x18 / SCALE._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the square root. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point . sub function sub(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Subtracts one signed 59.18-decimal fixed-point number from another one, returning a new signed 59.18-decimal fixed-point number. Name Type Description x struct PRBMath.SD59x18 The minuend as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The subtrahend as a signed 59.18-decimal fixed-point number. toInt function toInt(struct PRBMath.SD59x18 x) internal pure returns (int256 result) Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to convert. Name Type Description result int256 The same number in basic integer form.","title":"PRBMathSD59x18Typed"},{"location":"PRBMathSD59x18Typed/#prbmathsd59x18typed","text":"Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18 trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type int256. This is the same as PRBMathSD59x18, except that it works with structs instead of raw uint256s.","title":"PRBMathSD59x18Typed"},{"location":"PRBMathSD59x18Typed/#log2_e","text":"int256 LOG2_E log2(e) as a signed 59.18-decimal fixed-point number.","title":"LOG2_E"},{"location":"PRBMathSD59x18Typed/#half_scale","text":"int256 HALF_SCALE Half the SCALE number.","title":"HALF_SCALE"},{"location":"PRBMathSD59x18Typed/#max_sd59x18","text":"int256 MAX_SD59x18 The maximum value a signed 59.18-decimal fixed-point number can have.","title":"MAX_SD59x18"},{"location":"PRBMathSD59x18Typed/#max_whole_sd59x18","text":"int256 MAX_WHOLE_SD59x18 The maximum whole value a signed 59.18-decimal fixed-point number can have.","title":"MAX_WHOLE_SD59x18"},{"location":"PRBMathSD59x18Typed/#min_sd59x18","text":"int256 MIN_SD59x18 The minimum value a signed 59.18-decimal fixed-point number can have.","title":"MIN_SD59x18"},{"location":"PRBMathSD59x18Typed/#min_whole_sd59x18","text":"int256 MIN_WHOLE_SD59x18 The minimum whole value a signed 59.18-decimal fixed-point number can have.","title":"MIN_WHOLE_SD59x18"},{"location":"PRBMathSD59x18Typed/#scale","text":"int256 SCALE How many trailing decimals can be represented.","title":"SCALE"},{"location":"PRBMathSD59x18Typed/#abs","text":"function abs(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculate the absolute value of x. Requirements: - x must be greater than MIN_SD59x18. Name Type Description x struct PRBMath.SD59x18 The number to calculate the absolute value for.","title":"abs"},{"location":"PRBMathSD59x18Typed/#add","text":"function add(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Adds two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal fixed-point number. Name Type Description x struct PRBMath.SD59x18 The first summand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The second summand as a signed 59.18-decimal fixed-point number.","title":"add"},{"location":"PRBMathSD59x18Typed/#avg","text":"function avg(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x struct PRBMath.SD59x18 The first operand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The arithmetic average as a signed 59.18-decimal fixed-point number.","title":"avg"},{"location":"PRBMathSD59x18Typed/#ceil","text":"function ceil(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_SD59x18._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to ceil.","title":"ceil"},{"location":"PRBMathSD59x18Typed/#div","text":"function div(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers. Works by computing the signs and the absolute values separately. Requirements: - All from \"PRBMath.mulDiv\". - None of the inputs can be type(int256).min. - The denominator cannot be zero. - The result must fit within int256. Caveats: - All from \"PRBMath.mulDiv\"._ Name Type Description x struct PRBMath.SD59x18 The numerator as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The denominator as a signed 59.18-decimal fixed-point number.","title":"div"},{"location":"PRBMathSD59x18Typed/#e","text":"function e() internal pure returns (struct PRBMath.SD59x18 result) Returns Euler's number as a signed 59.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._","title":"e"},{"location":"PRBMathSD59x18Typed/#exp","text":"function exp(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 133.084258667509499441. Caveats: - All from \"exp2\". - For any x less than -41.446531673892822322, the result is zero._ Name Type Description x struct PRBMath.SD59x18 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number.","title":"exp"},{"location":"PRBMathSD59x18Typed/#exp2","text":"function exp2(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_SD59x18. Caveats: - For any x less than -59.794705707972522261, the result is zero._ Name Type Description x struct PRBMath.SD59x18 The exponent as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number.","title":"exp2"},{"location":"PRBMathSD59x18Typed/#floor","text":"function floor(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be greater than or equal to MIN_WHOLE_SD59x18._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to floor.","title":"floor"},{"location":"PRBMathSD59x18Typed/#frac","text":"function frac(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Yields the excess beyond the floor of x for positive numbers and the part of the number to the right of the radix point for negative numbers. Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to get the fractional part of.","title":"frac"},{"location":"PRBMathSD59x18Typed/#fromint","text":"function fromInt(int256 x) internal pure returns (struct PRBMath.SD59x18 result) Converts a number from basic integer form to signed 59.18-decimal fixed-point representation. Requirements: - x must be greater than or equal to MIN_SD59x18 divided by SCALE. - x must be less than or equal to MAX_SD59x18 divided by SCALE. Name Type Description x int256 The basic integer to convert.","title":"fromInt"},{"location":"PRBMathSD59x18Typed/#gm","text":"function gm(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_SD59x18, lest it overflows. - x * y cannot be negative. Name Type Description x struct PRBMath.SD59x18 The first operand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The second operand as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number.","title":"gm"},{"location":"PRBMathSD59x18Typed/#inv","text":"function inv(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result struct PRBMath.SD59x18 The inverse as a signed 59.18-decimal fixed-point number.","title":"inv"},{"location":"PRBMathSD59x18Typed/#ln","text":"function ln(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result struct PRBMath.SD59x18 The natural logarithm as a signed 59.18-decimal fixed-point number.","title":"ln"},{"location":"PRBMathSD59x18Typed/#log10","text":"function log10(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result struct PRBMath.SD59x18 The common logarithm as a signed 59.18-decimal fixed-point number.","title":"log10"},{"location":"PRBMathSD59x18Typed/#log2","text":"function log2(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than zero. Caveats: - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result struct PRBMath.SD59x18 The binary logarithm as a signed 59.18-decimal fixed-point number.","title":"log2"},{"location":"PRBMathSD59x18Typed/#mul","text":"function mul(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal fixed-point number. _Variant of \"mulDiv\" that works with signed numbers and employs constant folding, i.e. the denominator is always 1e18. Requirements: - All from \"PRBMath.mulDivFixedPoint\". - None of the inputs can be MIN_SD59x18 - The result must fit within MAX_SD59x18. Caveats: - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works._ Name Type Description x struct PRBMath.SD59x18 The multiplicand as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The multiplier as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 The product as a signed 59.18-decimal fixed-point number.","title":"mul"},{"location":"PRBMathSD59x18Typed/#pi","text":"function pi() internal pure returns (struct PRBMath.SD59x18 result) Returns PI as a signed 59.18-decimal fixed-point number.","title":"pi"},{"location":"PRBMathSD59x18Typed/#pow","text":"function pow(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". - z cannot be zero. Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.SD59x18 Number to raise to given power y, as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 Exponent to raise x to, as a signed 59.18-decimal fixed-point number. Name Type Description result struct PRBMath.SD59x18 x raised to power y, as a signed 59.18-decimal fixed-point number.","title":"pow"},{"location":"PRBMathSD59x18Typed/#powu","text":"function powu(struct PRBMath.SD59x18 x, uint256 y) internal pure returns (struct PRBMath.SD59x18 result) Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - All from \"abs\" and \"PRBMath.mulDivFixedPoint\". - The result must fit within MAX_SD59x18. Caveats: - All from \"PRBMath.mulDivFixedPoint\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.SD59x18 The base as a signed 59.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point number.","title":"powu"},{"location":"PRBMathSD59x18Typed/#scale_1","text":"function scale() internal pure returns (struct PRBMath.SD59x18 result) Returns 1 as a signed 59.18-decimal fixed-point number.","title":"scale"},{"location":"PRBMathSD59x18Typed/#sqrt","text":"function sqrt(struct PRBMath.SD59x18 x) internal pure returns (struct PRBMath.SD59x18 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x cannot be negative. - x must be less than MAX_SD59x18 / SCALE._ Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number for which to calculate the square root. Name Type Description result struct PRBMath.SD59x18 The result as a signed 59.18-decimal fixed-point .","title":"sqrt"},{"location":"PRBMathSD59x18Typed/#sub","text":"function sub(struct PRBMath.SD59x18 x, struct PRBMath.SD59x18 y) internal pure returns (struct PRBMath.SD59x18 result) Subtracts one signed 59.18-decimal fixed-point number from another one, returning a new signed 59.18-decimal fixed-point number. Name Type Description x struct PRBMath.SD59x18 The minuend as a signed 59.18-decimal fixed-point number. y struct PRBMath.SD59x18 The subtrahend as a signed 59.18-decimal fixed-point number.","title":"sub"},{"location":"PRBMathSD59x18Typed/#toint","text":"function toInt(struct PRBMath.SD59x18 x) internal pure returns (int256 result) Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x struct PRBMath.SD59x18 The signed 59.18-decimal fixed-point number to convert. Name Type Description result int256 The same number in basic integer form.","title":"toInt"},{"location":"PRBMathUD60x18/","text":"PRBMathUD60x18 Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18 trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type uint256. HALF_SCALE uint256 HALF_SCALE Half the SCALE number. LOG2_E uint256 LOG2_E log2(e) as an unsigned 60.18-decimal fixed-point number. MAX_UD60x18 uint256 MAX_UD60x18 The maximum value an unsigned 60.18-decimal fixed-point number can have. MAX_WHOLE_UD60x18 uint256 MAX_WHOLE_UD60x18 The maximum whole value an unsigned 60.18-decimal fixed-point number can have. SCALE uint256 SCALE How many trailing decimals can be represented. avg function avg(uint256 x, uint256 y) internal pure returns (uint256 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x uint256 The first operand as an unsigned 60.18-decimal fixed-point number. y uint256 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The arithmetic average as an unsigned 60.18-decimal fixed-point number. ceil function ceil(uint256 x) internal pure returns (uint256 result) Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_UD60x18._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to ceil. div function div(uint256 x, uint256 y) internal pure returns (uint256 result) Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number. _Uses mulDiv to enable overflow-safe multiplication and division. Requirements: - The denominator cannot be zero._ Name Type Description x uint256 The numerator as an unsigned 60.18-decimal fixed-point number. y uint256 The denominator as an unsigned 60.18-decimal fixed-point number. e function e() internal pure returns (uint256 result) Returns Euler's number as an unsigned 60.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._ exp function exp(uint256 x) internal pure returns (uint256 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 133.084258667509499441._ Name Type Description x uint256 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number. exp2 function exp2(uint256 x) internal pure returns (uint256 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_UD60x18._ Name Type Description x uint256 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number. floor function floor(uint256 x) internal pure returns (uint256 result) Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x. Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to floor. frac function frac(uint256 x) internal pure returns (uint256 result) Yields the excess beyond the floor of x. Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to get the fractional part of. fromUint function fromUint(uint256 x) internal pure returns (uint256 result) Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation. Requirements: - x must be less than or equal to MAX_UD60x18 divided by SCALE. Name Type Description x uint256 The basic integer to convert. gm function gm(uint256 x, uint256 y) internal pure returns (uint256 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_UD60x18, lest it overflows. Name Type Description x uint256 The first operand as an unsigned 60.18-decimal fixed-point number. y uint256 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number. inv function inv(uint256 x) internal pure returns (uint256 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result uint256 The inverse as an unsigned 60.18-decimal fixed-point number. ln function ln(uint256 x) internal pure returns (uint256 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result uint256 The natural logarithm as an unsigned 60.18-decimal fixed-point number. log10 function log10(uint256 x) internal pure returns (uint256 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result uint256 The common logarithm as an unsigned 60.18-decimal fixed-point number. log2 function log2(uint256 x) internal pure returns (uint256 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than or equal to SCALE, otherwise the result would be negative. Caveats: - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result uint256 The binary logarithm as an unsigned 60.18-decimal fixed-point number. mul function mul(uint256 x, uint256 y) internal pure returns (uint256 result) Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal fixed-point number. See the documentation for the \"PRBMath.mulDivFixedPoint\" function. Name Type Description x uint256 The multiplicand as an unsigned 60.18-decimal fixed-point number. y uint256 The multiplier as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The product as an unsigned 60.18-decimal fixed-point number. pi function pi() internal pure returns (uint256 result) Returns PI as an unsigned 60.18-decimal fixed-point number. pow function pow(uint256 x, uint256 y) internal pure returns (uint256 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x uint256 Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number. y uint256 Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 x raised to power y, as an unsigned 60.18-decimal fixed-point number. powu function powu(uint256 x, uint256 y) internal pure returns (uint256 result) Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - The result must fit within MAX_UD60x18. Caveats: - All from \"mul\". - Assumes 0^0 is 1._ Name Type Description x uint256 The base as an unsigned 60.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number. scale function scale() internal pure returns (uint256 result) Returns 1 as an unsigned 60.18-decimal fixed-point number. sqrt function sqrt(uint256 x) internal pure returns (uint256 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x must be less than MAX_UD60x18 / SCALE._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the square root. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point . toUint function toUint(uint256 x) internal pure returns (uint256 result) Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to convert. Name Type Description result uint256 The same number in basic integer form.","title":"PRBMathUD60x18"},{"location":"PRBMathUD60x18/#prbmathud60x18","text":"Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18 trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type uint256.","title":"PRBMathUD60x18"},{"location":"PRBMathUD60x18/#half_scale","text":"uint256 HALF_SCALE Half the SCALE number.","title":"HALF_SCALE"},{"location":"PRBMathUD60x18/#log2_e","text":"uint256 LOG2_E log2(e) as an unsigned 60.18-decimal fixed-point number.","title":"LOG2_E"},{"location":"PRBMathUD60x18/#max_ud60x18","text":"uint256 MAX_UD60x18 The maximum value an unsigned 60.18-decimal fixed-point number can have.","title":"MAX_UD60x18"},{"location":"PRBMathUD60x18/#max_whole_ud60x18","text":"uint256 MAX_WHOLE_UD60x18 The maximum whole value an unsigned 60.18-decimal fixed-point number can have.","title":"MAX_WHOLE_UD60x18"},{"location":"PRBMathUD60x18/#scale","text":"uint256 SCALE How many trailing decimals can be represented.","title":"SCALE"},{"location":"PRBMathUD60x18/#avg","text":"function avg(uint256 x, uint256 y) internal pure returns (uint256 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x uint256 The first operand as an unsigned 60.18-decimal fixed-point number. y uint256 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The arithmetic average as an unsigned 60.18-decimal fixed-point number.","title":"avg"},{"location":"PRBMathUD60x18/#ceil","text":"function ceil(uint256 x) internal pure returns (uint256 result) Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_UD60x18._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to ceil.","title":"ceil"},{"location":"PRBMathUD60x18/#div","text":"function div(uint256 x, uint256 y) internal pure returns (uint256 result) Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number. _Uses mulDiv to enable overflow-safe multiplication and division. Requirements: - The denominator cannot be zero._ Name Type Description x uint256 The numerator as an unsigned 60.18-decimal fixed-point number. y uint256 The denominator as an unsigned 60.18-decimal fixed-point number.","title":"div"},{"location":"PRBMathUD60x18/#e","text":"function e() internal pure returns (uint256 result) Returns Euler's number as an unsigned 60.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._","title":"e"},{"location":"PRBMathUD60x18/#exp","text":"function exp(uint256 x) internal pure returns (uint256 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 133.084258667509499441._ Name Type Description x uint256 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number.","title":"exp"},{"location":"PRBMathUD60x18/#exp2","text":"function exp2(uint256 x) internal pure returns (uint256 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_UD60x18._ Name Type Description x uint256 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number.","title":"exp2"},{"location":"PRBMathUD60x18/#floor","text":"function floor(uint256 x) internal pure returns (uint256 result) Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x. Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to floor.","title":"floor"},{"location":"PRBMathUD60x18/#frac","text":"function frac(uint256 x) internal pure returns (uint256 result) Yields the excess beyond the floor of x. Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to get the fractional part of.","title":"frac"},{"location":"PRBMathUD60x18/#fromuint","text":"function fromUint(uint256 x) internal pure returns (uint256 result) Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation. Requirements: - x must be less than or equal to MAX_UD60x18 divided by SCALE. Name Type Description x uint256 The basic integer to convert.","title":"fromUint"},{"location":"PRBMathUD60x18/#gm","text":"function gm(uint256 x, uint256 y) internal pure returns (uint256 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_UD60x18, lest it overflows. Name Type Description x uint256 The first operand as an unsigned 60.18-decimal fixed-point number. y uint256 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number.","title":"gm"},{"location":"PRBMathUD60x18/#inv","text":"function inv(uint256 x) internal pure returns (uint256 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result uint256 The inverse as an unsigned 60.18-decimal fixed-point number.","title":"inv"},{"location":"PRBMathUD60x18/#ln","text":"function ln(uint256 x) internal pure returns (uint256 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result uint256 The natural logarithm as an unsigned 60.18-decimal fixed-point number.","title":"ln"},{"location":"PRBMathUD60x18/#log10","text":"function log10(uint256 x) internal pure returns (uint256 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result uint256 The common logarithm as an unsigned 60.18-decimal fixed-point number.","title":"log10"},{"location":"PRBMathUD60x18/#log2","text":"function log2(uint256 x) internal pure returns (uint256 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than or equal to SCALE, otherwise the result would be negative. Caveats: - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result uint256 The binary logarithm as an unsigned 60.18-decimal fixed-point number.","title":"log2"},{"location":"PRBMathUD60x18/#mul","text":"function mul(uint256 x, uint256 y) internal pure returns (uint256 result) Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal fixed-point number. See the documentation for the \"PRBMath.mulDivFixedPoint\" function. Name Type Description x uint256 The multiplicand as an unsigned 60.18-decimal fixed-point number. y uint256 The multiplier as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 The product as an unsigned 60.18-decimal fixed-point number.","title":"mul"},{"location":"PRBMathUD60x18/#pi","text":"function pi() internal pure returns (uint256 result) Returns PI as an unsigned 60.18-decimal fixed-point number.","title":"pi"},{"location":"PRBMathUD60x18/#pow","text":"function pow(uint256 x, uint256 y) internal pure returns (uint256 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x uint256 Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number. y uint256 Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number. Name Type Description result uint256 x raised to power y, as an unsigned 60.18-decimal fixed-point number.","title":"pow"},{"location":"PRBMathUD60x18/#powu","text":"function powu(uint256 x, uint256 y) internal pure returns (uint256 result) Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - The result must fit within MAX_UD60x18. Caveats: - All from \"mul\". - Assumes 0^0 is 1._ Name Type Description x uint256 The base as an unsigned 60.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point number.","title":"powu"},{"location":"PRBMathUD60x18/#scale_1","text":"function scale() internal pure returns (uint256 result) Returns 1 as an unsigned 60.18-decimal fixed-point number.","title":"scale"},{"location":"PRBMathUD60x18/#sqrt","text":"function sqrt(uint256 x) internal pure returns (uint256 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x must be less than MAX_UD60x18 / SCALE._ Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number for which to calculate the square root. Name Type Description result uint256 The result as an unsigned 60.18-decimal fixed-point .","title":"sqrt"},{"location":"PRBMathUD60x18/#touint","text":"function toUint(uint256 x) internal pure returns (uint256 result) Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x uint256 The unsigned 60.18-decimal fixed-point number to convert. Name Type Description result uint256 The same number in basic integer form.","title":"toUint"},{"location":"PRBMathUD60x18Typed/","text":"PRBMathUD60x18Typed Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18 trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type uint256. This is the same as PRBMathUD59x18, except that it works with structs instead of raw uint256s. HALF_SCALE uint256 HALF_SCALE Half the SCALE number. LOG2_E uint256 LOG2_E log2(e) as an unsigned 60.18-decimal fixed-point number. MAX_UD60x18 uint256 MAX_UD60x18 The maximum value an unsigned 60.18-decimal fixed-point number can have. MAX_WHOLE_UD60x18 uint256 MAX_WHOLE_UD60x18 The maximum whole value an unsigned 60.18-decimal fixed-point number can have. SCALE uint256 SCALE How many trailing decimals can be represented. add function add(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Adds two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal fixed-point number. Name Type Description x struct PRBMath.UD60x18 The first summand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The second summand as an unsigned 60.18-decimal fixed-point number. avg function avg(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x struct PRBMath.UD60x18 The first operand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The arithmetic average as an unsigned 60.18-decimal fixed-point number. ceil function ceil(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_UD60x18._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to ceil. div function div(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number. _Uses mulDiv to enable overflow-safe multiplication and division. Requirements: - The denominator cannot be zero._ Name Type Description x struct PRBMath.UD60x18 The numerator as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The denominator as an unsigned 60.18-decimal fixed-point number. e function e() internal pure returns (struct PRBMath.UD60x18 result) Returns Euler's number as an unsigned 60.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._ exp function exp(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 88.722839111672999628._ Name Type Description x struct PRBMath.UD60x18 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number. exp2 function exp2(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_UD60x18._ Name Type Description x struct PRBMath.UD60x18 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number. floor function floor(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x. Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to floor. frac function frac(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Yields the excess beyond the floor of x. Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to get the fractional part of. fromUint function fromUint(uint256 x) internal pure returns (struct PRBMath.UD60x18 result) Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation. Requirements: - x must be less than or equal to MAX_UD60x18 divided by SCALE. Name Type Description x uint256 The basic integer to convert. gm function gm(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_UD60x18, lest it overflows. Name Type Description x struct PRBMath.UD60x18 The first operand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number. inv function inv(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result struct PRBMath.UD60x18 The inverse as an unsigned 60.18-decimal fixed-point number. ln function ln(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result struct PRBMath.UD60x18 The natural logarithm as an unsigned 60.18-decimal fixed-point number. log10 function log10(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result struct PRBMath.UD60x18 The common logarithm as an unsigned 60.18-decimal fixed-point number. log2 function log2(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than or equal to SCALE, otherwise the result would be negative. Caveats: - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result struct PRBMath.UD60x18 The binary logarithm as an unsigned 60.18-decimal fixed-point number. mul function mul(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal fixed-point number. See the documentation for the \"PRBMath.mulDivFixedPoint\" function. Name Type Description x struct PRBMath.UD60x18 The multiplicand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The multiplier as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The product as an unsigned 60.18-decimal fixed-point number. pi function pi() internal pure returns (struct PRBMath.UD60x18 result) Returns PI as an unsigned 60.18-decimal fixed-point number. pow function pow(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.UD60x18 Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 x raised to power y, as an unsigned 60.18-decimal fixed-point number. powu function powu(struct PRBMath.UD60x18 x, uint256 y) internal pure returns (struct PRBMath.UD60x18 result) Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - The result must fit within MAX_UD60x18. Caveats: - All from \"mul\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.UD60x18 The base as an unsigned 60.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number. scale function scale() internal pure returns (struct PRBMath.UD60x18 result) Returns 1 as an unsigned 60.18-decimal fixed-point number. sqrt function sqrt(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x must be less than MAX_UD60x18 / SCALE._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the square root. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point . sub function sub(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Subtracts one unsigned 60.18-decimal fixed-point number from another one, returning a new unsigned 60.18-decimal fixed-point number. Name Type Description x struct PRBMath.UD60x18 The minuend as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The subtrahend as an unsigned 60.18-decimal fixed-point number. toUint function toUint(struct PRBMath.UD60x18 x) internal pure returns (uint256 result) Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to convert. Name Type Description result uint256 The same number in basic integer form.","title":"PRBMathUD60x18Typed"},{"location":"PRBMathUD60x18Typed/#prbmathud60x18typed","text":"Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18 trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60 digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the maximum values permitted by the Solidity type uint256. This is the same as PRBMathUD59x18, except that it works with structs instead of raw uint256s.","title":"PRBMathUD60x18Typed"},{"location":"PRBMathUD60x18Typed/#half_scale","text":"uint256 HALF_SCALE Half the SCALE number.","title":"HALF_SCALE"},{"location":"PRBMathUD60x18Typed/#log2_e","text":"uint256 LOG2_E log2(e) as an unsigned 60.18-decimal fixed-point number.","title":"LOG2_E"},{"location":"PRBMathUD60x18Typed/#max_ud60x18","text":"uint256 MAX_UD60x18 The maximum value an unsigned 60.18-decimal fixed-point number can have.","title":"MAX_UD60x18"},{"location":"PRBMathUD60x18Typed/#max_whole_ud60x18","text":"uint256 MAX_WHOLE_UD60x18 The maximum whole value an unsigned 60.18-decimal fixed-point number can have.","title":"MAX_WHOLE_UD60x18"},{"location":"PRBMathUD60x18Typed/#scale","text":"uint256 SCALE How many trailing decimals can be represented.","title":"SCALE"},{"location":"PRBMathUD60x18Typed/#add","text":"function add(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Adds two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal fixed-point number. Name Type Description x struct PRBMath.UD60x18 The first summand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The second summand as an unsigned 60.18-decimal fixed-point number.","title":"add"},{"location":"PRBMathUD60x18Typed/#avg","text":"function avg(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Calculates the arithmetic average of x and y, rounding down. Name Type Description x struct PRBMath.UD60x18 The first operand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The arithmetic average as an unsigned 60.18-decimal fixed-point number.","title":"avg"},{"location":"PRBMathUD60x18Typed/#ceil","text":"function ceil(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x. _Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Requirements: - x must be less than or equal to MAX_WHOLE_UD60x18._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to ceil.","title":"ceil"},{"location":"PRBMathUD60x18Typed/#div","text":"function div(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number. _Uses mulDiv to enable overflow-safe multiplication and division. Requirements: - The denominator cannot be zero._ Name Type Description x struct PRBMath.UD60x18 The numerator as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The denominator as an unsigned 60.18-decimal fixed-point number.","title":"div"},{"location":"PRBMathUD60x18Typed/#e","text":"function e() internal pure returns (struct PRBMath.UD60x18 result) Returns Euler's number as an unsigned 60.18-decimal fixed-point number. See https://en.wikipedia.org/wiki/E (mathematical_constant)._","title":"e"},{"location":"PRBMathUD60x18Typed/#exp","text":"function exp(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the natural exponent of x. _Based on the insight that e^x = 2^(x * log2(e)). Requirements: - All from \"log2\". - x must be less than 88.722839111672999628._ Name Type Description x struct PRBMath.UD60x18 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number.","title":"exp"},{"location":"PRBMathUD60x18Typed/#exp2","text":"function exp2(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the binary exponent of x using the binary fraction method. _See https://ethereum.stackexchange.com/q/79903/24693. Requirements: - x must be 192 or less. - The result must fit within MAX_UD60x18._ Name Type Description x struct PRBMath.UD60x18 The exponent as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number.","title":"exp2"},{"location":"PRBMathUD60x18Typed/#floor","text":"function floor(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x. Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to floor.","title":"floor"},{"location":"PRBMathUD60x18Typed/#frac","text":"function frac(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Yields the excess beyond the floor of x. Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to get the fractional part of.","title":"frac"},{"location":"PRBMathUD60x18Typed/#fromuint","text":"function fromUint(uint256 x) internal pure returns (struct PRBMath.UD60x18 result) Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation. Requirements: - x must be less than or equal to MAX_UD60x18 divided by SCALE. Name Type Description x uint256 The basic integer to convert.","title":"fromUint"},{"location":"PRBMathUD60x18Typed/#gm","text":"function gm(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down. Requirements: - x * y must fit within MAX_UD60x18, lest it overflows. Name Type Description x struct PRBMath.UD60x18 The first operand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The second operand as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number.","title":"gm"},{"location":"PRBMathUD60x18Typed/#inv","text":"function inv(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates 1 / x, rounding toward zero. Requirements: - x cannot be zero. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the inverse. Name Type Description result struct PRBMath.UD60x18 The inverse as an unsigned 60.18-decimal fixed-point number.","title":"inv"},{"location":"PRBMathUD60x18Typed/#ln","text":"function ln(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the natural logarithm of x. _Based on the insight that ln(x) = log2(x) / log2(e). Requirements: - All from \"log2\". Caveats: - All from \"log2\". - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm. Name Type Description result struct PRBMath.UD60x18 The natural logarithm as an unsigned 60.18-decimal fixed-point number.","title":"ln"},{"location":"PRBMathUD60x18Typed/#log10","text":"function log10(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the common logarithm of x. _First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common logarithm based on the insight that log10(x) = log2(x) / log2(10). Requirements: - All from \"log2\". Caveats: - All from \"log2\"._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm. Name Type Description result struct PRBMath.UD60x18 The common logarithm as an unsigned 60.18-decimal fixed-point number.","title":"log10"},{"location":"PRBMathUD60x18Typed/#log2","text":"function log2(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the binary logarithm of x. _Based on the iterative approximation algorithm. https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation Requirements: - x must be greater than or equal to SCALE, otherwise the result would be negative. Caveats: - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm. Name Type Description result struct PRBMath.UD60x18 The binary logarithm as an unsigned 60.18-decimal fixed-point number.","title":"log2"},{"location":"PRBMathUD60x18Typed/#mul","text":"function mul(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal fixed-point number. See the documentation for the \"PRBMath.mulDivFixedPoint\" function. Name Type Description x struct PRBMath.UD60x18 The multiplicand as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The multiplier as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 The product as an unsigned 60.18-decimal fixed-point number.","title":"mul"},{"location":"PRBMathUD60x18Typed/#pi","text":"function pi() internal pure returns (struct PRBMath.UD60x18 result) Returns PI as an unsigned 60.18-decimal fixed-point number.","title":"pi"},{"location":"PRBMathUD60x18Typed/#pow","text":"function pow(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Raises x to the power of y. _Based on the insight that x^y = 2^(log2(x) * y). Requirements: - All from \"exp2\", \"log2\" and \"mul\". Caveats: - All from \"exp2\", \"log2\" and \"mul\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.UD60x18 Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number. Name Type Description result struct PRBMath.UD60x18 x raised to power y, as an unsigned 60.18-decimal fixed-point number.","title":"pow"},{"location":"PRBMathUD60x18Typed/#powu","text":"function powu(struct PRBMath.UD60x18 x, uint256 y) internal pure returns (struct PRBMath.UD60x18 result) Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the famous algorithm \"exponentiation by squaring\". _See https://en.wikipedia.org/wiki/Exponentiation_by_squaring Requirements: - The result must fit within MAX_UD60x18. Caveats: - All from \"mul\". - Assumes 0^0 is 1._ Name Type Description x struct PRBMath.UD60x18 The base as an unsigned 60.18-decimal fixed-point number. y uint256 The exponent as an uint256. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point number.","title":"powu"},{"location":"PRBMathUD60x18Typed/#scale_1","text":"function scale() internal pure returns (struct PRBMath.UD60x18 result) Returns 1 as an unsigned 60.18-decimal fixed-point number.","title":"scale"},{"location":"PRBMathUD60x18Typed/#sqrt","text":"function sqrt(struct PRBMath.UD60x18 x) internal pure returns (struct PRBMath.UD60x18 result) Calculates the square root of x, rounding down. _Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method. Requirements: - x must be less than MAX_UD60x18 / SCALE._ Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number for which to calculate the square root. Name Type Description result struct PRBMath.UD60x18 The result as an unsigned 60.18-decimal fixed-point .","title":"sqrt"},{"location":"PRBMathUD60x18Typed/#sub","text":"function sub(struct PRBMath.UD60x18 x, struct PRBMath.UD60x18 y) internal pure returns (struct PRBMath.UD60x18 result) Subtracts one unsigned 60.18-decimal fixed-point number from another one, returning a new unsigned 60.18-decimal fixed-point number. Name Type Description x struct PRBMath.UD60x18 The minuend as an unsigned 60.18-decimal fixed-point number. y struct PRBMath.UD60x18 The subtrahend as an unsigned 60.18-decimal fixed-point number.","title":"sub"},{"location":"PRBMathUD60x18Typed/#touint","text":"function toUint(struct PRBMath.UD60x18 x) internal pure returns (uint256 result) Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process. Name Type Description x struct PRBMath.UD60x18 The unsigned 60.18-decimal fixed-point number to convert. Name Type Description result uint256 The same number in basic integer form.","title":"toUint"}]}